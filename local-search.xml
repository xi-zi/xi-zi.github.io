<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>2025 0xGame Week1 Pwn</title>
    <link href="/2025/11/11/2025-0xGame-Week1-Pwn/"/>
    <url>/2025/11/11/2025-0xGame-Week1-Pwn/</url>
    
    <content type="html"><![CDATA[<h1 id="0xGame-Week1-Pwn"><a href="#0xGame-Week1-Pwn" class="headerlink" title="0xGame Week1 Pwn"></a>0xGame Week1 Pwn</h1><h2 id="1-Test-your-nc"><a href="#1-Test-your-nc" class="headerlink" title="1.Test your nc"></a>1.Test your nc</h2><p>简单的签到题，熟知nc的用法即可。</p><p><img src="/images/week1-1(1).png" alt="图解"></p><h2 id="2-命令执行"><a href="#2-命令执行" class="headerlink" title="2.命令执行"></a>2.命令执行</h2><p>同样远端连接后，可以直接获取shell，不过过滤了cat和sh指令。通过拼接就可以成功获得flag。</p><p><img src="/images/week1-2(1).png" alt="图解"></p><h2 id="3-Stack-overflow"><a href="#3-Stack-overflow" class="headerlink" title="3.Stack overflow"></a>3.Stack overflow</h2><p>栈溢出。先丢进ida查看，发现backdoor，却是假的，但是whhhat给出了shell。再看main函数，看到了read危险函数，并且存在溢出的机会。</p><p><img src="/images/week1-3(1).png" alt="ida"></p><p><img src="/images/week1-3(2).png" alt="exp"></p><p>简单说一下exp，首先是对pwn工具库的一个调用，之后是对远端的连接，如果是在虚拟机上连接远端环境用remote，如果在物理机上则用connect，调试也可以用process指令。观察ida可以看出距离rbp为0x30又有0x8（64位下）的大小存放rbp，所以距离ret_addr实际上是0x38的大小，所以填充0x38的padding来使函数返回至后门函数，也就是shell的地址（在ida中找出，这里不做演示）。最后getshell。</p><p><img src="/images/week1-3(3).png" alt="图解"></p><h2 id="4-ROP1"><a href="#4-ROP1" class="headerlink" title="4.ROP1"></a>4.ROP1</h2><p>rop链是pwn的一种常见攻击手段，可以上网看看原理。把附件丢进ida中</p><p><img src="/images/week1-4(1).png" alt="ida"></p><p>可以看到有gadget函数，可以在ida中查看gadget的地址为0x40117E，也可以在bash中用指令（ROPgadget –binary “文件名” –only “pop|ret” | grep “rdi”）获得地址。</p><p><img src="/images/week1-4(4).png" alt="rdi"></p><p>由于在ida中找不到sh相关的字符串，于是可以从gdb中获取（当然选择在help中用偏移也是可以打通的）</p><p><img src="/images/week1-4(2).png" alt="sh"></p><p>从而可以构造exp</p><p><img src="/images/week1-4(3).png" alt="exp"></p><h5 id="由于ubuntu的版本，所以这里需要进行栈对齐，也就是payload中p64-ret-的由来。"><a href="#由于ubuntu的版本，所以这里需要进行栈对齐，也就是payload中p64-ret-的由来。" class="headerlink" title="由于ubuntu的版本，所以这里需要进行栈对齐，也就是payload中p64(ret)的由来。"></a>由于ubuntu的版本，所以这里需要进行栈对齐，也就是payload中p64(ret)的由来。</h5><p>这里的ret是任意的一个ret_addr，因为其大小为1，所以可以起到一个对齐的作用。（因为我也不完全清楚其背后的原理QAQ）</p><h2 id="5-ROP2"><a href="#5-ROP2" class="headerlink" title="5.ROP2"></a>5.ROP2</h2><p>这道题的解法其实和上一道rop1类似，不过由于过滤掉了sh，bash等sh类指令，所以这边可以联想到$0这个神奇的参数也可以起到一个shell的作用。</p><p><img src="/images/week1-5(1).png" alt="$0"></p><p>exp如下图</p><p><img src="/images/week1-5(2).png" alt="exp"></p><p>week1至此结束，至于还有一道简单数学题，对python语法要求较高，我就不在此叙述。（绝对不是我菜QWQ）</p>]]></content>
    
    
    <categories>
      
      <category>ctf-pwn</category>
      
    </categories>
    
    
    <tags>
      
      <tag>pwn入门</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
